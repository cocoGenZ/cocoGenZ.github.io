{"title":"solidity进阶","uid":"26cdbf141378457625c3c7f264148e8f","slug":"solidity进阶","date":"2022-12-07T15:23:57.000Z","updated":"2022-12-07T15:25:33.484Z","comments":true,"path":"api/articles/solidity进阶.json","keywords":null,"cover":[],"content":"<h1 id=\"solidity进阶\">solidity进阶</h1>\r\n<h2 id=\"函数重载\">16.函数重载</h2>\r\n<h3 id=\"重载\">重载</h3>\r\n<p><code>solidity</code>中允许函数进行重载（<code>overloading</code>），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为<strong>不同</strong>的函数。注意，<code>solidity</code>不允许修饰器（<code>modifier</code>）重载。</p>\r\n<h3 id=\"函数重载-1\">函数重载</h3>\r\n<p>举个例子，我们可以定义两个都叫<code>saySomething()</code>的函数，一个没有任何参数，输出<code>\"Nothing\"</code>；另一个接收一个<code>string</code>参数，输出这个<code>string</code>。</p>\r\n<pre class=\"solidity\"><code>function saySomething() public pure returns(string memory){\r\n    return(\"Nothing\");\r\n}\r\n\r\nfunction saySomething(string memory something) public pure returns(string memory){\r\n    return(something);\r\n}</code></pre>\r\n<p>最终重载函数在经过编译器编译后，由于不同的参数类型，都变成了不同的函数选择器（selector）。(选择器在29的内容)</p>\r\n<h3 id=\"实参匹配argument-matching\">实参匹配（Argument Matching）</h3>\r\n<p>在调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配。\r\n如果出现多个匹配的重载函数，则会报错。下面这个例子有两个叫<code>f()</code>的函数，一个参数为<code>uint8</code>，另一个为<code>uint256</code>：</p>\r\n<pre class=\"solidity\"><code>    function f(uint8 _in) public pure returns (uint8 out) {\r\n        out = _in;\r\n    }\r\n\r\n    function f(uint256 _in) public pure returns (uint256 out) {\r\n        out = _in;\r\n    }</code></pre>\r\n<p>我们调用<code>f(50)</code>，因为<code>50</code>既可以被转换为<code>uint8</code>，也可以被转换为<code>uint256</code>，因此会报错。</p>\r\n<h2 id=\"库合约\">17.库合约</h2>\r\n<h3 id=\"库函数\">库函数</h3>\r\n<p>库函数是一种特殊的合约，为了提升<code>solidity</code>代码的复用性和减少<code>gas</code>而存在。库合约一般都是一些好用的函数合集（<code>库函数</code>），由大神或者项目方创作，咱们站在巨人的肩膀上，会用就行了。</p>\r\n<p>库函数和普通合约的不同：<br>\r\n1.不能存在状态变量<br>\r\n2.不能够继承或被继承<br>\r\n3.不能接受以太币<br>\r\n4.不可以被销毁</p>\r\n<h3 id=\"string库合约\">String库合约</h3>\r\n<p><code>String库合约</code>是将<code>uint256</code>类型转换为相应的<code>string</code>类型的代码库，样例代码如下：</p>\r\n<pre class=\"solidity\"><code>library Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) public pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) public pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp &gt;&gt;= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) public pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i &gt; 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value &amp; 0xf];\r\n            value &gt;&gt;= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}</code></pre>\r\n<p>他主要包含两个函数，<code>toString()</code>将<code>uint256</code>转为<code>string</code>，<code>toHexString()</code>将<code>uint256</code>转换为<code>16进制</code>，在转换为<code>string</code>。</p>\r\n<h3 id=\"如何使用库合约\">如何使用库合约</h3>\r\n<p><strong>1.利用using for指令</strong></p>\r\n<p>指令<code>using A for B;</code>可用于附加库函数（从库\r\nA）到任何类型（B）。添加完指令后，库<code>A</code>中的函数会自动添加为<code>B</code>类型变量的成员，可以直接调用。注意：在调用的时候，这个变量会被当作第一个参数传递给函数：</p>\r\n<pre class=\"solidity\"><code>    // 利用using for指令\r\n    using Strings for uint256;\r\n    function getString1(uint256 _number) public pure returns(string memory){\r\n        // 库函数会自动添加为uint256型变量的成员\r\n        return _number.toHexString();\r\n    }</code></pre>\r\n<p><strong>2.通过库合约名称调用库函数</strong></p>\r\n<pre class=\"solidity\"><code>    // 直接通过库合约名调用\r\n    function getString2(uint256 _number) public pure returns(string memory){\r\n        return Strings.toHexString(_number);\r\n    }</code></pre>\r\n<ol type=\"1\">\r\n<li><a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Strings.sol\">String</a>：将<code>uint256</code>转换为<code>String</code></li>\r\n<li><a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Address.sol\">Address</a>：判断某个地址是否为合约地址</li>\r\n<li><a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Create2.sol\">Create2</a>：更安全的使用<code>Create2 EVM opcode</code></li>\r\n<li><a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Arrays.sol\">Arrays</a>：跟数组相关的库函数</li>\r\n</ol>\r\n<h2 id=\"import\">18.Import</h2>\r\n<p><code>solidity</code>支持利用<code>import</code>关键字导入其他源代码中的合约，让开发更加模块化。</p>\r\n<h3 id=\"import用法\"><code>import</code>用法</h3>\r\n<ul>\r\n<li>通过源文件相对位置导入，eg：</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>文件结构\r\n├── Import.sol\r\n└── Yeye.sol\r\n\r\n// 通过文件相对位置import\r\nimport './Yeye.sol';</code></pre>\r\n<ul>\r\n<li>通过源文件网址导入网上的合约，eg：</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>// 通过网址引用\r\nimport 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol';</code></pre>\r\n<ul>\r\n<li>通过<code>npm</code>的目录导入，eg：</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>import '@openzeppelin/contracts/access/Ownable.sol';</code></pre>\r\n<ul>\r\n<li>通过<code>全局符号</code>导入特定的合约，eg：</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>import {Yeye} from './Yeye.sol';</code></pre>\r\n<ul>\r\n<li>引用(<code>import</code>)在代码中的位置为：在<strong>声明版本号之后</strong>，在<strong>其余代码之前</strong>。</li>\r\n</ul>\r\n<h2 id=\"接受eth\">19.接受ETH</h2>\r\n<p><code>Solidity</code>支持两种特殊的回调函数，<code>receive()</code>和<code>fallback()</code>，他们主要在两种情况下被使用：</p>\r\n<ol type=\"1\">\r\n<li>接收ETH</li>\r\n<li>处理合约中不存在的函数调用（代理合约proxy contract）</li>\r\n</ol>\r\n<p>注意⚠️：在solidity 0.6.x版本之前，语法上只有 <code>fallback()</code>\r\n函数，用来接收用户发送的ETH时调用以及在被调用函数签名没有匹配到时，来调用。\r\n0.6版本之后，solidity才将 <code>fallback()</code> 函数拆分成\r\n<code>receive()</code> 和 <code>fallback()</code> 两个函数。</p>\r\n<h3 id=\"接受eth函数receive\">接受ETH函数receive</h3>\r\n<p><code>receive()</code>只用于处理接收<code>ETH</code>。一个合约最多有一个<code>receive()</code>函数，声明方式与一般函数不一样，不需要<code>function</code>关键字：<code>receive() external payable { ... }</code>。<code>receive()</code>函数<strong>不能有任何的参数</strong>，<strong>不能返回任何值</strong>，<strong>必须包含<code>external</code>和<code>payable</code></strong>。</p>\r\n<p>当合约接收ETH的时候，<code>receive()</code>会被触发。<code>receive()</code>最好不要执行太多的逻辑因为如果别人用<code>send</code>和<code>transfer</code>方法发送<code>ETH</code>的话，<code>gas</code>会限制在<code>2300</code>，<code>receive()</code>太复杂可能会触发<code>Out of Gas</code>报错；如果用<code>call</code>就可以自定义<code>gas</code>执行更复杂的逻辑（这三种发送ETH的方法我们之后会讲到）。</p>\r\n<p>可以在<code>receive()</code>里发送一个<code>event</code>，eg：</p>\r\n<pre class=\"solidity\"><code>    // 定义事件\r\n    event Received(address Sender, uint Value);\r\n    // 接收ETH时释放Received事件\r\n    receive() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }</code></pre>\r\n<p>有些恶意合约，会在<code>receive()</code> 函数（老版本的话，就是\r\n<code>fallback()</code>\r\n函数）嵌入恶意消耗<code>gas</code>的内容或者使得执行故意失败的代码，导致一些包含退款和转账逻辑的合约不能正常工作，因此写包含退款等逻辑的合约时候，一定要注意这种情况。</p>\r\n<h3 id=\"回退函数fallback\">回退函数fallback</h3>\r\n<p><code>fallback()</code>函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约<code>proxy contract</code>。<code>fallback()</code>声明时不需要<code>function</code>关键字，<strong>必须由<code>external</code>修饰</strong>，一般也会用<code>payable</code>修饰，用于接收ETH:<code>fallback() external payable { ... }</code>。</p>\r\n<p>我们定义一个<code>fallback()</code>函数，被触发时候会释放<code>fallbackCalled</code>事件，并输出<code>msg.sender</code>，<code>msg.value</code>和<code>msg.data</code>:</p>\r\n<pre class=\"solidity\"><code>    // fallback\r\n    fallback() external payable{\r\n        emit fallbackCalled(msg.sender, msg.value, msg.data);\r\n    }</code></pre>\r\n<h3 id=\"receive和fallback的区别\">receive和fallback的区别</h3>\r\n<p><code>receive</code>和<code>fallback</code>都能够用于接收<code>ETH</code>，他们触发的规则如下：</p>\r\n<pre class=\"text\"><code>触发fallback() 还是 receive()?\r\n           接收ETH\r\n              |\r\n         msg.data是空？\r\n            /  \\\r\n          是    否\r\n          /      \\\r\nreceive()存在?   fallback()\r\n        / \\\r\n       是  否\r\n      /     \\\r\nreceive()   fallback()</code></pre>\r\n<p>简单来说，合约接收<code>ETH</code>时，<code>msg.data</code>为空且存在<code>receive()</code>时，会触发<code>receive()</code>；<code>msg.data</code>不为空或不存在<code>receive()</code>时，会触发<code>fallback()</code>，此时<code>fallback()</code>必须为<code>payable</code>。</p>\r\n<p><code>receive()</code>和<code>payable fallback()</code>均不存在的时候，向合约发送<code>ETH</code>将会报错。</p>\r\n<h2 id=\"发送eth\">20.发送ETH</h2>\r\n<h3 id=\"接受eth合约\">接受ETH合约</h3>\r\n<p>我们先部署一个接收<code>ETH</code>合约<code>ReceiveETH</code>。<code>ReceiveETH</code>合约里有一个事件<code>Log</code>，记录收到的<code>ETH</code>数量和<code>gas</code>剩余。还有两个函数，一个是<code>receive()</code>函数，收到<code>ETH</code>被触发，并发送<code>Log</code>事件；另一个是查询合约<code>ETH</code>余额的<code>getBalance()</code>函数。</p>\r\n<pre class=\"solidity\"><code>contract ReceiveETH {\r\n    // 收到eth事件，记录amount和gas\r\n    event Log(uint amount, uint gas);\r\n    \r\n    // receive方法，接收eth时被触发\r\n    receive() external payable{\r\n        emit Log(msg.value, gasleft());\r\n    }\r\n    \r\n    // 返回合约ETH余额\r\n    function getBalance() view public returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n}</code></pre>\r\n<p>部署<code>ReceiveETH</code>合约后，运行<code>getBalance()</code>函数，可以看到当前合约的<code>ETH</code>余额为<code>0</code>。</p>\r\n<h3 id=\"发送eth合约\">发送ETH合约</h3>\r\n<p>我们将实现三种方法向<code>ReceiveETH</code>合约发送<code>ETH</code>。首先，先在发送ETH合约<code>SendETH</code>中实现<code>payable</code>的<code>构造函数</code>和<code>receive()</code>，让我们能够在部署时和部署后向合约转账。</p>\r\n<pre class=\"solidity\"><code>contract SendETH {\r\n    // 构造函数，payable使得部署的时候可以转eth进去\r\n    constructor() payable{}\r\n    // receive方法，接收eth时被触发\r\n    receive() external payable{}\r\n}</code></pre>\r\n<h3 id=\"transfer\">transfer</h3>\r\n<ul>\r\n<li>用法是<code>接收方地址.transfer(发送ETH数额)</code>。</li>\r\n<li><code>transfer()</code>的<code>gas</code>限制是<code>2300</code>，足够用于转账，但对方合约的<code>fallback()</code>或<code>receive()</code>函数不能实现太复杂的逻辑。</li>\r\n<li><code>transfer()</code>如果转账失败，会自动<code>revert</code>（回滚交易）。</li>\r\n</ul>\r\n<p>代码样例，注意里面的<code>_to</code>填<code>ReceiveETH</code>合约的地址，<code>amount</code>是<code>ETH</code>转账金额：</p>\r\n<pre class=\"solidity\"><code>// 用transfer()发送ETH\r\nfunction transferETH(address payable _to, uint256 amount) external payable{\r\n    _to.transfer(amount);\r\n}</code></pre>\r\n<h3 id=\"send\">send</h3>\r\n<ul>\r\n<li>用法是<code>接收方地址.send(发送ETH数额)</code>。</li>\r\n<li><code>send()</code>的<code>gas</code>限制是<code>2300</code>，足够用于转账，但对方合约的<code>fallback()</code>或<code>receive()</code>函数不能实现太复杂的逻辑。</li>\r\n<li><code>send()</code>如果转账失败，不会<code>revert</code>。</li>\r\n<li><code>send()</code>的返回值是<code>bool</code>，代表着转账成功或失败，需要额外代码处理一下。</li>\r\n</ul>\r\n<p>代码样例：</p>\r\n<pre class=\"solidity\"><code>// send()发送ETH\r\nfunction sendETH(address payable _to, uint256 amount) external payable{\r\n    // 处理下send的返回值，如果失败，revert交易并发送error\r\n    bool success = _to.send(amount);\r\n    if(!success){\r\n        revert SendFailed();\r\n    }\r\n}</code></pre>\r\n<h3 id=\"call\">call</h3>\r\n<ul>\r\n<li>用法是<code>接收方地址.call{value: 发送ETH数额}(\"\")</code>。</li>\r\n<li><code>call()</code>没有<code>gas</code>限制，可以支持对方合约<code>fallback()</code>或<code>receive()</code>函数实现复杂逻辑。</li>\r\n<li><code>call()</code>如果转账失败，不会<code>revert</code>。</li>\r\n<li><code>call()</code>的返回值是<code>(bool, data)</code>，其中<code>bool</code>代表着转账成功或失败，需要额外代码处理一下。</li>\r\n</ul>\r\n<p>代码样例：</p>\r\n<pre class=\"solidity\"><code>// call()发送ETH\r\nfunction callETH(address payable _to, uint256 amount) external payable{\r\n    // 处理下call的返回值，如果失败，revert交易并发送error\r\n    (bool success,) = _to.call{value: amount}(\"\");\r\n    if(!success){\r\n        revert CallFailed();\r\n    }\r\n}</code></pre>\r\n<h3 id=\"三者的选择\">三者的选择</h3>\r\n<ul>\r\n<li><code>call</code>没有<code>gas</code>限制，最为灵活，是最提倡的方法；</li>\r\n<li><code>transfer</code>有<code>2300 gas</code>限制，但是发送失败会自动<code>revert</code>交易，是次优选择；</li>\r\n<li><code>send</code>有<code>2300 gas</code>限制，而且发送失败不会自动<code>revert</code>交易，几乎没有人用它。</li>\r\n</ul>\r\n<h2 id=\"调用其他合约\">21.调用其他合约</h2>\r\n<p><strong>调用已部署合约</strong></p>\r\n<p>开发者写智能合约来调用其他合约，这让以太坊网络上的程序可以复用，从而建立繁荣的生态。很多<code>web3</code>项目依赖于调用其他合约，比如收益农场（<code>yield farming</code>）。这一讲，我们介绍如何在已知合约代码（或接口）和地址情况下调用目标合约的函数。</p>\r\n<h3 id=\"目标合约\">目标合约</h3>\r\n<p>先写一个简单的合约<code>OtherContract</code>来调用。</p>\r\n<pre class=\"solidity\"><code>contract OtherContract {\r\n    uint256 private _x = 0; // 状态变量_x\r\n    // 收到eth的事件，记录amount和gas\r\n    event Log(uint amount, uint gas);\r\n    \r\n    // 返回合约ETH余额\r\n    function getBalance() view public returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)\r\n    function setX(uint256 x) external payable{\r\n        _x = x;\r\n        // 如果转入ETH，则释放Log事件\r\n        if(msg.value &gt; 0){\r\n            emit Log(msg.value, gasleft());\r\n        }\r\n    }\r\n\r\n    // 读取_x\r\n    function getX() external view returns(uint x){\r\n        x = _x;\r\n    }\r\n}</code></pre>\r\n<p>这个合约包含一个状态变量<code>_x</code>，一个事件<code>Log</code>在收到<code>ETH</code>时触发，三个函数：</p>\r\n<ul>\r\n<li><code>getBalance()</code>: 返回合约<code>ETH</code>余额。</li>\r\n<li><code>setX()</code>:\r\n<code>external payable</code>函数，可以设置<code>_x</code>的值，并向合约发送<code>ETH</code>。</li>\r\n<li><code>getX()</code>: 读取<code>_x</code>的值。</li>\r\n</ul>\r\n<h3 id=\"调用othercontract合约\">调用<code>OtherContract</code>合约</h3>\r\n<p>（先贴个源码吧，本来以为要创建两个文件的，只要一个文件部署两个合约就可以了）</p>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ncontract OtherContract {\r\n    uint256 private _x = 0; // 状态变量x\r\n    // 收到eth事件，记录amount和gas\r\n    event Log(uint amount, uint gas);\r\n    \r\n    // 返回合约ETH余额\r\n    function getBalance() view public returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)\r\n    function setX(uint256 x) external payable{\r\n        _x = x;\r\n        // 如果转入ETH，则释放Log事件\r\n        if(msg.value &gt; 0){\r\n            emit Log(msg.value, gasleft());\r\n        }\r\n    }\r\n\r\n    // 读取x\r\n    function getX() external view returns(uint x){\r\n        x = _x;\r\n    }\r\n}\r\n\r\ncontract CallContract{\r\n    function callSetX(address _Address, uint256 x) external{\r\n        OtherContract(_Address).setX(x);\r\n    }\r\n\r\n    function callGetX(OtherContract _Address) external view returns(uint x){\r\n        x = _Address.getX();\r\n    }\r\n\r\n    function callGetX2(address _Address) external view returns(uint x){\r\n        OtherContract oc = OtherContract(_Address);\r\n        x = oc.getX();\r\n    }\r\n\r\n    function setXTransferETH(address otherContract, uint256 x) payable external{\r\n        OtherContract(otherContract).setX{value: msg.value}(x);\r\n    }\r\n}</code></pre>\r\n<p>我们可以利用合约的地址和合约代码（或接口）来创建合约的引用：<code>_Name(_Address)</code>，其中<code>_Name</code>是合约名，<code>_Address</code>是合约地址。然后用合约的引用来调用它的函数：<code>_Name(_Address).f()</code>，其中<code>f()</code>是要调用的函数。</p>\r\n<p>下面我们介绍4个调用合约的例子，在remix中编译合约后，分别部署<code>OtherContract</code>和<code>CallContract</code>：(还没怎么搞得懂)<br>\r\n<img src=\"https://wtf.academy/assets/images/21-1-9c522c370dfc53d1a0c273716f949c9e.png\"><br>\r\n<img src=\"https://wtf.academy/assets/images/21-2-a3c672e6dca937bf09dc3dfe5a421534.png\"><br>\r\n<img src=\"https://wtf.academy/assets/images/21-3-dd0cfc401d8462761c9b740ec21aa994.png\"></p>\r\n<h4 id=\"传入合约地址\">1.传入合约地址</h4>\r\n<p>我们可以在函数里传入目标合约地址，生成目标合约的引用，然后调用目标函数。以调用<code>OtherContract</code>合约的<code>setX</code>函数为例，我们在新合约中写一个<code>callSetX</code>函数，传入已部署好的<code>OtherContract</code>合约地址<code>_Address</code>和<code>setX</code>的参数<code>x</code>：</p>\r\n<pre class=\"solidity\"><code>    function callSetX(address _Address, uint256 x) external{\r\n        OtherContract(_Address).setX(x);\r\n    }</code></pre>\r\n<p>复制<code>OtherContract</code>合约的地址，填入<code>callSetX</code>函数的参数中，成功调用后，调用<code>OtherContract</code>合约中的<code>getX</code>验证<code>x</code>变为123<br>\r\n<img src=\"https://wtf.academy/assets/images/21-4-89e705ffc18c8f90063c922e7504b31e.png\"><br>\r\n<img src=\"https://wtf.academy/assets/images/21-5-52866e87f467b4ebad52d6d00d4d2744.png\"></p>\r\n<h4 id=\"传入合约变量\">2.传入合约变量</h4>\r\n<p>我们可以直接在函数里传入合约的引用，只需要把上面参数的<code>address</code>类型改为目标合约名，比如<code>OtherContract</code>。下面例子实现了调用目标合约的<code>getX()</code>函数。</p>\r\n<p><strong>注意</strong>该函数参数<code>OtherContract _Address</code>底层类型仍然是<code>address</code>，生成的<code>ABI</code>中、调用<code>callGetX</code>时传入的参数都是<code>address</code>类型</p>\r\n<pre class=\"solidity\"><code>    function callGetX(OtherContract _Address) external view returns(uint x){\r\n        x = _Address.getX();\r\n    }</code></pre>\r\n<p>复制<code>OtherContract</code>合约的地址，填入<code>callGetX</code>函数的参数中，调用后成功获取<code>x</code>的值<br>\r\n<img src=\"https://wtf.academy/assets/images/21-6-615b6ab5f73c18a1c4a7a7d0be5f7228.png\"></p>\r\n<h4 id=\"创建合约变量\">3.创建合约变量</h4>\r\n<p>我们可以创建合约变量，然后通过它来调用目标函数。下面例子，我们给变量<code>oc</code>存储了<code>OtherContract</code>合约的引用：</p>\r\n<pre class=\"solidity\"><code>    function callGetX2(address _Address) external view returns(uint x){\r\n        OtherContract oc = OtherContract(_Address);\r\n        x = oc.getX();\r\n    }</code></pre>\r\n<p>复制<code>OtherContract</code>合约的地址，填入<code>callGetX2</code>函数的参数中，调用后成功获取<code>x</code>的值<br>\r\n<img src=\"https://wtf.academy/assets/images/21-7-ab9a5e3d84b27006392eb368b1e93d2d.png\"></p>\r\n<h4 id=\"调用合约并发送eth\">4.调用合约并发送<code>ETH</code></h4>\r\n<p>如果目标合约的函数是<code>payable</code>的，那么我们可以通过调用它来给合约转账：<code>_Name(_Address).f{value: _Value}()</code>，其中<code>_Name</code>是合约名，<code>_Address</code>是合约地址，<code>f</code>是目标函数名，<code>_Value</code>是要转的<code>ETH</code>数额（以<code>wei</code>为单位）。</p>\r\n<p><code>OtherContract</code>合约的<code>setX</code>函数是<code>payable</code>的，在下面这个例子中我们通过调用<code>setX</code>来往目标合约转账。</p>\r\n<pre class=\"solidity\"><code>    function setXTransferETH(address otherContract, uint256 x) payable external{\r\n        OtherContract(otherContract).setX{value: msg.value}(x);\r\n    }</code></pre>\r\n<p>复制<code>OtherContract</code>合约的地址，填入<code>setXTransferETH</code>函数的参数中，并转入10ETH<br>\r\n<img src=\"https://wtf.academy/assets/images/21-8-3566ee52a32b536dded77112c6599bdb.png\"></p>\r\n<p>转账后，我们可以通过<code>Log</code>事件和<code>getBalance()</code>函数观察目标合约<code>ETH</code>余额的变化。<br>\r\n<img src=\"https://wtf.academy/assets/images/21-9-d90c3bad37dd4d77acbd2ea8b695242e.png\"></p>\r\n<h2 id=\"call-1\">22.Call</h2>\r\n<p><code>call</code>\r\n是<code>address</code>类型的低级成员函数，它用来与其他合约交互。它的返回值为<code>(bool, data)</code>，分别对应<code>call</code>是否成功以及目标函数的返回值。</p>\r\n<ul>\r\n<li><code>call</code>是<code>solidity</code>官方推荐的通过触发<code>fallback</code>或<code>receive</code>函数发送<code>ETH</code>的方法。</li>\r\n<li>不推荐用<code>call</code>来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数，见<a href=\"https://github.com/AmazingAng/WTFSolidity/tree/main/21_CallContract\">第21讲：调用其他合约</a></li>\r\n<li>当我们不知道对方合约的源代码或<code>ABI</code>，就没法生成合约变量；这时，我们仍可以通过<code>call</code>调用对方合约的函数。</li>\r\n</ul>\r\n<h3 id=\"call的使用规则\"><code>call</code>的使用规则</h3>\r\n<p><code>目标合约地址.call(二进制编码);</code></p>\r\n<p>其中<code>二进制编码</code>利用结构化编码函数<code>abi.encodeWithSignature</code>获得：</p>\r\n<pre class=\"text\"><code>abi.encodeWithSignature(\"函数签名\", 逗号分隔的具体参数)</code></pre>\r\n<p><code>函数签名</code>为<code>\"函数名（逗号分隔的参数类型)\"</code>。例如<code>abi.encodeWithSignature(\"f(uint256,address)\", _x, _addr)</code>。</p>\r\n<p>另外<code>call</code>在调用合约时可以指定交易发送的<code>ETH</code>数额和<code>gas</code>：</p>\r\n<pre class=\"text\"><code>目标合约地址.call{value:发送数额, gas:gas数额}(二进制编码);</code></pre>\r\n<p>(看不懂......举个栗子康康)</p>\r\n<h3 id=\"目标合约-1\">目标合约</h3>\r\n<p>先写一个简单的目标合约<code>OtherContract</code>并部署，代码与第19讲中基本相同，只是多了<code>fallback</code>函数。</p>\r\n<pre class=\"solidity\"><code>contract OtherContract {\r\n    uint256 private _x = 0; // 状态变量x\r\n    // 收到eth的事件，记录amount和gas\r\n    event Log(uint amount, uint gas);\r\n    \r\n    fallback() external payable{}\r\n\r\n    // 返回合约ETH余额\r\n    function getBalance() view public returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)\r\n    function setX(uint256 x) external payable{\r\n        _x = x;\r\n        // 如果转入ETH，则释放Log事件\r\n        if(msg.value &gt; 0){\r\n            emit Log(msg.value, gasleft());\r\n        }\r\n    }\r\n\r\n    // 读取x\r\n    function getX() external view returns(uint x){\r\n        x = _x;\r\n    }\r\n}</code></pre>\r\n<p>这个合约包含一个状态变量<code>x</code>，一个在收到<code>ETH</code>时触发的事件<code>Log</code>，三个函数：</p>\r\n<ul>\r\n<li><code>getBalance()</code>: 返回合约<code>ETH</code>余额。</li>\r\n<li><code>setX()</code>:\r\n<code>external payable</code>函数，可以设置<code>x</code>的值，并向合约发送<code>ETH</code>。</li>\r\n<li><code>getX()</code>: 读取<code>x</code>的值。</li>\r\n</ul>\r\n<h3 id=\"利用call调用目标合约\">利用<code>call</code>调用目标合约</h3>\r\n<p><strong>1.Response事件</strong></p>\r\n<p>我们写一个<code>Call</code>合约来调用目标合约函数。首先定义一个<code>Response</code>事件，输出<code>call</code>返回的<code>success</code>和<code>data</code>，方便我们观察返回值。</p>\r\n<pre class=\"solidity\"><code>// 定义Response事件，输出call返回的结果success和data\r\nevent Response(bool success, bytes data);</code></pre>\r\n<p><strong>2.调用setX函数</strong></p>\r\n<p>我们定义<code>callSetX</code>函数来调用目标合约的<code>setX()</code>，转入<code>msg.value</code>数额的<code>ETH</code>，并释放<code>Response</code>事件输出<code>success</code>和<code>data</code>：</p>\r\n<pre class=\"solidity\"><code>function callSetX(address payable _addr, uint256 x) public payable {\r\n    // call setX()，同时可以发送ETH\r\n    (bool success, bytes memory data) = _addr.call{value: msg.value}(\r\n        abi.encodeWithSignature(\"setX(uint256)\", x)\r\n    );\r\n\r\n    emit Response(success, data); //释放事件\r\n}</code></pre>\r\n<p>接下来我们调用<code>callSetX</code>把状态变量<code>_x</code>改为5，参数为<code>OtherContract</code>地址和<code>5</code>，由于目标函数<code>setX()</code>没有返回值，因此<code>Response</code>事件输出的<code>data</code>为<code>0x</code>，也就是空。<br>\r\n<img src=\"https://wtf.academy/assets/images/22-1-c8df2a8eb61086564f7e7bd4346ae8a8.png\"></p>\r\n<p><strong>3.调用getX函数</strong></p>\r\n<p>下面我们调用<code>getX()</code>函数，它将返回目标合约<code>_x</code>的值，类型为<code>uint256</code>。我们可以利用<code>abi.decode</code>来解码<code>call</code>的返回值<code>data</code>，并读出数值。</p>\r\n<pre class=\"solidity\"><code>function callGetX(address _addr) external returns(uint256){\r\n    // call getX()\r\n    (bool success, bytes memory data) = _addr.call(\r\n        abi.encodeWithSignature(\"getX()\")\r\n    );\r\n\r\n    emit Response(success, data); //释放事件\r\n    return abi.decode(data, (uint256));\r\n}</code></pre>\r\n<p>从<code>Response</code>事件的输出，我们可以看到<code>data</code>为<code>0x0000000000000000000000000000000000000000000000000000000000000005</code>。而经过<code>abi.decode</code>，最终返回值为<code>5</code>。<br>\r\n<img src=\"https://wtf.academy/assets/images/22-2-008a7b4cdb2734426c2c284cfca79b41.png\"></p>\r\n<p><strong>4.调用不存在的函数</strong></p>\r\n<p>如果我们给<code>call</code>输入的函数不存在于目标合约，那么目标合约的<code>fallback</code>函数会被触发。</p>\r\n<pre class=\"solidity\"><code>function callNonExist(address _addr) external{\r\n    // call getX()\r\n    (bool success, bytes memory data) = _addr.call(\r\n        abi.encodeWithSignature(\"foo(uint256)\")\r\n    );\r\n\r\n    emit Response(success, data); //释放事件\r\n}</code></pre>\r\n<p>上面例子中，我们<code>call</code>了不存在的<code>foo</code>函数。<code>call</code>仍能执行成功，并返回<code>success</code>，但其实调用的目标合约<code>fallback</code>函数。<br>\r\n<img src=\"https://wtf.academy/assets/images/22-3-b6b8e21fc3d39b5592c1a54f75fdad66.png\"></p>\r\n<p><code>call</code>不是调用合约的推荐方法，因为不安全。但他能让我们在不知道源代码和<code>ABI</code>的情况下调用目标合约，很有用。</p>\r\n<p>(最后直接贴上所有代码)</p>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ncontract OtherContract {\r\n    uint256 private _x = 0; // 状态变量x\r\n    // 收到eth的事件，记录amount和gas\r\n    event Log(uint amount, uint gas);\r\n    \r\n    fallback() external payable{}\r\n\r\n    // 返回合约ETH余额\r\n    function getBalance() view public returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)\r\n    function setX(uint256 x) external payable{\r\n        _x = x;\r\n        // 如果转入ETH，则释放Log事件\r\n        if(msg.value &gt; 0){\r\n            emit Log(msg.value, gasleft());\r\n        }\r\n    }\r\n\r\n    // 读取x\r\n    function getX() external view returns(uint x){\r\n        x = _x;\r\n    }\r\n}\r\n\r\n    contract call{\r\n        function callGetX(address _addr) external returns(uint256){\r\n    // call getX()\r\n    (bool success, bytes memory data) = _addr.call(\r\n        abi.encodeWithSignature(\"getX()\")\r\n    );\r\n\r\n    emit Response(success, data); //释放事件\r\n    return abi.decode(data, (uint256));\r\n}\r\n\r\n        event Response(bool success, bytes data);\r\n\r\n        function callSetX(address payable _addr, uint256 x) public payable {\r\n    // call setX()，同时可以发送ETH\r\n    (bool success, bytes memory data) = _addr.call{value: msg.value}(\r\n        abi.encodeWithSignature(\"setX(uint256)\", x)\r\n    );\r\n\r\n    emit Response(success, data); //释放事件\r\n}\r\n    function callNonExist(address _addr) external{\r\n    // call getX()\r\n    (bool success, bytes memory data) = _addr.call(\r\n        abi.encodeWithSignature(\"foo(uint256)\")\r\n    );\r\n\r\n    emit Response(success, data); //释放事件\r\n}\r\n    }</code></pre>\r\n<h2 id=\"delegatecall\">23.Delegatecall</h2>\r\n<p><code>delegatecall</code>与<code>call</code>类似，是<code>solidity</code>中地址类型的低级成员函数。<code>delegate</code>中是委托/代表的意思，那么<code>delegatecall</code>委托了什么？</p>\r\n<p>当用户<code>A</code>通过合约<code>B</code>来<code>call</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，<code>语境</code>(<code>Context</code>，可以理解为包含变量和状态的环境)也是合约<code>C</code>的：<code>msg.sender</code>是<code>B</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>C</code>的变量上。<br>\r\n<img src=\"https://images.mirror-media.xyz/publication-images/VgMR533pA8WYtE5Lr65mQ.png?height=698&amp;width=1860\"></p>\r\n<p>而当用户<code>A</code>通过合约<code>B</code>来<code>delegatecall</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，但是<code>语境</code>仍是合约<code>B</code>的：<code>msg.sender</code>是<code>A</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>B</code>的变量上。<br>\r\n<img src=\"https://images.mirror-media.xyz/publication-images/JucQiWVixdlmJl6zHjCSI.png?height=702&amp;width=1862\"></p>\r\n<p>大家可以这样理解：一个<code>富商</code>把它的资产（<code>状态变量</code>）都交给一个<code>VC</code>代理（<code>目标合约</code>的函数）来打理。执行的是<code>VC</code>的函数，但是改变的是<code>富商</code>的状态。</p>\r\n<p><code>delegatecall</code>语法和<code>call</code>类似，也是：</p>\r\n<pre class=\"solidity\"><code>目标合约地址.delegatecall(二进制编码);</code></pre>\r\n<p>其中<code>二进制编码</code>利用结构化编码函数<code>abi.encodeWithSignature</code>获得：</p>\r\n<pre class=\"solidity\"><code>abi.encodeWithSignature(\"函数签名\", 逗号分隔的具体参数)</code></pre>\r\n<p><code>函数签名</code>为<code>\"函数名（逗号分隔的参数类型)\"</code>。例如<code>abi.encodeWithSignature(\"f(uint256,address)\", _x, _addr)</code>。</p>\r\n<p>和<code>call</code>不一样，<code>delegatecall</code>在调用合约时可以指定交易发送的<code>gas</code>，但不能指定发送的<code>ETH</code>数额</p>\r\n<blockquote>\r\n<p><strong>注意</strong>：<code>delegatecall</code>有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。</p>\r\n</blockquote>\r\n<h3 id=\"什么情况下会用到delegatecall\">什么情况下会用到<code>delegatecall</code></h3>\r\n<p>目前<code>delegatecall</code>主要有两个应用场景：</p>\r\n<ol type=\"1\">\r\n<li>代理合约（<code>Proxy Contract</code>）：将智能合约的存储合约和逻辑合约分开：代理合约（<code>Proxy Contract</code>）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（<code>Logic Contract</code>）里，通过<code>delegatecall</code>执行。当升级时，只需要将代理合约指向新的逻辑合约即可。</li>\r\n<li>EIP-2535\r\nDiamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合同的代理合同。</li>\r\n</ol>\r\n<h3 id=\"delegatecall例子\"><code>delegatecall</code>例子</h3>\r\n<p>调用结构：你（<code>A</code>）通过合约<code>B</code>调用目标合约<code>C</code>。</p>\r\n<h4 id=\"被调用的合约c\">被调用的合约C</h4>\r\n<p>我们先写一个简单的目标合约<code>C</code>：有两个<code>public</code>变量：<code>num</code>和<code>sender</code>，分别是<code>uint256</code>和<code>address</code>类型；有一个函数，可以将<code>num</code>设定为传入的<code>_num</code>，并且将<code>sender</code>设为<code>msg.sender</code>。</p>\r\n<pre class=\"solidity\"><code>// 被调用的合约C\r\ncontract C {\r\n    uint public num;\r\n    address public sender;\r\n\r\n    function setVars(uint _num) public payable {\r\n        num = _num;\r\n        sender = msg.sender;\r\n    }\r\n}</code></pre>\r\n<h4 id=\"发起调用的合约b\">发起调用的合约B</h4>\r\n<p>首先，<strong>合约<code>B</code>和目标合约<code>C</code>的变量存储布局必须相同</strong>，两个变量，并且顺序为<code>num</code>和<code>sender</code></p>\r\n<pre class=\"solidity\"><code>contract B {\r\n    uint public num;\r\n    address public sender;</code></pre>\r\n<p>接下来，我们分别用<code>call</code>和<code>delegatecall</code>来调用合约<code>C</code>的<code>setVars</code>函数，更好的理解它们的区别。</p>\r\n<p><code>callSetVars</code>函数通过<code>call</code>来调用<code>setVars</code>。它有两个参数<code>_addr</code>和<code>_num</code>，分别对应合约<code>C</code>的地址和<code>setVars</code>的参数。</p>\r\n<pre class=\"solidity\"><code>    // 通过call来调用C的setVars()函数，将改变合约C里的状态变量\r\n    function callSetVars(address _addr, uint _num) external payable{\r\n        // call setVars()\r\n        (bool success, bytes memory data) = _addr.call(\r\n            abi.encodeWithSignature(\"setVars(uint256)\", _num)\r\n        );\r\n    }</code></pre>\r\n<p>而<code>delegatecallSetVars</code>函数通过<code>delegatecall</code>来调用<code>setVars</code>。与上面的<code>callSetVars</code>函数相同，有两个参数<code>_addr</code>和<code>_num</code>，分别对应合约<code>C</code>的地址和<code>setVars</code>的参数。</p>\r\n<pre class=\"solidity\"><code>    // 通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量\r\n    function delegatecallSetVars(address _addr, uint _num) external payable{\r\n        // delegatecall setVars()\r\n        (bool success, bytes memory data) = _addr.delegatecall(\r\n            abi.encodeWithSignature(\"setVars(uint256)\", _num)\r\n        );\r\n    }\r\n}</code></pre>\r\n<h4 id=\"在remix上验证\">在remix上验证</h4>\r\n<p>1.首先，我们把合约<code>B</code>和<code>C</code>都部署好</p>\r\n<p><img src=\"https://wtf.academy/assets/images/23-1-85c05f2d534e1a100a08f48bdea973b0.png\" alt=\"deploy.png\"></p>\r\n<p>2.部署之后，查看<code>C</code>合约状态变量的初始值，<code>B</code>合约的状态变量也是一样。</p>\r\n<p><img src=\"https://wtf.academy/assets/images/23-2-0710e49786d637814b5998a6b2c33dc0.png\" alt=\"initialstate.png\"></p>\r\n<p>3.此时，调用合约<code>B</code>中的<code>callSetVars</code>，传入参数为合约<code>C</code>地址和<code>10</code></p>\r\n<p><img src=\"https://wtf.academy/assets/images/23-3-24a8e170ef4ffc2ee1964ecea2e3fa46.png\" alt=\"call.png\"></p>\r\n<p>4.运行后，合约<code>C</code>中的状态变量将被修改：<code>num</code>被改为<code>10</code>，<code>sender</code>变为合约<code>B</code>的地址</p>\r\n<p><img src=\"https://wtf.academy/assets/images/23-4-dc4ef0d4cdcdd6fa306fc19dd4b3f931.png\" alt=\"resultcall.png\"></p>\r\n<p>5.接下来，我们调用合约<code>B</code>中的<code>delegatecallSetVars</code>，传入参数为合约<code>C</code>地址和<code>100</code></p>\r\n<p><img src=\"https://wtf.academy/assets/images/23-5-48ec2ddb52f11031a3d1fba839e74f26.png\" alt=\"delegatecall.png\"></p>\r\n<p>6.由于是<code>delegatecall</code>，语境为合约<code>B</code>。在运行后，合约<code>B</code>中的状态变量将被修改：<code>num</code>被改为<code>100</code>，<code>sender</code>变为你的钱包地址。合约<code>C</code>中的状态变量不会被修改。</p>\r\n<p><img src=\"https://wtf.academy/assets/images/23-6-563be58ca9837183438ce89b76b618fb.png\"></p>\r\n<h2 id=\"在合约中创建新合约\">24.在合约中创建新合约</h2>\r\n<p>在以太坊链上，用户（外部账户，<code>EOA</code>）可以创建智能合约，智能合约同样也可以创建新的智能合约。去中心化交易所<code>uniswap</code>就是利用工厂合约（<code>Factory</code>）创建了无数个币对合约（<code>Pair</code>）。这一讲，我会用简化版的<code>uniswap</code>讲如何通过合约创建合约。</p>\r\n<h3 id=\"create和create2\"><code>create</code>和<code>create2</code></h3>\r\n<p>有两种方法可以在合约中创建新合约，<code>create</code>和<code>create2</code>，这里我们讲<code>create</code>，下一讲会介绍<code>create2</code>。</p>\r\n<p><code>create</code>的用法很简单，就是<code>new</code>一个合约，并传入新合约构造函数所需的参数：</p>\r\n<pre class=\"solidity\"><code>Contract x = new Contract{value: _value}(params)</code></pre>\r\n<p>其中<code>Contract</code>是要创建的合约名，<code>x</code>是合约对象（地址），如果构造函数是<code>payable</code>，可以创建时转入<code>_value</code>数量的<code>ETH</code>，<code>params</code>是新合约构造函数的参数。</p>\r\n<h3 id=\"极简uniswap\">极简Uniswap</h3>\r\n<p><code>Uniswap V2</code><a href=\"https://github.com/Uniswap/v2-core/tree/master/contracts\">核心合约</a>中包含两个合约：</p>\r\n<ol type=\"1\">\r\n<li>UniswapV2Pair: 币对合约，用于管理币对地址、流动性、买卖。</li>\r\n<li>UniswapV2Factory: 工厂合约，用于创建新的币对，并管理币对地址。</li>\r\n</ol>\r\n<p>下面我们用<code>create</code>方法实现一个极简版的<code>Uniswap</code>：<code>Pair</code>币对合约负责管理币对地址，<code>PairFactory</code>工厂合约用于创建新的币对，并管理币对地址。</p>\r\n<h4 id=\"pair合约\"><code>Pair</code>合约</h4>\r\n<pre class=\"solidity\"><code>contract Pair{\r\n    address public factory; // 工厂合约地址\r\n    address public token0; // 代币1\r\n    address public token1; // 代币2\r\n\r\n    constructor() payable {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    // called once by the factory at time of deployment\r\n    function initialize(address _token0, address _token1) external {\r\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n    }\r\n}</code></pre>\r\n<p><code>Pair</code>合约很简单，包含3个状态变量：<code>factory</code>，<code>token0</code>和<code>token1</code>。</p>\r\n<p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值为工厂合约地址。<code>initialize</code>函数会在<code>Pair</code>合约创建的时候被工厂合约调用一次，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p>\r\n<blockquote>\r\n<p><strong>提问</strong>：为什么<code>uniswap</code>不在<code>constructor</code>中将<code>token0</code>和<code>token1</code>地址更新好？</p>\r\n<p><strong>答</strong>：因为<code>uniswap</code>使用的是<code>create2</code>创建合约，限制构造函数不能有参数。当使用<code>create</code>时，<code>Pair</code>合约允许构造函数有参数，可以在<code>constructor</code>中将<code>token0</code>和<code>token1</code>地址更新好。</p>\r\n</blockquote>\r\n<h4 id=\"pairfactory\"><code>PairFactory</code></h4>\r\n<pre class=\"solidity\"><code>contract PairFactory{\r\n    mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址\r\n    address[] public allPairs; // 保存所有Pair地址\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pairAddr) {\r\n        // 创建新合约\r\n        Pair pair = new Pair(); \r\n        // 调用新合约的initialize方法\r\n        pair.initialize(tokenA, tokenB);\r\n        // 更新地址map\r\n        pairAddr = address(pair);\r\n        allPairs.push(pairAddr);\r\n        getPair[tokenA][tokenB] = pairAddr;\r\n        getPair[tokenB][tokenA] = pairAddr;\r\n    }\r\n}</code></pre>\r\n<p>工厂合约（<code>PairFactory</code>）有两个状态变量<code>getPair</code>是两个代币地址到币对地址的<code>map</code>，方便根据代币找到币对地址；<code>allPairs</code>是币对地址的数组，存储了所有代币地址。</p>\r\n<p><code>PairFactory</code>合约只有一个<code>createPair</code>函数，根据输入的两个代币地址<code>tokenA</code>和<code>tokenB</code>来创建新的<code>Pair</code>合约。其中</p>\r\n<pre class=\"solidity\"><code>    Pair pair = new Pair(); </code></pre>\r\n<p>就是创建合约的代码，非常简单。大家可以部署好<code>PairFactory</code>合约，然后用下面两个地址作为参数调用<code>createPair</code>，看看创建的币对地址是什么：</p>\r\n<pre class=\"text\"><code>WBNB地址: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78\r\nBSC链上的PEOPLE地址:\r\n0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c</code></pre>\r\n<h4 id=\"在remix上验证-1\">在remix上验证</h4>\r\n<p>1.使用<code>WBNB</code>和<code>PEOPLE</code>的地址作为参数调用<code>createPair</code>,得到<code>Pair</code>合约地址：0xD3e2008b4Da2cD6DEAF73471590fF30C86778A48</p>\r\n<p><img src=\"https://wtf.academy/assets/images/24-1-d4a6d130254e0486a4cb649b74cb40c4.png\" alt=\"img\"></p>\r\n<p>（刚开始没整出来，加个步骤，复制得到的<code>Pair</code>合约地址，放到<code>At Address</code>里面，同时上面部署合约要改回<code>Pair</code>,点击<code>At Address</code>得到合约）</p>\r\n<p><img src=\"https://s2.loli.net/2022/11/29/pw3mz5S8MTjeItD.png\" alt=\"image-20221129212246832.png\"></p>\r\n<p>2.查看<code>Pair</code>合约变量</p>\r\n<p><img src=\"https://wtf.academy/assets/images/24-2-3521680cc697424ef856eae959ad61c0.png\" alt=\"img\"></p>\r\n<p>3.Debug查看<code>create</code>操作码</p>\r\n<p><img src=\"https://wtf.academy/assets/images/24-3-f4526e2f8351ddfcabb223ec5ec6d20a.png\" alt=\"img\"></p>\r\n<h2 id=\"create2\">25.Create2</h2>\r\n<p><code>CREATE2</code>\r\n操作码使我们在智能合约部署在以太坊网络之前就能预测合约的地址。<code>Uniswap</code>创建<code>Pair</code>合约用的就是<code>CREATE2</code>而不是<code>CREATE</code>。</p>\r\n<h3 id=\"create如何计算地址\">Create如何计算地址</h3>\r\n<p>智能合约可以由其他合约和普通账户利用<code>CREATE</code>操作码创建。\r\n在这两种情况下，新合约的地址都以相同的方式计算：创建者的地址(通常为部署的钱包地址或者合约地址)和<code>nonce</code>(该地址发送交易的总数,对于合约账户是创建的合约总数,每创建一个合约nonce+1))的哈希。</p>\r\n<pre class=\"text\"><code>新地址 = hash(创建者地址, nonce)</code></pre>\r\n<p>创建者地址不会变，但<code>nonce</code>可能会随时间而改变，因此用<code>CREATE</code>创建的合约地址不好预测。</p>\r\n<h3 id=\"create2如何计算地址\">Create2如何计算地址</h3>\r\n<p><code>CREATE2</code>的目的是为了让合约地址独立于未来的事件。不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上。用<code>CREATE2</code>创建的合约地址由4个部分决定：</p>\r\n<ul>\r\n<li><code>0xFF</code>：一个常数，避免和<code>CREATE</code>冲突</li>\r\n<li>创建者地址</li>\r\n<li><code>salt</code>（盐）：一个创建者给定的数值</li>\r\n<li>待部署合约的字节码（<code>bytecode</code>）</li>\r\n</ul>\r\n<pre class=\"text\"><code>新地址 = hash(\"0xFF\",创建者地址, salt, bytecode)</code></pre>\r\n<p><code>CREATE2</code> 确保，如果创建者使用 <code>CREATE2</code>\r\n和提供的 <code>salt</code>\r\n部署给定的合约<code>bytecode</code>，它将存储在 <code>新地址</code>\r\n中。</p>\r\n<h3 id=\"如何使用create2\">如何使用<code>Create2</code></h3>\r\n<p><code>CREATE2</code>的用法和之前讲的<code>Create</code>类似，同样是<code>new</code>一个合约，并传入新合约构造函数所需的参数，只不过要多传一个<code>salt</code>参数：</p>\r\n<pre class=\"text\"><code>Contract x = new Contract{salt: _salt, value: _value}(params)</code></pre>\r\n<p>其中<code>Contract</code>是要创建的合约名，<code>x</code>是合约对象（地址），<code>_salt</code>是指定的盐；如果构造函数是<code>payable</code>，可以创建时转入<code>_value</code>数量的<code>ETH</code>，<code>params</code>是新合约构造函数的参数。</p>\r\n<h3 id=\"极简uniswap2\">极简Uniswap2</h3>\r\n<h4 id=\"pair\"><code>Pair</code></h4>\r\n<pre class=\"solidity\"><code>contract Pair{\r\n    address public factory; // 工厂合约地址\r\n    address public token0; // 代币1\r\n    address public token1; // 代币2\r\n\r\n    constructor() payable {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    // called once by the factory at time of deployment\r\n    function initialize(address _token0, address _token1) external {\r\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n    }\r\n}</code></pre>\r\n<p><code>Pair</code>合约很简单，包含3个状态变量：<code>factory</code>，<code>token0</code>和<code>token1</code>。</p>\r\n<p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值为工厂合约地址。<code>initialize</code>函数会在<code>Pair</code>合约创建的时候被工厂合约调用一次，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p>\r\n<h4 id=\"pairfactory2\"><code>PairFactory2</code></h4>\r\n<pre class=\"solidity\"><code>contract PairFactory2{\r\n        mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址\r\n        address[] public allPairs; // 保存所有Pair地址\r\n\r\n        function createPair2(address tokenA, address tokenB) external returns (address pairAddr) {\r\n            require(tokenA != tokenB, 'IDENTICAL_ADDRESSES'); //避免tokenA和tokenB相同产生的冲突\r\n            // 计算用tokenA和tokenB地址计算salt\r\n            (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序\r\n            bytes32 salt = keccak256(abi.encodePacked(token0, token1));\r\n            // 用create2部署新合约\r\n            Pair pair = new Pair{salt: salt}(); \r\n            // 调用新合约的initialize方法\r\n            pair.initialize(tokenA, tokenB);\r\n            // 更新地址map\r\n            pairAddr = address(pair);\r\n            allPairs.push(pairAddr);\r\n            getPair[tokenA][tokenB] = pairAddr;\r\n            getPair[tokenB][tokenA] = pairAddr;\r\n        }\r\n    }</code></pre>\r\n<p>工厂合约（<code>PairFactory2</code>）有两个状态变量<code>getPair</code>是两个代币地址到币对地址的<code>map</code>，方便根据代币找到币对地址；<code>allPairs</code>是币对地址的数组，存储了所有币对地址。</p>\r\n<p><code>PairFactory2</code>合约只有一个<code>createPair2</code>函数，使用<code>CREATE2</code>根据输入的两个代币地址<code>tokenA</code>和<code>tokenB</code>来创建新的<code>Pair</code>合约。其中</p>\r\n<pre class=\"solidity\"><code>    Pair pair = new Pair{salt: salt}(); </code></pre>\r\n<p>就是利用<code>CREATE2</code>创建合约的代码，非常简单，而<code>salt</code>为<code>token1</code>和<code>token2</code>的<code>hash</code>：</p>\r\n<pre class=\"solidity\"><code>            bytes32 salt = keccak256(abi.encodePacked(token0, token1));</code></pre>\r\n<h4 id=\"事先计算pair地址\">事先计算<code>Pair</code>地址</h4>\r\n<pre class=\"solidity\"><code>        // 提前计算pair合约地址\r\n        function calculateAddr(address tokenA, address tokenB) public view returns(address predictedAddress){\r\n            require(tokenA != tokenB, 'IDENTICAL_ADDRESSES'); //避免tokenA和tokenB相同产生的冲突\r\n            // 计算用tokenA和tokenB地址计算salt\r\n            (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序\r\n            bytes32 salt = keccak256(abi.encodePacked(token0, token1));\r\n            // 计算合约地址方法 hash()\r\n            predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(\r\n                bytes1(0xff),\r\n                address(this),\r\n                salt,\r\n                keccak256(type(Pair).creationCode)\r\n            )))));\r\n        }</code></pre>\r\n<p>我们写了一个<code>calculateAddr</code>函数来事先计算<code>tokenA</code>和<code>tokenB</code>将会生成的<code>Pair</code>地址。通过它，我们可以验证我们事先计算的地址和实际地址是否相同。</p>\r\n<p>大家可以部署好<code>PairFactory2</code>合约，然后用下面两个地址作为参数调用<code>createPair2</code>，看看创建的币对地址是什么，是否与事先计算的地址一样：</p>\r\n<pre class=\"text\"><code>WBNB地址: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78\r\nBSC链上的PEOPLE地址:\r\n0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c</code></pre>\r\n<h4 id=\"在remix上验证-2\">在remix上验证</h4>\r\n<ol type=\"1\">\r\n<li><p>首先用<code>WBNB</code>和<code>PEOPLE</code>的地址哈希作为<code>salt</code>来计算出<code>Pair</code>合约的地址</p></li>\r\n<li><p>调用<code>PairFactory2.createPair2</code>传入参数为<code>WBNB</code>和<code>PEOPLE</code>的地址，获取出创建的<code>pair</code>合约地址</p></li>\r\n<li><p>对比合约地址</p></li>\r\n</ol>\r\n<p><img src=\"https://wtf.academy/assets/images/25-1-2d1f4ed217fe799a46e8b53a44cfdd3b.png\" alt=\"create2_remix_test.png\"></p>\r\n<h3 id=\"create2的实际应用场景\">create2的实际应用场景</h3>\r\n<ol type=\"1\">\r\n<li>交易所为新用户预留创建钱包合约地址。</li>\r\n<li>由 <code>CREATE2</code> 驱动的 <code>factory</code>\r\n合约，在<code>uniswapV2</code>中交易对的创建是在\r\n<code>Factory</code>中调用<code>create2</code>完成。这样做的好处是:\r\n它可以得到一个确定的<code>pair</code>地址, 使得\r\n<code>Router</code>中就可以通过 <code>(tokenA, tokenB)</code>\r\n计算出<code>pair</code>地址, 不再需要执行一次\r\n<code>Factory.getPair(tokenA, tokenB)</code> 的跨合约调用。</li>\r\n</ol>\r\n<h2 id=\"删除合约\">26.删除合约</h2>\r\n<h3 id=\"selfdestruct\"><code>selfdestruct</code></h3>\r\n<p><code>selfdestruct</code>命令可以用来删除智能合约，并将该合约剩余<code>ETH</code>转到指定地址。<code>selfdestruct</code>是为了应对合约出错的极端情况而设计的。它最早被命名为<code>suicide</code>（自杀），但是这个词太敏感。为了保护抑郁的程序员，改名为<code>selfdestruct</code>。</p>\r\n<h3 id=\"如何使用selfdestruct\">如何使用<code>selfdestruct</code></h3>\r\n<p><code>selfdestruct</code>使用起来非常简单：</p>\r\n<pre class=\"solidity\"><code>selfdestruct(_addr)；</code></pre>\r\n<p>其中<code>_addr</code>是接收合约中剩余<code>ETH</code>的地址。</p>\r\n<h3 id=\"例子\">例子</h3>\r\n<pre class=\"solidity\"><code>contract DeleteContract {\r\n\r\n    uint public value = 10;\r\n\r\n    constructor() payable {}\r\n\r\n    receive() external payable {}\r\n\r\n    function deleteContract() external {\r\n        // 调用selfdestruct销毁合约，并把剩余的ETH转给msg.sender\r\n        selfdestruct(payable(msg.sender));\r\n    }\r\n\r\n    function getBalance() external view returns(uint balance){\r\n        balance = address(this).balance;\r\n    }\r\n}</code></pre>\r\n<p>在<code>DeleteContract</code>合约中，我们写了一个<code>public</code>状态变量<code>value</code>，两个函数：<code>getBalance()</code>用于获取合约<code>ETH</code>余额，<code>deleteContract()</code>用于自毁合约，并把<code>ETH</code>转入给发起人。</p>\r\n<p>部署好合约后，我们向<code>DeleteContract</code>合约转入1\r\n<code>ETH</code>。这时，<code>getBalance()</code>会返回1\r\n<code>ETH</code>，<code>value</code>变量是10。</p>\r\n<p>当我们调用<code>deleteContract()</code>函数，合约将自毁，所有变量都清空，此时<code>value</code>变为默认值<code>0</code>，<code>getBalance()</code>也返回空值。</p>\r\n<h3 id=\"注意事项\">注意事项</h3>\r\n<ol type=\"1\">\r\n<li>对外提供合约销毁接口时，最好设置为只有合约所有者可以调用，可以使用函数修饰符<code>onlyOwner</code>进行函数声明。</li>\r\n<li>当合约被销毁后与智能合约的交互也能成功，并且返回0。</li>\r\n<li>当合约中有<code>selfdestruct</code>功能时常常会带来安全问题和信任问题，合约中的<code>Selfdestruct</code>功能会为攻击者打开攻击向量(例如使用<code>selfdestruct</code>向一个合约频繁转入token进行攻击，这将大大节省了GAS的费用，虽然很少人这么做)，此外，此功能还会降低用户对合约的信心。</li>\r\n</ol>\r\n<h2 id=\"abi编码解码\">27.ABI编码解码</h2>\r\n<p><code>ABI</code> (Application Binary\r\nInterface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。</p>\r\n<p><code>Solidity</code>中，<code>ABI编码</code>有4个函数：<code>abi.encode</code>,\r\n<code>abi.encodePacked</code>, <code>abi.encodeWithSignature</code>,\r\n<code>abi.encodeWithSelector</code>。而<code>ABI解码</code>有1个函数：<code>abi.decode</code>，用于解码<code>abi.encode</code>的数据。</p>\r\n<h4 id=\"abi编码\">ABI编码</h4>\r\n<p>我们将用编码4个变量，他们的类型分别是<code>uint256</code>,\r\n<code>address</code>, <code>string</code>, <code>uint256[2]</code>：</p>\r\n<pre class=\"solidity\"><code>    uint x = 10;\r\n    address addr = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;\r\n    string name = \"0xAA\";\r\n    uint[2] array = [5, 6]; </code></pre>\r\n<h4 id=\"abi.encode\"><code>abi.encode</code></h4>\r\n<p>将给定参数利用<a href=\"https://learnblockchain.cn/docs/solidity/abi-spec.html\">ABI规则</a>编码。<code>ABI</code>被设计出来跟智能合约交互，他将每个参数填充为32字节的数据，并拼接在一起。如果你要和合约交互，你要用的就是<code>abi.encode</code>。</p>\r\n<pre class=\"solidity\"><code>    function encode() public view returns(bytes memory result) {\r\n        result = abi.encode(x, addr, name, array);\r\n    }</code></pre>\r\n<p>编码的结果为<code>0x000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000</code>，由于<code>abi.encode</code>将每个数据都填充为32字节，中间有很多<code>0</code>。</p>\r\n<h4 id=\"abi.encodepacked\"><code>abi.encodePacked</code></h4>\r\n<p>将给定参数根据其所需最低空间编码。它类似\r\n<code>abi.encode</code>，但是会把其中填充的很多<code>0</code>省略。比如，只用1字节来编码<code>uint</code>类型。当你想省空间，并且不与合约交互的时候，可以使用<code>abi.encodePacked</code>，例如算一些数据的<code>hash</code>时。</p>\r\n<pre class=\"solidity\"><code>    function encodePacked() public view returns(bytes memory result) {\r\n        result = abi.encodePacked(x, addr, name, array);\r\n    }</code></pre>\r\n<p>编码的结果为<code>0x000000000000000000000000000000000000000000000000000000000000000a7a58c0be72be218b41c608b7fe7c5bb630736c713078414100000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006</code>，由于<code>abi.encodePacked</code>对编码进行了压缩，长度比<code>abi.encode</code>短很多。</p>\r\n<h4 id=\"abi.encodewithsignature\"><code>abi.encodeWithSignature</code></h4>\r\n<p>与<code>abi.encode</code>功能类似，只不过第一个参数为<code>函数签名</code>，比如<code>\"foo(uint256,address)\"</code>。当调用其他合约的时候可以使用。</p>\r\n<pre class=\"solidity\"><code>    function encodeWithSignature() public view returns(bytes memory result) {\r\n        result = abi.encodeWithSignature(\"foo(uint256,address,string,uint256[2])\", x, addr, name, array);\r\n    }</code></pre>\r\n<p>编码的结果为<code>0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000</code>，等同于在<code>abi.encode</code>编码结果前加上了4字节的<code>函数选择器</code><a href=\"https://wtf.academy/solidity-advanced/ABIEncode/#fn-说明\">说明</a>。\r\n<a href=\"https://wtf.academy/solidity-advanced/ABIEncode/#fn-说明\">说明</a>:\r\n函数选择器就是通过函数名和参数进行签名处理(Keccak–Sha3)来标识函数，可以用于不同合约之间的函数调用</p>\r\n<h4 id=\"abi.encodewithselector\"><code>abi.encodeWithSelector</code></h4>\r\n<p>与<code>abi.encodeWithSignature</code>功能类似，只不过第一个参数为<code>函数选择器</code>，为<code>函数签名</code>Keccak哈希的前4个字节。</p>\r\n<pre class=\"solidity\"><code>    function encodeWithSelector() public view returns(bytes memory result) {\r\n        result = abi.encodeWithSelector(bytes4(keccak256(\"foo(uint256,address,string,uint256[2])\")), x, addr, name, array);\r\n    }</code></pre>\r\n<p>编码的结果为<code>0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000</code>，与<code>abi.encodeWithSignature</code>结果一样。</p>\r\n<h3 id=\"abi解码\">ABI解码</h3>\r\n<h4 id=\"abi.decode\"><code>abi.decode</code></h4>\r\n<p><code>abi.decode</code>用于解码<code>abi.encode</code>生成的二进制编码，将它还原成原本的参数。</p>\r\n<pre class=\"solidity\"><code>    function decode(bytes memory data) public pure returns(uint dx, address daddr, string memory dname, uint[2] memory darray) {\r\n        (dx, daddr, dname, darray) = abi.decode(data, (uint, address, string, uint[2]));\r\n    }</code></pre>\r\n<p>我们将<code>abi.encode</code>的二进制编码输入给<code>decode</code>，将解码出原来的参数：</p>\r\n<p><img src=\"https://images.mirror-media.xyz/publication-images/jboRaaq0U57qVYjmsOgbv.png?height=408&amp;width=624\" alt=\"img\"></p>\r\n<h3 id=\"abi的使用场景\">ABI的使用场景</h3>\r\n<p>1.在合约开发中，ABI常配合call来实现对合约的底层调用。</p>\r\n<pre class=\"solidity\"><code>    bytes4 selector = contract.getValue.selector;\r\n\r\n    bytes memory data = abi.encodeWithSelector(selector, _x);\r\n    (bool success, bytes memory returnedData) = address(contract).staticcall(data);\r\n    require(success);\r\n\r\n    return abi.decode(returnedData, (uint256));</code></pre>\r\n<p>2.ethers.js中常用ABI实现合约的导入和函数调用。</p>\r\n<pre class=\"solidity\"><code>    const wavePortalContract = new ethers.Contract(contractAddress, contractABI, signer);\r\n    /*\r\n        * Call the getAllWaves method from your Smart Contract\r\n        */\r\n    const waves = await wavePortalContract.getAllWaves();</code></pre>\r\n<p>3.对不开源合约进行反编译后，某些函数无法查到函数签名，可通过ABI进行调用。</p>\r\n<ul>\r\n<li><p>0x533ba33a()\r\n是一个反编译后显示的函数，只有函数编码后的结果，并且无法查到函数签名</p>\r\n<p><img src=\"https://s2.loli.net/2022/11/30/7BH1urKkUEnjPVS.png\" alt=\"image-20221130001453540.png\"></p></li>\r\n<li><p>这种情况无法通过构造interface接口或contract来进行调用</p>\r\n<p><img src=\"https://s2.loli.net/2022/11/30/P9JmTixdAYyHEL3.png\" alt=\"image-20221130001547298.png\"></p></li>\r\n</ul>\r\n<p>这种情况下，就可以通过ABI函数选择器来调用</p>\r\n<pre class=\"solidity\"><code>    bytes memory data = abi.encodeWithSelector(bytes4(0x533ba33a));\r\n\r\n    (bool success, bytes memory returnedData) = address(contract).staticcall(data);\r\n    require(success);\r\n\r\n    return abi.decode(returnedData, (uint256));</code></pre>\r\n<h2 id=\"hash\">28.Hash</h2>\r\n<p>哈希函数（hash\r\nfunction）是一个密码学概念，它可以将任意长度的消息转换为一个固定长度的值，这个值也称作哈希（hash）。</p>\r\n<h3 id=\"hash的性质\">Hash的性质</h3>\r\n<p>一个好的哈希函数应该具有以下几个特性：</p>\r\n<ul>\r\n<li>单向性：从输入的消息到它的哈希的正向运算简单且唯一确定，而反过来非常难，只能靠暴力枚举。</li>\r\n<li>灵敏性：输入的消息改变一点对它的哈希改变很大。</li>\r\n<li>高效性：从输入的消息到哈希的运算高效。</li>\r\n<li>均一性：每个哈希值被取到的概率应该基本相等。</li>\r\n<li>抗碰撞性：\r\n<ul>\r\n<li>弱抗碰撞性：给定一个消息<code>x</code>，找到另一个消息<code>x'</code>使得<code>hash(x) = hash(x')</code>是困难的。</li>\r\n<li>强抗碰撞性：找到任意<code>x</code>和<code>x'</code>，使得<code>hash(x) = hash(x')</code>是困难的。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"hash的应用\">Hash的应用</h3>\r\n<ul>\r\n<li>生成数据唯一标识</li>\r\n<li>加密签名</li>\r\n<li>安全加密</li>\r\n</ul>\r\n<h3 id=\"keccak256\">Keccak256</h3>\r\n<p><code>Keccak256</code>函数是<code>solidity</code>中最常用的哈希函数，用法非常简单：</p>\r\n<pre class=\"solidity\"><code>哈希 = keccak256(数据);</code></pre>\r\n<h4 id=\"keccak256和sha3\">Keccak256和sha3</h4>\r\n<ol type=\"1\">\r\n<li>sha3由keccak标准化而来，在很多场合下Keccak和SHA3是同义词，但在2015年8月SHA3最终完成标准化时，NIST调整了填充算法。<strong>所以SHA3就和keccak计算的结果不一样</strong>，这点在实际开发中要注意。</li>\r\n<li>以太坊在开发的时候sha3还在标准化中，所以采用了keccak，所以Ethereum和Solidity智能合约代码中的SHA3是指Keccak256，而不是标准的NIST-SHA3，为了避免混淆，直接在合约代码中写成Keccak256是最清晰的。</li>\r\n</ol>\r\n<h4 id=\"生成数据唯一标志\">生成数据唯一标志</h4>\r\n<p>我们可以利用<code>keccak256</code>来生成一些数据的唯一标识。比如我们有几个不同类型的数据：<code>uint</code>，<code>string</code>，<code>address</code>，我们可以先用<code>abi.encodePacked</code>方法将他们打包编码，然后再用<code>keccak256</code>来生成唯一标识：</p>\r\n<pre class=\"solidity\"><code>    function hash(\r\n        uint _num,\r\n        string memory _string,\r\n        address _addr\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_num, _string, _addr));\r\n    }</code></pre>\r\n<h4 id=\"弱抗碰撞性\">弱抗碰撞性</h4>\r\n<p>我们用<code>keccak256</code>演示一下之前讲到的弱抗碰撞性，即给定一个消息<code>x</code>，找到另一个消息<code>x'</code>使得<code>hash(x) = hash(x')</code>是困难的。</p>\r\n<p>我们给定一个消息<code>0xAA</code>，试图去找另一个消息，使得它们的哈希值相等：</p>\r\n<pre class=\"solidity\"><code>    // 弱抗碰撞性\r\n    function weak(\r\n        string memory string1\r\n    )public view returns (bool){\r\n        return keccak256(abi.encodePacked(string1)) == _msg;\r\n    }</code></pre>\r\n<p>（大家可以试个10次，看看能不能幸运的碰撞上。）</p>\r\n<h4 id=\"强抗碰撞性\">强抗碰撞性</h4>\r\n<p>我们用<code>keccak256</code>演示一下之前讲到的强抗碰撞性，即找到任意不同的<code>x</code>和<code>x'</code>，使得<code>hash(x) = hash(x')</code>是困难的。</p>\r\n<p>我们构造一个函数<code>strong</code>，接收两个不同的<code>string</code>参数<code>string1</code>和<code>string2</code>，然后判断它们的哈希是否相同：</p>\r\n<pre class=\"solidity\"><code>    // 强抗碰撞性\r\n    function strong(\r\n        string memory string1,\r\n        string memory string2\r\n    )public pure returns (bool){\r\n        return keccak256(abi.encodePacked(string1)) == keccak256(abi.encodePacked(string2));\r\n    }</code></pre>\r\n<p>（大家可以试个10次，看看能不能幸运的碰撞上。）</p>\r\n<h2 id=\"选择器\">29.选择器</h2>\r\n<h3 id=\"selector\"><code>selector</code></h3>\r\n<p>当我们调用智能合约时，本质上是向目标合约发送了一段<code>calldata</code>，在remix中发送一次交易后，可以在详细信息中看见<code>input</code>即为此次交易的<code>calldata</code></p>\r\n<p><img src=\"https://wtf.academy/assets/images/29-1-0cdac97a91d23b8b328265d1df3a56b5.png\" alt=\"tx input in remix\"></p>\r\n<p>发送的<code>calldata</code>中前4个字节是<code>selector</code>（函数选择器）。</p>\r\n<h4 id=\"msg.data\"><code>msg.data</code></h4>\r\n<p><code>msg.data</code>是<code>solidity</code>中的一个全局变量，值为完整的<code>calldata</code>（调用函数时传入的数据）。</p>\r\n<p>在下面的代码中，我们可以通过<code>Log</code>事件来输出调用<code>mint</code>函数的<code>calldata</code>：</p>\r\n<pre class=\"solidity\"><code>    // event 返回msg.data\r\n    event Log(bytes data);\r\n\r\n    function mint(address to) external{\r\n        emit Log(msg.data);\r\n    }</code></pre>\r\n<p>当参数为<code>0x2c44b726ADF1963cA47Af88B284C06f30380fC78</code>时，输出的<code>calldata</code>为</p>\r\n<pre class=\"text\"><code>0x6a6278420000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78</code></pre>\r\n<p>这段很乱的字节码可以分成两部分：</p>\r\n<pre class=\"text\"><code>前4个字节为函数选择器selector：\r\n0x6a627842\r\n\r\n后面32个字节为输入的参数：\r\n0x0000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78</code></pre>\r\n<p>其实<code>calldata</code>就是告诉智能合约，我要调用哪个函数，以及参数是什么。</p>\r\n<h4 id=\"method-idselector和函数签名\"><code>method id</code>、<code>selector</code>和<code>函数签名</code></h4>\r\n<p><code>method id</code>定义为<code>函数签名</code>的<code>Keccak</code>哈希后的前4个字节，当<code>selector</code>与<code>method id</code>相匹配时，即表示调用该函数，那么<code>函数签名</code>是什么？</p>\r\n<p>其实在第21讲中，我们简单介绍了函数签名，为<code>\"函数名（逗号分隔的参数类型)\"</code>。举个例子，上面代码中<code>mint</code>的函数签名为<code>\"mint(address)\"</code>。在同一个智能合约中，不同的函数有不同的函数签名，因此我们可以通过函数签名来确定要调用哪个函数。</p>\r\n<p><strong>注意</strong>：在函数签名中，<code>uint</code>和<code>int</code>要写为<code>uint256</code>和<code>int256</code>。</p>\r\n<p>我们写一个函数，来验证<code>mint</code>函数的<code>method id</code>是否为<code>0x6a627842</code>。大家可以运行下面的函数，看看结果。</p>\r\n<pre class=\"solidity\"><code>    function mintSelector() external pure returns(bytes4 mSelector){\r\n        return bytes4(keccak256(\"mint(address)\"));\r\n    }</code></pre>\r\n<p>结果正是<code>0x6a627842</code>：</p>\r\n<p><img src=\"https://wtf.academy/assets/images/29-2-c2fb1c121b8e30f44786780b5199b742.png\" alt=\"method id in remix\"></p>\r\n<h4 id=\"使用selector\">使用<code>selector</code></h4>\r\n<p>我们可以利用<code>selector</code>来调用目标函数。例如我想调用<code>mint</code>函数，我只需要利用<code>abi.encodeWithSelector</code>将<code>mint</code>函数的<code>method id</code>作为<code>selector</code>和参数打包编码，传给<code>call</code>函数：</p>\r\n<pre class=\"solidity\"><code>    function callWithSignature() external returns(bool, bytes memory){\r\n        (bool success, bytes memory data) = address(this).call(abi.encodeWithSelector(0x6a627842, \"0x2c44b726ADF1963cA47Af88B284C06f30380fC78\"));\r\n        return(success, data);\r\n    }</code></pre>\r\n<p>在日志中，我们可以看到<code>mint</code>函数被成功调用，并输出<code>Log</code>事件。</p>\r\n<p><img src=\"https://wtf.academy/assets/images/29-3-07556b49a00092690652925132b23219.png\" alt=\"logs in remix\"></p>\r\n<h2 id=\"try-catch\">30.Try Catch</h2>\r\n<p><code>try-catch</code>是现代编程语言几乎都有的处理异常的一种标准方式，<code>solidity</code>0.6版本也添加了它。</p>\r\n<h3 id=\"try-catch-1\"><code>try-catch</code></h3>\r\n<p>在<code>solidity</code>中，<code>try-catch</code><strong>只能</strong>被用于<strong><code>external</code>函数</strong>或<strong>创建合约时<code>constructor</code>（被视为<code>external</code>函数）的调用</strong>。基本语法如下：</p>\r\n<pre class=\"solidity\"><code>        try externalContract.f() {\r\n            // call成功的情况下 运行一些代码\r\n        } catch {\r\n            // call失败的情况下 运行一些代码\r\n        }</code></pre>\r\n<p>其中<code>externalContract.f()</code>是某个外部合约的函数调用，<code>try</code>模块在<strong>调用成功</strong>的情况下运行，而<code>catch</code>模块则在<strong>调用失败</strong>时运行。</p>\r\n<p>同样可以使用<code>this.f()</code>来替代<code>externalContract.f()</code>，<code>this.f()</code>也被视作为外部调用，但不可在构造函数中使用，因为此时合约还未创建。</p>\r\n<p>如果调用的函数有返回值，那么必须在<code>try</code>之后声明<code>returns(returnType val)</code>，并且在<code>try</code>模块中可以使用返回的变量；如果是创建合约，那么返回值是新创建的合约变量。</p>\r\n<pre class=\"solidity\"><code>        try externalContract.f() returns(returnType val){\r\n            // call成功的情况下 运行一些代码\r\n        } catch {\r\n            // call失败的情况下 运行一些代码\r\n        }</code></pre>\r\n<p>另外，<code>catch</code>模块支持捕获特殊的异常原因：</p>\r\n<pre class=\"solidity\"><code>        try externalContract.f() returns(returnType){\r\n            // call成功的情况下 运行一些代码\r\n        } catch Error(string memory reason) {\r\n            // 捕获失败的 revert() 和 require()\r\n        } catch (bytes memory reason) {\r\n            // 捕获失败的 assert()\r\n        }</code></pre>\r\n<h3 id=\"try-catch实战\"><code>try-catch</code>实战</h3>\r\n<h4 id=\"onlyeven\"><code>onlyEven</code></h4>\r\n<p>我们创建一个外部合约<code>OnlyEven</code>，并使用<code>try-catch</code>来处理异常：</p>\r\n<pre class=\"solidity\"><code>contract OnlyEven{\r\n    constructor(uint a){\r\n        require(a != 0, \"invalid number\");\r\n        assert(a != 1);\r\n    }\r\n\r\n    function onlyEven(uint256 b) external pure returns(bool success){\r\n        // 输入奇数时revert\r\n        require(b % 2 == 0, \"Ups! Reverting\");\r\n        success = true;\r\n    }\r\n}</code></pre>\r\n<p><code>OnlyEven</code>合约包含一个构造函数和一个<code>onlyEven</code>函数。</p>\r\n<ul>\r\n<li>构造函数有一个参数<code>a</code>，当<code>a=0</code>时，<code>require</code>会抛出异常；当<code>a=1</code>时，<code>assert</code>会抛出异常；其他情况均正常。</li>\r\n<li><code>onlyEven</code>函数有一个参数<code>b</code>，当<code>b</code>为奇数时，<code>require</code>会抛出异常。</li>\r\n</ul>\r\n<h4 id=\"处理外部函数调用异常\">处理外部函数调用异常</h4>\r\n<p>首先，在<code>TryCatch</code>合约中定义一些事件和状态变量：</p>\r\n<pre class=\"solidity\"><code>    // 成功event\r\n    event SuccessEvent();\r\n\r\n    // 失败event\r\n    event CatchEvent(string message);\r\n    event CatchByte(bytes data);\r\n\r\n    // 声明OnlyEven合约变量\r\n    OnlyEven even;\r\n\r\n    constructor() {\r\n        even = new OnlyEven(2);\r\n    }</code></pre>\r\n<p><code>SuccessEvent</code>是调用成功会释放的事件，而<code>CatchEvent</code>和<code>CatchByte</code>是抛出异常时会释放的事件，分别对应<code>require/revert</code>和<code>assert</code>异常的情况。<code>even</code>是个<code>OnlyEven</code>合约类型的状态变量。</p>\r\n<p>然后我们在<code>execute</code>函数中使用<code>try-catch</code>处理调用外部函数<code>onlyEven</code>中的异常：</p>\r\n<pre class=\"solidity\"><code>    // 在external call中使用try-catch\r\n    function execute(uint amount) external returns (bool success) {\r\n        try even.onlyEven(amount) returns(bool _success){\r\n            // call成功的情况下\r\n            emit SuccessEvent();\r\n            return _success;\r\n        } catch Error(string memory reason){\r\n            // call不成功的情况下\r\n            emit CatchEvent(reason);\r\n        }\r\n    }</code></pre>\r\n","feature":true,"text":"solidity进阶 16.函数重载 重载 solidity中允许函数进行重载（overloading），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，solidity不允许修饰器（modifier）重载。 函数重载 举个例子，我们可以定义两个都叫s...","link":"","photos":[],"count_time":{"symbolsCount":"37k","symbolsTime":"34 mins."},"categories":[],"tags":[{"name":"solidity","slug":"solidity","count":2,"path":"api/tags/solidity.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#solidity%E8%BF%9B%E9%98%B6\"><span class=\"toc-text\">solidity进阶</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">16.函数重载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">重载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-1\"><span class=\"toc-text\">函数重载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E5%8F%82%E5%8C%B9%E9%85%8Dargument-matching\"><span class=\"toc-text\">实参匹配（Argument Matching）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%93%E5%90%88%E7%BA%A6\"><span class=\"toc-text\">17.库合约</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BA%93%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">库函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#string%E5%BA%93%E5%90%88%E7%BA%A6\"><span class=\"toc-text\">String库合约</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%BA%93%E5%90%88%E7%BA%A6\"><span class=\"toc-text\">如何使用库合约</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#import\"><span class=\"toc-text\">18.Import</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#import%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">import用法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%97eth\"><span class=\"toc-text\">19.接受ETH</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%97eth%E5%87%BD%E6%95%B0receive\"><span class=\"toc-text\">接受ETH函数receive</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E9%80%80%E5%87%BD%E6%95%B0fallback\"><span class=\"toc-text\">回退函数fallback</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#receive%E5%92%8Cfallback%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">receive和fallback的区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%91%E9%80%81eth\"><span class=\"toc-text\">20.发送ETH</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%97eth%E5%90%88%E7%BA%A6\"><span class=\"toc-text\">接受ETH合约</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%91%E9%80%81eth%E5%90%88%E7%BA%A6\"><span class=\"toc-text\">发送ETH合约</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#transfer\"><span class=\"toc-text\">transfer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#send\"><span class=\"toc-text\">send</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#call\"><span class=\"toc-text\">call</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E8%80%85%E7%9A%84%E9%80%89%E6%8B%A9\"><span class=\"toc-text\">三者的选择</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E5%90%88%E7%BA%A6\"><span class=\"toc-text\">21.调用其他合约</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E6%A0%87%E5%90%88%E7%BA%A6\"><span class=\"toc-text\">目标合约</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8othercontract%E5%90%88%E7%BA%A6\"><span class=\"toc-text\">调用OtherContract合约</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E5%85%A5%E5%90%88%E7%BA%A6%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">1.传入合约地址</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E5%85%A5%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">2.传入合约变量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">3.创建合约变量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E5%90%88%E7%BA%A6%E5%B9%B6%E5%8F%91%E9%80%81eth\"><span class=\"toc-text\">4.调用合约并发送ETH</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#call-1\"><span class=\"toc-text\">22.Call</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#call%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99\"><span class=\"toc-text\">call的使用规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E6%A0%87%E5%90%88%E7%BA%A6-1\"><span class=\"toc-text\">目标合约</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8call%E8%B0%83%E7%94%A8%E7%9B%AE%E6%A0%87%E5%90%88%E7%BA%A6\"><span class=\"toc-text\">利用call调用目标合约</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#delegatecall\"><span class=\"toc-text\">23.Delegatecall</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E7%94%A8%E5%88%B0delegatecall\"><span class=\"toc-text\">什么情况下会用到delegatecall</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#delegatecall%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">delegatecall例子</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E5%90%88%E7%BA%A6c\"><span class=\"toc-text\">被调用的合约C</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%91%E8%B5%B7%E8%B0%83%E7%94%A8%E7%9A%84%E5%90%88%E7%BA%A6b\"><span class=\"toc-text\">发起调用的合约B</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9C%A8remix%E4%B8%8A%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">在remix上验证</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E5%90%88%E7%BA%A6%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%B0%E5%90%88%E7%BA%A6\"><span class=\"toc-text\">24.在合约中创建新合约</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#create%E5%92%8Ccreate2\"><span class=\"toc-text\">create和create2</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%81%E7%AE%80uniswap\"><span class=\"toc-text\">极简Uniswap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#pair%E5%90%88%E7%BA%A6\"><span class=\"toc-text\">Pair合约</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#pairfactory\"><span class=\"toc-text\">PairFactory</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9C%A8remix%E4%B8%8A%E9%AA%8C%E8%AF%81-1\"><span class=\"toc-text\">在remix上验证</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#create2\"><span class=\"toc-text\">25.Create2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#create%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">Create如何计算地址</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#create2%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">Create2如何计算地址</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8create2\"><span class=\"toc-text\">如何使用Create2</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%81%E7%AE%80uniswap2\"><span class=\"toc-text\">极简Uniswap2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#pair\"><span class=\"toc-text\">Pair</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#pairfactory2\"><span class=\"toc-text\">PairFactory2</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%85%88%E8%AE%A1%E7%AE%97pair%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">事先计算Pair地址</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9C%A8remix%E4%B8%8A%E9%AA%8C%E8%AF%81-2\"><span class=\"toc-text\">在remix上验证</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#create2%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">create2的实际应用场景</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E5%90%88%E7%BA%A6\"><span class=\"toc-text\">26.删除合约</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#selfdestruct\"><span class=\"toc-text\">selfdestruct</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8selfdestruct\"><span class=\"toc-text\">如何使用selfdestruct</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">例子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#abi%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81\"><span class=\"toc-text\">27.ABI编码解码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#abi%E7%BC%96%E7%A0%81\"><span class=\"toc-text\">ABI编码</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#abi.encode\"><span class=\"toc-text\">abi.encode</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#abi.encodepacked\"><span class=\"toc-text\">abi.encodePacked</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#abi.encodewithsignature\"><span class=\"toc-text\">abi.encodeWithSignature</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#abi.encodewithselector\"><span class=\"toc-text\">abi.encodeWithSelector</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#abi%E8%A7%A3%E7%A0%81\"><span class=\"toc-text\">ABI解码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#abi.decode\"><span class=\"toc-text\">abi.decode</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#abi%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">ABI的使用场景</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#hash\"><span class=\"toc-text\">28.Hash</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#hash%E7%9A%84%E6%80%A7%E8%B4%A8\"><span class=\"toc-text\">Hash的性质</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#hash%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">Hash的应用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#keccak256\"><span class=\"toc-text\">Keccak256</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#keccak256%E5%92%8Csha3\"><span class=\"toc-text\">Keccak256和sha3</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%94%AF%E4%B8%80%E6%A0%87%E5%BF%97\"><span class=\"toc-text\">生成数据唯一标志</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%B1%E6%8A%97%E7%A2%B0%E6%92%9E%E6%80%A7\"><span class=\"toc-text\">弱抗碰撞性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%BA%E6%8A%97%E7%A2%B0%E6%92%9E%E6%80%A7\"><span class=\"toc-text\">强抗碰撞性</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E5%99%A8\"><span class=\"toc-text\">29.选择器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#selector\"><span class=\"toc-text\">selector</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#msg.data\"><span class=\"toc-text\">msg.data</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#method-idselector%E5%92%8C%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D\"><span class=\"toc-text\">method id、selector和函数签名</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8selector\"><span class=\"toc-text\">使用selector</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#try-catch\"><span class=\"toc-text\">30.Try Catch</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#try-catch-1\"><span class=\"toc-text\">try-catch</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#try-catch%E5%AE%9E%E6%88%98\"><span class=\"toc-text\">try-catch实战</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#onlyeven\"><span class=\"toc-text\">onlyEven</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">处理外部函数调用异常</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"cocoZ","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"想永远活在17岁！！！想越来越优秀！！！过去的遗憾现在弥补！！！ <br/> @ <b>QQ:1601760796<b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"solidity入门","uid":"3b889475d55359c53070293a35d903d7","slug":"solidity入门","date":"2022-11-26T16:55:02.000Z","updated":"2022-11-26T17:06:49.334Z","comments":true,"path":"api/articles/solidity入门.json","keywords":null,"cover":[],"text":"solidity 1.入门 // SPDX-License-Identifier: MIT //这个代码所用的软件许可，如果不写许可，编译时会警告 pragma solidity ^0.8.4; //声明源文件所用的solidity版本 contract HelloWeb3{ /...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[],"tags":[{"name":"solidity","slug":"solidity","count":2,"path":"api/tags/solidity.json"}],"author":{"name":"cocoZ","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"想永远活在17岁！！！想越来越优秀！！！过去的遗憾现在弥补！！！ <br/> @ <b>QQ:1601760796<b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}