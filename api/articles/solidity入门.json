{"title":"solidity入门","uid":"3b889475d55359c53070293a35d903d7","slug":"solidity入门","date":"2022-11-26T16:55:02.000Z","updated":"2022-12-17T12:18:51.054Z","comments":true,"path":"api/articles/solidity入门.json","keywords":null,"cover":"https://s2.loli.net/2022/12/17/eOYWR2zZ9rqSchP.jpg","content":"<h1 id=\"solidity\"><a href=\"#solidity\" class=\"headerlink\" title=\"solidity\"></a>solidity</h1><h2 id=\"1-入门\"><a href=\"#1-入门\" class=\"headerlink\" title=\"1.入门\"></a>1.入门</h2><pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// SPDX-License-Identifier: MIT\t\t\t\t//这个代码所用的软件许可，如果不写许可，编译时会警告</span>\n<span class=\"token keyword\">pragma</span> <span class=\"token keyword\">solidity</span> <span class=\"token operator\">^</span><span class=\"token version number\">0.8.4</span><span class=\"token punctuation\">;</span>\t\t\t\t<span class=\"token comment\">//声明源文件所用的solidity版本</span>\n<span class=\"token keyword\">contract</span> <span class=\"token class-name\">HelloWeb3</span><span class=\"token punctuation\">{</span>\t\t\t\t<span class=\"token comment\">//创建合约（contract），并声明合约名字为Helloweb3</span>\n    <span class=\"token builtin\">string</span> <span class=\"token keyword\">public</span> _string <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello Web3!\"</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">//合约的内容，声明了一个string（字符串）变量_string，并赋值</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"2-数值类型\"><a href=\"#2-数值类型\" class=\"headerlink\" title=\"2.数值类型\"></a>2.数值类型</h2><h3 id=\"数值类型\"><a href=\"#数值类型\" class=\"headerlink\" title=\"数值类型\"></a>数值类型</h3><p>1.布尔型：二值变量，取值为<strong> true</strong>或<strong>false</strong><br><code>bool public  _bool = true;</code><br>布尔值的运算符：！（逻辑非）、&amp;&amp;（逻辑与）、||（逻辑或）、==（等于）、！=（不等于）</p>\n<p>2.整型：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token builtin\">int</span> <span class=\"token keyword\">public</span> _int <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\t\t\t<span class=\"token comment\">//整数，包括负数</span>\n<span class=\"token builtin\">uint</span> <span class=\"token keyword\">public</span> _uint <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\t\t\t<span class=\"token comment\">//正整数</span>\n<span class=\"token builtin\">uint256</span> <span class=\"token keyword\">public</span> _number <span class=\"token operator\">=</span> <span class=\"token number\">20220330</span><span class=\"token punctuation\">;</span>\t\t <span class=\"token comment\">//256位正整数</span>\n<span class=\"token builtin\">uint</span> <span class=\"token keyword\">public</span> _coco1 <span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token operator\">**</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">//求指数2^4=16</span>\n<span class=\"token builtin\">bool</span> <span class=\"token keyword\">public</span> _numberbool <span class=\"token operator\">=</span> _Uint <span class=\"token operator\">&gt;</span> _int<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">//比大小</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>3.地址类型：<br>存储一个20字节的值（以太坊地址的大小）。<br>地址类型也由成员变量，并作为所有合约的基础。<br>地址类型分为<strong>普通的地址</strong>和<strong>可以转账ETH的地址（payable）</strong><br>payable的地址拥有balance和transfer（）两个成员，方便查询ETH余额以及转账。</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token builtin\">address</span> <span class=\"token keyword\">public</span> _address <span class=\"token operator\">=</span><span class=\"token number\">0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">address</span> <span class=\"token keyword\">payable</span> <span class=\"token keyword\">public</span> _address1 <span class=\"token operator\">=</span> <span class=\"token keyword\">payable</span><span class=\"token punctuation\">(</span>_address<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">//payable address可以转账、查余额</span>\n<span class=\"token builtin\">uint256</span> <span class=\"token keyword\">public</span> balance <span class=\"token operator\">=</span> _address1<span class=\"token punctuation\">.</span>balance<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//address1的余额</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>4.定长字节数组：<br>字节数组bytes分为定长（byte,bytes8，bytes32）和不定长。（定长的属于数值类型，不定长的属于引用类型）<br>定长byte可以存一些数据，消耗gas比较少</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token builtin\">bytes32</span> <span class=\"token keyword\">public</span> _byte32 <span class=\"token operator\">=</span> <span class=\"token string\">\"Minisolidity\"</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">//Minisolidity变量以字节的方式存储进变量_byte32，转换成16进制为：0x4d696e69536f6c69646974790000000000000000000000000000000000000000</span>\n<span class=\"token builtin\">bytes1</span> <span class=\"token keyword\">public</span> _byte <span class=\"token operator\">=</span> _byte32<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">//_byte变量存储_byte32的第一个字节，为0x4d</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>Tip：byte是bytes1的别名</p>\n<p><img src=\"https://s2.loli.net/2022/11/27/ug9m4Bn8fUsJVx6.png\" alt=\"image-20221027093034801.png\"><br>（Q:为啥每个元素会浪费31字节？)</p>\n<p>5.枚举enum<br>枚举是solidity中用户定义的数据类型，主要为uint分配名称，使程序易于阅读和维护（参考c语言）</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">enum</span> <span class=\"token class-name\">ActionSet</span><span class=\"token punctuation\">{</span>Buy<span class=\"token punctuation\">,</span>hold<span class=\"token punctuation\">,</span>Sell<span class=\"token punctuation\">}</span>\t\t<span class=\"token comment\">//用enum将unit 0， 1， 2表示为Buy, Hold, Sell</span>\nActionSet action <span class=\"token operator\">=</span> ActionSet<span class=\"token punctuation\">.</span>Buy<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//创建enum变量action</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><img src=\"https://s2.loli.net/2022/11/27/G9NCUmEzTJ6I8u1.png\" alt=\"image-20221027205852761.png\"><br>（Q:这段话有点看不懂，啥叫显式的和uint相互转换？然后检查是怎么检查的？)</p>\n<p><img src=\"https://s2.loli.net/2022/11/27/7EGa9uPgVh2Wfck.png\" alt=\"image-20221027210741846.png\"><br>emmmmm，懂了，我觉得就是数组名称和数组索引的转换，检查是自动会检查的，如果不在长度内会报错</p>\n<h2 id=\"3-函数类型\"><a href=\"#3-函数类型\" class=\"headerlink\" title=\"3.函数类型\"></a>3.函数类型</h2><h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">function</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">function</span> name<span class=\"token operator\">&gt;</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>parameter types<span class=\"token operator\">&gt;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">internal</span><span class=\"token operator\">|</span><span class=\"token keyword\">external</span><span class=\"token operator\">|</span><span class=\"token keyword\">public</span><span class=\"token operator\">|</span><span class=\"token keyword\">private</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">pure</span><span class=\"token operator\">|</span><span class=\"token keyword\">view</span><span class=\"token operator\">|</span><span class=\"token keyword\">payable</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">return</span> types<span class=\"token operator\">&gt;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">function</span> 函数名<span class=\"token punctuation\">(</span>输入到函数的变量类型和名字<span class=\"token punctuation\">)</span> 函数可见性说明符 决定函数权限<span class=\"token operator\">/</span>功能的关键字 <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span>函数返回的变量类型和名称<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>1.<code>function</code>：声明函数的关键字<br>2.<code>&lt;function name&gt;</code>：函数名<br>3.<code>(&lt;parameter types&gt;)</code>：函数的参数，变量类型+变量名<br>4.<code>{internal|external|public|private}</code>：函数可见性说明符，一共4种（没标明函数类型的，默认<code>internal</code>）</p>\n<ul>\n<li><code>public</code>：内部外部都可见（也可以用于修饰状态变量，public变量会自动生成<code>getter</code>函数，用于查询数据）</li>\n<li><code>private</code>：只能从合约内部访问，继承的合约也不能用（也可用于修饰状态变量）</li>\n<li><code>external</code>：只能从合约外部访问（但是可以用<code>this.f()</code>来调用，<code>f</code>是函数名）</li>\n<li><code>internal</code>：只能从合约内部访问，继承的合约可以用（也可以用于修饰状态变量）<br>5.<code>[pure|view|payable]</code>：决定函数权限/功能的关键字。（<code>payable</code>运行时可以给合约转入<code>ETH</code>）<br>6.<code>[returns()]</code>：函数返回的变量类型和名称 </li>\n</ul>\n<p><img src=\"https://s2.loli.net/2022/11/27/JYtKU5oBQ8g7Dmi.png\" alt=\"image-20221027214317445.png\"></p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">eg<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">return</span> data<span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"关于pure和view\"><a href=\"#关于pure和view\" class=\"headerlink\" title=\"关于pure和view\"></a>关于<code>pure</code>和<code>view</code></h4><p>在合约里面定义一个状态变量<code>number=5</code></p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// SPDX-License-Indentifier:MIT</span>\n<span class=\"token keyword\">pragma</span> <span class=\"token keyword\">solidity</span> <span class=\"token operator\">^</span><span class=\"token version number\">0.8.4</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">contract</span> <span class=\"token class-name\">FunctionTypes</span><span class=\"token punctuation\">{</span>\n<span class=\"token builtin\">uint256</span> <span class=\"token keyword\">public</span> number<span class=\"token operator\">=</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>定义一个<code>add()</code>函数，每次调用，每次给<code>number+1</code></p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">//默认</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">{</span>\nnumber<span class=\"token operator\">=</span>number<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>如果<code>add()</code>包含了<code>pure</code>关键字，例如<code>function add() pure external</code>，就会报错。<code>pure</code>没有权限读取合约的相关变量，更没有权限改写。<br><code>pure</code>函数能干啥捏？(<code>pure</code>：纯纯牛马emmmmm)<br>eg：可以给函数传递一个参数<code>_number</code>，然后让他返回<code>_number+1</code></p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">function</span> <span class=\"token function\">addPure</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> _number<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">pure</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> new_number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\nnew_number<span class=\"token operator\">=</span>_number<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://s2.loli.net/2022/11/27/5XEZmvxpYFQkwT6.png\" alt=\"image-20221029154221351.png\"></p>\n<p>如图，在_number位置传入一个参数7，就会执行函数，得到输出结果为8</p>\n<p>如果<code>add()</code>包含<code>view</code>，比如<code>function add() view external</code>也会报错。因为<code>view</code>能读取，但是不能够改写状态变量。可以稍微改一下，让其不改写<code>number</code>，而是返回一个新的变量。(<code>view</code>：看客)</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token builtin\">uint</span> <span class=\"token keyword\">public</span> number<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> new_number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\nnew_number<span class=\"token operator\">=</span>number<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://s2.loli.net/2022/11/27/orpfQxRaWBOweEK.png\" alt=\"image-20221029155635711.png\"></p>\n<p>点击addView这个函数就会直接读取number=5，直接输出number3=6</p>\n<p>（Q:遇到一个问题，就是这样子写报错了，addView函数里面写uint256 number=5也会报错，我觉得是因为view只有读取的权限没有写入的权限，是嘛是嘛？？？）</p>\n<p><img src=\"https://s2.loli.net/2022/11/27/vbsONroSlc3zBuj.png\" alt=\"image-20221029160053020.png\"></p>\n<p><img src=\"https://s2.loli.net/2022/11/27/pbyiCreHQFcklD2.png\" alt=\"image-20221029160113643.png\"></p>\n<h5 id=\"为什么引入pure和view关键字\"><a href=\"#为什么引入pure和view关键字\" class=\"headerlink\" title=\"为什么引入pure和view关键字\"></a>为什么引入<code>pure</code>和<code>view</code>关键字</h5><p><code>solidity</code>引入<code>pure</code>和<code>view</code>关键字主要是为了<strong>节省<code>gas</code></strong>和<strong>控制函数权限</strong>：如果用户直接调用<code>pure/view</code>方程是不消耗<code>gas</code>的（合约中非<code>pure/gas</code>函数调用它们则会改写链上状态，需要付<code>gas</code>）</p>\n<h4 id=\"关于internal和external\"><a href=\"#关于internal和external\" class=\"headerlink\" title=\"关于internal和external\"></a>关于<code>internal</code>和<code>external</code></h4><p>（Q：我自己问出了一个很蠢的问题：怎么区分合约内部和外部）<br>我思考了一下，还是要回到<code>1入门</code>那边，最开始学习到的创建一个合约</p>\n<p><img src=\"https://s2.loli.net/2022/11/27/X9bjnwNItQz2r17.png\" alt=\"image-20221029160952606.png\"></p>\n<p>所以我知道怎么区分了（所以我是pure，纯纯牛马一个</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">//internal:内部</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">minus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">internal</span><span class=\"token punctuation\">{</span>\nnumber<span class=\"token operator\">=</span>number<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//合约内的函数可以调用内部函数</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">minusCall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token function\">minus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>定义一个<code>internal</code>的<code>minus()</code>函数，每次调用使number-1。由于是<code>internal</code>，只能从合约内部调用，不能从外部。因此，还要再定义一个<code>external</code>的<code>minusCall()</code>函数，来直接调用内部的<code>minus()</code></p>\n<p><img src=\"https://s2.loli.net/2022/11/27/ZEn7ga8vf3UoDhk.png\" alt=\"image-20221029162810919.png\"></p>\n<p>图片里面只能看到minus222（）看不到minus（）这样子</p>\n<p>（Tip：我的理解是<code>internal</code>有像把函数写进合约内部，然后<code>external</code>是写在外部，直接调用即可。)（这样子理解有问题否？？？？？</p>\n<h4 id=\"payable\"><a href=\"#payable\" class=\"headerlink\" title=\"payable\"></a><code>payable</code></h4><pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">//payable：递钱，能给合约支付ETH的函数</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">minusPayable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">payable</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> balance<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token function\">minus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nbalance<span class=\"token operator\">=</span><span class=\"token builtin\">address</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>balance<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>定义一个<code>external payable</code>的<code>minusPayable()</code>函数，间接的调用<code>minus()</code>，并且返回合约里的<code>ETH</code>余额（<code>this</code>关键字可以让我们引用合约地址）<br>我们可以再调用<code>minusPayable()</code>时，往合约里转入1个<code>ETH</code></p>\n<p><img src=\"https://s2.loli.net/2022/11/27/3KLfpd2maTRN61V.png\" alt=\"image-20221029163704630.png\"></p>\n<p>是这样的，可以在左下角看到余额balance：1ETH</p>\n<p><img src=\"https://s2.loli.net/2022/11/27/Si6m3EUajLcRYnb.png\" alt=\"image-20221029163754954.png\"></p>\n<h2 id=\"4-函数输出return\"><a href=\"#4-函数输出return\" class=\"headerlink\" title=\"4.函数输出return\"></a>4.函数输出return</h2><h3 id=\"返回值return和returns\"><a href=\"#返回值return和returns\" class=\"headerlink\" title=\"返回值return和returns\"></a>返回值return和returns</h3><p><code>return</code>和<code>returns</code>这两个关键字与函数输出相关。区别在于：</p>\n<ul>\n<li><code>returns</code>加在函数名后面，用于声明返回的变量类型及变量名；</li>\n<li><code>returns</code>用于函数主体中，返回指定的变量。</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">//返回多个变量</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">returnMultiple</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">pure</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span><span class=\"token punctuation\">,</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">,</span><span class=\"token builtin\">uint256</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">memory</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">uint256</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>声明了<code>returnMultiple()</code>函数将有多个输出：<code>returns(uint256,bool,uint256[3] memory)</code>，接着在函数的主体中用<code>return(1,true,[uint256(1),2,5])</code>确定了返回值</p>\n<h3 id=\"命名式返回\"><a href=\"#命名式返回\" class=\"headerlink\" title=\"命名式返回\"></a>命名式返回</h3><p>我们可以在<code>returns</code>中 标明返回变量的名称，这样<code>solidity</code>会自动给这些变量初始化，并且自动返回这些函数的值，不需要加<code>return</code></p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// 返回多个变量</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">returnMultiple</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">pure</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint256</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">memory</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">uint256</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>改为</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// 命名式返回</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">returnNamed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">pure</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> _number<span class=\"token punctuation\">,</span> <span class=\"token builtin\">bool</span> _bool<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint256</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">memory</span> _array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    _number <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    _bool <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span> \n    _array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">uint256</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>Tip:也可以在命名式返回中用<code>return</code>来返回变量，跟第一种一样</p>\n<h3 id=\"解构式赋值\"><a href=\"#解构式赋值\" class=\"headerlink\" title=\"解构式赋值\"></a>解构式赋值</h3><ul>\n<li>读取所有返回值：声明变量，并且将要赋值的变量用<code>,</code>隔开，按顺序排列。</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token builtin\">uint256</span> _number<span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">bool</span> _bool<span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">uint256</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">memory</span> _array<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span>_number<span class=\"token punctuation\">,</span> _bool<span class=\"token punctuation\">,</span> _array<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token function\">returnNamed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。下面这段代码中，我们只读取<code>_bool</code>，而不读取返回的<code>_number</code>和<code>_array</code>：</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span> _bool2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token function\">returnNamed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"5-变量数据存储和作用域\"><a href=\"#5-变量数据存储和作用域\" class=\"headerlink\" title=\"5.变量数据存储和作用域\"></a>5.变量数据存储和作用域</h2><h3 id=\"引用类型-Reference-Type\"><a href=\"#引用类型-Reference-Type\" class=\"headerlink\" title=\"引用类型(Reference Type)\"></a>引用类型(Reference Type)</h3><p>数组(<code>array</code>)、结构体(<code>struct</code>)和映射(<code>mapping</code>)，这类变量占空间大，赋值时候直接传递地址（类似指针）。由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明<strong>数据存储的位置</strong>。</p>\n<h3 id=\"数据位置\"><a href=\"#数据位置\" class=\"headerlink\" title=\"数据位置\"></a>数据位置</h3><p><code>storage</code>、<code>memory</code>和<code>calldata</code>。<br>不同存储位置的<code>gas</code>成本不同：<br><code>storage</code>类型的数据存在链上，类似计算机的硬盘，消耗<code>gas</code>多；<br><code>memory</code>和<code>calldata</code>类型的临时存在内存里，消耗<code>gas</code>少。</p>\n<ul>\n<li><code>storage</code>：合约里的状态变量默认都是<code>storage</code>，存储在链上。</li>\n<li><code>memory</code>：函数里的参数和临时变量一般用<code>memory</code>，存储在内存中，不上链。</li>\n<li><code>calldata</code>：和<code>memory</code>类似，存储在内存中，不上链。与<code>memory</code>的不同点在于<code>calldata</code>变量不能修改（<code>immutable</code>），一般用于函数的参数。eg：</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">function</span> <span class=\"token function\">fCalldata</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">calldata</span> _x<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">pure</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">calldata</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//参数为calldata数组，不能被修改</span>\n    <span class=\"token comment\">// _x[0] = 0 //这样修改会报错</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>_x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"赋值规则\"><a href=\"#赋值规则\" class=\"headerlink\" title=\"赋值规则\"></a>赋值规则</h4><p>在不同存储类型相互赋值时候，有时会产生独立的副本（修改新变量不会影响原变量），有时会产生引用（修改新变量会影响原变量）。规则如下：</p>\n<ul>\n<li><code>storage</code>（合约的状态变量）赋值给本地<code>storage</code>（函数里的）时候，会创建引用，改变新变量会影响原变量。eg：</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> x <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 状态变量：数组 x</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">fStorage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//声明一个storage的变量 xStorage，指向x。修改xStorage也会影响x</span>\n    <span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">storage</span> xStorage <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    xStorage<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><code>storage</code>赋值给<code>memory</code>，会创建独立的复本，修改其中一个不会影响另一个；反之亦然。</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> x <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 状态变量：数组 x</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">fMemory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">view</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//声明一个Memory的变量xMemory，复制x。修改xMemory不会影响x</span>\n    <span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">memory</span> xMemory <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    xMemory<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n    xMemory<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">memory</span> xMemory2 <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    xMemory2<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">300</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><code>debug</code>康康</p>\n<p><img src=\"https://s2.loli.net/2022/11/27/9vTGVJyf4qu6cXj.png\" alt=\"image-20221124141004557.png\"></p>\n<p><img src=\"https://s2.loli.net/2022/11/27/52lLBitGYp6wxCD.png\" alt=\"image-20221124141019609.png\"></p>\n<ul>\n<li><code>memory</code>赋值给<code>memory</code>，会创建引用，改变新变量会影响原变量</li>\n<li>其他情况，变量赋值给<code>storage</code>，会创建独立的复本，修改其中一个不会影响另一个</li>\n</ul>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><ul>\n<li><p><strong>状态变量</strong><br>数据存储在链上的变量，所有的合约内的函数都可以访问，<code>gas</code>消耗高。状态变量在<strong>合约内、函数外</strong>声明（可以在函数里更改状态变量的值）</p>\n</li>\n<li><p><strong>局部变量</strong><br>局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，<code>gas</code>低。局部变量在<strong>函数内</strong>声明</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">pure</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">uint</span> xx <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">uint</span> yy <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">uint</span> zz <span class=\"token operator\">=</span> xx <span class=\"token operator\">+</span> yy<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>zz<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>全局变量</strong><br>全局变量是全局范围工作的变量，都是<code>solidity</code>预留关键字（可以在函数内不声明直接使用）</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">function</span> <span class=\"token function\">global</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">bytes</span> <span class=\"token keyword\">memory</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">address</span> sender <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">uint</span> blockNum <span class=\"token operator\">=</span> block<span class=\"token punctuation\">.</span>number<span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">bytes</span> <span class=\"token keyword\">memory</span> data <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>sender<span class=\"token punctuation\">,</span> blockNum<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://s2.loli.net/2022/11/27/TPm32juO1kWsnpX.png\" alt=\"image-20221124142321645.png\"></p>\n<h2 id=\"6-引用类型\"><a href=\"#6-引用类型\" class=\"headerlink\" title=\"6.引用类型\"></a>6.引用类型</h2><h3 id=\"数组array\"><a href=\"#数组array\" class=\"headerlink\" title=\"数组array\"></a>数组array</h3><p>数组（<code>Array</code>）是<code>solidity</code>常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）</p>\n<ul>\n<li>固定长度数组：在声明时指定数组的长度。用<code>T[k]</code>的格式表明，其中<code>T</code>是元素的类型，<code>k</code>是长度，eg:</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// 固定长度 Array</span>\n<span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span> array1<span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">bytes1</span><span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> array2<span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">address</span><span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span> array3<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>可变长度数组（动态数组）：在声明时不指定数值的长度。用<code>T[]</code>的格式表明，其中<code>T</code>是元素的类型（<code>bytes</code>比较特殊，是数组，但是不加<code>[]</code>），eg：</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// 可变长度 Array</span>\n<span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array4<span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">bytes1</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array5<span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">address</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array6<span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">bytes</span> array7<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"创建数组的规则\"><a href=\"#创建数组的规则\" class=\"headerlink\" title=\"创建数组的规则\"></a>创建数组的规则</h3><ul>\n<li>对于<code>memory</code>修饰的<code>动态数组</code>，可以用<code>new</code>操作符来创建，但是必须声明长度，并且声明后长度不能改变，eg：</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// memory动态数组</span>\n<span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">memory</span> array8 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">bytes</span> <span class=\"token keyword\">memory</span> array9 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">bytes</span><span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>数组字面常数（Array Literals）是写作表达形式的数组，用方括号包着来初始化array的一种方式，并且里面每一个元素的type是以<strong>第一个元素</strong>为准的，例如<code>[1,2,3]</code>里面所有的元素都是uint8类型，因为在solidity中如果一个值没有指定type的话，默认就是<strong>最小单位</strong>的该type，这里int的默认最小单位类型就是uint8。而<code>[uint(1),2,3]</code>里面的元素都是uint类型，因为第一个元素指定了是uint类型了，我们都以第一个元素为准。下面的合约中，对于f函数里面的调用，如果我们没有显式对第一个元素进行uint强转的话，是会报错的，因为如上所述我们其实是传入了uint8类型的array，可是g函数需要的却是uint类型的array，就会报错了。</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// SPDX-License-Identifier: GPL-3.0</span>\n<span class=\"token keyword\">pragma</span> <span class=\"token keyword\">solidity</span> <span class=\"token operator\">&gt;=</span><span class=\"token version number\">0.4.16</span> <span class=\"token operator\">&lt;</span><span class=\"token version number\">0.9.0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">contract</span> <span class=\"token class-name\">C</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">pure</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t <span class=\"token comment\">//uint(1)强转了。如果是g([1,2,3]),就是uint8类型</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">memory</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">pure</span> <span class=\"token punctuation\">{</span>\t<span class=\"token comment\">//g()这边传入的是uint类型</span>\n        <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>如果创建的是动态数组，你需要一个一个元素的赋值。</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">memory</span> x <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nx<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\nx<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\nx<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"数组成员\"><a href=\"#数组成员\" class=\"headerlink\" title=\"数组成员\"></a>数组成员</h3><p><img src=\"https://s2.loli.net/2022/11/27/hQUVlj2AEvoHDNw.png\" alt=\"image-20221126150559283.png\"></p>\n<h3 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h3><p>创建结构体</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// 结构体</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">uint256</span> id<span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">uint256</span> score<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">Student student<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 初始一个student结构体</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>给结构体赋值的两种方法</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">//  给结构体赋值</span>\n<span class=\"token comment\">// 方法1:在函数中创建一个storage的struct引用</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">initStudent1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">{</span>\n    Student <span class=\"token keyword\">storage</span> _student <span class=\"token operator\">=</span> student<span class=\"token punctuation\">;</span> <span class=\"token comment\">// assign a copy of student</span>\n    _student<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">11</span><span class=\"token punctuation\">;</span>\n    _student<span class=\"token punctuation\">.</span>score <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"> <span class=\"token comment\">// 方法2:直接引用状态变量的struct</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">initStudent2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">{</span>\n    student<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    student<span class=\"token punctuation\">.</span>score <span class=\"token operator\">=</span> <span class=\"token number\">80</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"7-映射类型\"><a href=\"#7-映射类型\" class=\"headerlink\" title=\"7.映射类型\"></a>7.映射类型</h2><h3 id=\"mapping\"><a href=\"#mapping\" class=\"headerlink\" title=\"mapping\"></a>mapping</h3><p>在映射中，人们可以通过键（<code>Key</code>）来查询对应的值（<code>Value</code>），比如：通过一个人的<code>id</code>来查询他的钱包地址。<br><code>mapping(_KeyType =&gt; _ValueType)</code>eg:</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> <span class=\"token operator\">=&gt;</span> <span class=\"token builtin\">address</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> idToAddress<span class=\"token punctuation\">;</span> <span class=\"token comment\">// id映射到地址</span>\n<span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> <span class=\"token operator\">=&gt;</span> <span class=\"token builtin\">address</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> swapPair<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 币对的映射，地址到地址</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"映射的规则\"><a href=\"#映射的规则\" class=\"headerlink\" title=\"映射的规则\"></a>映射的规则</h3><ul>\n<li><strong>规则1</strong>：映射的<code>_KeyType</code>只能选择<code>solidity</code>默认的类型，比如<code>uint</code>，<code>address</code>等，不能用自定义的结构体。而<code>_ValueType</code>可以使用自定义的类型。</li>\n<li><strong>规则2</strong>：映射的存储位置必须是<code>storage</code>，因此可以用于合约的状态变量，函数中的<code>storage</code>变量。不能用于<code>public</code>函数的参数或返回结果中，因为<code>mapping</code>记录的是一种关系 (key - value pair)。</li>\n<li><strong>规则3</strong>：如果映射声明为<code>public</code>，那么<code>solidity</code>会<strong>自动</strong>给你创建一个<code>getter</code>函数，可以通过<code>Key</code>来查询对应的<code>Value</code>。</li>\n<li><strong>规则4</strong>：给映射新增的键值对的语法为<code>_Var[_Key] = _Value</code>，其中<code>_Var</code>是映射变量名，<code>_Key</code>和<code>_Value</code>对应新增的键值对。eg：</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">function</span> writeMap <span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> _Key<span class=\"token punctuation\">,</span> <span class=\"token builtin\">address</span> _Value<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span><span class=\"token punctuation\">{</span>\n    idToAddress<span class=\"token punctuation\">[</span>_Key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> _Value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"映射的原理\"><a href=\"#映射的原理\" class=\"headerlink\" title=\"映射的原理\"></a>映射的原理</h3><ul>\n<li><strong>原理1</strong>：映射不储存任何键（<code>Key</code>）的资讯，也没有length的资讯。</li>\n<li><strong>原理2</strong>：映射使用<code>keccak256(key)</code>当成offset存取value。</li>\n<li><strong>原理3</strong>：因为Ethereum会定义所有未使用的空间为0，所以未赋值（<code>Value</code>）的键（<code>Key</code>）初始值都是0。</li>\n</ul>\n<h2 id=\"8-变量初始值\"><a href=\"#8-变量初始值\" class=\"headerlink\" title=\"8.变量初始值\"></a>8.变量初始值</h2><p>声明但没赋值的变量都是有初始值</p>\n<h3 id=\"值类型初始值\"><a href=\"#值类型初始值\" class=\"headerlink\" title=\"值类型初始值\"></a>值类型初始值</h3><ul>\n<li><code>boolean</code>:<code>false</code></li>\n<li><code>string</code>:<code>\"\"</code></li>\n<li><code>int</code>:<code>0</code></li>\n<li><code>uint</code>:<code>o</code></li>\n<li><code>enum</code>:枚举的第一个元素</li>\n<li><code>address</code>:<code>0x0000000000000000000000000000000000000000</code>(或<code>address(0)</code>)</li>\n<li><code>function</code><ul>\n<li><code>internal</code>:空白方程</li>\n<li><code>external</code>:空白方程</li>\n</ul>\n</li>\n</ul>\n<p>可以用<code>public</code>变量的<code>getter</code>函数验证初始值：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token builtin\">bool</span> <span class=\"token keyword\">public</span> _bool<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"引用类型初始值\"><a href=\"#引用类型初始值\" class=\"headerlink\" title=\"引用类型初始值\"></a>引用类型初始值</h3><ul>\n<li>映射<code>mapping</code>：所有元素都为其默认值的<code>mapping</code></li>\n<li>结构体<code>struct</code>：所有成员都设为其默认值的结构题</li>\n<li>数组<code>array</code>：<ul>\n<li>动态数组：<code>[]</code></li>\n<li>静态数组：所有成员设为其默认值的静态数组</li>\n</ul>\n</li>\n</ul>\n<p>验证方式一样，eg：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> <span class=\"token operator\">=&gt;</span> <span class=\"token builtin\">address</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> _mapping<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 所有元素都为其默认值的mapping</span>\n\n    <span class=\"token comment\">// 所有成员设为其默认值的结构体 0, 0</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">uint256</span> id<span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">uint256</span> score<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\nStudent <span class=\"token keyword\">public</span> student<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"delete操作符\"><a href=\"#delete操作符\" class=\"headerlink\" title=\"delete操作符\"></a><code>delete</code>操作符</h3><p><code>delete a</code>会让变量<code>a</code>的值变为初始值</p>\n<h2 id=\"9-常数\"><a href=\"#9-常数\" class=\"headerlink\" title=\"9.常数\"></a>9.常数</h2><p><code>constant</code>（常量）和<code>immutable</code>（不变量）。状态变量声明这个两个关键字之后，不能在合约后更改数值；并且还可以节省<code>gas</code>。<br>另外，只有数值变量可以声明<code>constant</code>和<code>immutable</code>；<code>string</code>和<code>bytes</code>可以声明为<code>constant</code>，但不能为<code>immutable</code>。</p>\n<h3 id=\"constant\"><a href=\"#constant\" class=\"headerlink\" title=\"constant\"></a>constant</h3><p><code>constant</code>变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过。</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// constant变量必须在声明的时候初始化，之后不能改变</span>\n<span class=\"token builtin\">uint256</span> <span class=\"token keyword\">constant</span> CONSTANT_NUM <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">string</span> <span class=\"token keyword\">constant</span> CONSTANT_STRING <span class=\"token operator\">=</span> <span class=\"token string\">\"0xAA\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">bytes</span> <span class=\"token keyword\">constant</span> CONSTANT_BYTES <span class=\"token operator\">=</span> <span class=\"token string\">\"WTF\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">address</span> <span class=\"token keyword\">constant</span> CONSTANT_ADDRESS <span class=\"token operator\">=</span> <span class=\"token number\">0x0000000000000000000000000000000000000000</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"immutable\"><a href=\"#immutable\" class=\"headerlink\" title=\"immutable\"></a>immutable</h3><p><code>immutable</code>变量可以在<strong>声明时</strong>或<strong>构造函数中</strong>初始化，因此更加灵活。</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// immutable变量可以在constructor里初始化，之后不能改变</span>\n<span class=\"token builtin\">uint256</span> <span class=\"token keyword\">public</span> immutable IMMUTABLE_NUM <span class=\"token operator\">=</span> <span class=\"token number\">9999999999</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">address</span> <span class=\"token keyword\">public</span> immutable IMMUTABLE_ADDRESS<span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">uint256</span> <span class=\"token keyword\">public</span> immutable IMMUTABLE_BLOCK<span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">uint256</span> <span class=\"token keyword\">public</span> immutable IMMUTABLE_TEST<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>可以使用全局变量例如<code>address(this)</code>，<code>block.number</code> ，或者自定义的函数给<code>immutable</code>变量初始化。在下面这个例子，我们利用了<code>test()</code>函数给<code>IMMUTABLE_TEST</code>初始化为<code>9</code>：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// 利用constructor初始化immutable变量，因此可以利用</span>\n<span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    IMMUTABLE_ADDRESS <span class=\"token operator\">=</span> <span class=\"token builtin\">address</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    IMMUTABLE_BLOCK <span class=\"token operator\">=</span> block<span class=\"token punctuation\">.</span>number<span class=\"token punctuation\">;</span>\n    IMMUTABLE_TEST <span class=\"token operator\">=</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">pure</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">uint256</span> what <span class=\"token operator\">=</span> <span class=\"token number\">9</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>what<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"10-控制流\"><a href=\"#10-控制流\" class=\"headerlink\" title=\"10.控制流\"></a>10.控制流</h2><ul>\n<li><code>if-else</code></li>\n<li><code>for循环</code></li>\n<li><code>whie循环</code></li>\n<li><code>do-while循环</code></li>\n<li><code>三元运算符</code>：三元运算符是<code>solidity</code>中唯一一个接受三个操作数的运算符，规则<code>条件? 条件为真的表达式:条件为假的表达式</code>。 此运算符经常用作 if 语句的快捷方式。</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// 三元运算符 ternary/conditional operator</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">ternaryTest</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> x<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint256</span> y<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">pure</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// return the max of x and y</span>\n    <span class=\"token keyword\">return</span> x <span class=\"token operator\">&gt;=</span> y <span class=\"token operator\">?</span> x<span class=\"token punctuation\">:</span> y<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"用solidity实现插入排序\"><a href=\"#用solidity实现插入排序\" class=\"headerlink\" title=\"用solidity实现插入排序\"></a>用<code>solidity</code>实现插入排序</h3><h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><p>排序算法解决的问题是将无序的一组数字，例如<code>[2, 5, 3, 1]</code>，从小到大依次排列好。（思路：从前往后，依次将每一个数和排在他前面的数字比大小，如果比前面的数字小，就互换位置。）</p>\n<p>贴个<code>python</code>代码</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token comment\"># Python program for implementation of Insertion Sort</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">insertionSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        key <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n        j <span class=\"token operator\">=</span> i<span class=\"token operator\">-</span><span class=\"token number\">1</span>\n        <span class=\"token keyword\">while</span> j <span class=\"token operator\">&gt;=</span><span class=\"token number\">0</span> <span class=\"token keyword\">and</span> key <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">:</span>\n                arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span>\n                j <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n        arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> key<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>改写成<code>solidity</code>后有BUG！</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// 插入排序 错误版</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">insertionSortWrong</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">memory</span> a<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">pure</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">memory</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    \n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token builtin\">uint</span> temp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token builtin\">uint</span> j<span class=\"token operator\">=</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">&gt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>temp <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            j<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>原因：<code>solidity</code>中最常用的变量类型是<code>uint</code>，也就是正整数，取到负值的话，会报<code>underflow</code>错误。而在插入算法中，变量<code>j</code>有可能会取到<code>-1</code>，引起报错。<br>这里把<code>j</code>加1，让它无法取到赋值</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// 插入排序 正确版</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">insertionSort</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">memory</span> a<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">pure</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">memory</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// note that uint can not take negative value</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token builtin\">uint</span> temp <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token builtin\">uint</span> j<span class=\"token operator\">=</span>i<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">&gt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>temp <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            j<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"11-构造函数和修饰器\"><a href=\"#11-构造函数和修饰器\" class=\"headerlink\" title=\"11.构造函数和修饰器\"></a>11.构造函数和修饰器</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>构造函数（<code>constructor</code>）是一种特殊的函数，每个合约可以定义一个，并在部署合约的时候自动运行一次。它可以用来初始化合约的一些参数，例如初始化合约的<code>owner</code>地址：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token builtin\">address</span> owner<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 定义owner变量</span>\n\n<span class=\"token comment\">// 构造函数</span>\n<span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   owner <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 在部署合约的时候，将owner设置为部署者的地址</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>Tip:构造函数在不同的solidity版本中的语法并不一致，在Solidity 0.4.22之前，构造函数不使用 <code>constructor</code> 而是使用与合约名同名的函数作为构造函数而使用，由于这种旧写法容易使开发者在书写时发生疏漏（例如合约名叫 <code>Parents</code>，构造函数名写成 <code>parents</code>），使得构造函数变成普通函数，引发漏洞，所以0.4.22版本及之后，采用了全新的 <code>constructor</code> 写法。</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">pragma</span> <span class=\"token keyword\">solidity</span> <span class=\"token operator\">=</span><span class=\"token number\">0.4</span><span class=\"token number\">.21</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">contract</span> <span class=\"token class-name\">Parents</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 与合约名Parents同名的函数就是构造函数</span>\n    <span class=\"token keyword\">function</span> Parents <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"修饰器\"><a href=\"#修饰器\" class=\"headerlink\" title=\"修饰器\"></a>修饰器</h3><p>修饰器（<code>modifier</code>）是<code>solidity</code>特有的语法，类似于面向对象编程中的<code>decorator</code>，声明函数拥有的特性，并减少代码冗余。<br><code>modifier</code>的主要使用场景是运行函数前的检查，例如地址，变量，余额等。</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// 定义modifier</span>\n<span class=\"token keyword\">modifier</span> onlyOwner <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>sender <span class=\"token operator\">==</span> owner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 检查调用者是否为owner地址</span>\n   <span class=\"token keyword\">_</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 如果是的话，继续运行函数主体；否则报错并revert交易</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>带有<code>onlyOwner</code>修饰符的函数只能被<code>owner</code>地址调用，比如下面这个例子：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">function</span> <span class=\"token function\">changeOwner</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> _newOwner<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> onlyOwner<span class=\"token punctuation\">{</span>\n   owner <span class=\"token operator\">=</span> _newOwner<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 只有owner地址运行这个函数，并改变owner</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>我们定义了一个<code>changeOwner</code>函数，运行他可以改变合约的<code>owner</code>，但是由于<code>onlyOwner</code>修饰符的存在，只有原先的<code>owner</code>可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。</p>\n<h2 id=\"12-事件\"><a href=\"#12-事件\" class=\"headerlink\" title=\"12.事件\"></a>12.事件</h2><p><code>Solidity</code>中的事件（<code>event</code>）是<code>EVM</code>上日志的抽象，它具有两个特点：</p>\n<ul>\n<li>应用程序（<a href=\"https://learnblockchain.cn/docs/ethers.js/api-contract.html#id18\"><code>ether.js</code></a>）可以通过<code>RPC</code>接口订阅和监听这些事件，并在前端做响应。</li>\n<li>事件是<code>EVM</code>上比较经济的存储数据的方式，每个大概消耗2,000 <code>gas</code>；相比之下，链上存储一个新变量至少需要20,000 <code>gas</code>。</li>\n</ul>\n<h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h3><p>事件的声明由<code>event</code>关键字开头，然后跟事件名称，括号里面写好事件需要记录的变量类型和变量名。以<code>ERC20</code>代币合约的<code>Transfer</code>事件为例：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">event</span> <span class=\"token function\">Transfer</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> <span class=\"token keyword\">indexed</span> <span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">address</span> <span class=\"token keyword\">indexed</span> to<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint256</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><code>Transfer</code>事件共记录了3个变量<code>from</code>，<code>to</code>和<code>value</code>，分别对应代币的转账地址，接收地址和转账数量。</p>\n<p>同时<code>from</code>和<code>to</code>前面带着<code>indexed</code>关键字，每个<code>indexed</code>标记的变量可以理解为<strong>检索事件的索引“键”</strong>，在以太坊上单独作为一个<code>topic</code>进行存储和索引，程序可以轻松的筛选出特定转账地址和接收地址的转账事件。每个事件<strong>最多</strong>有3个带<code>indexed</code>的变量。每个 <code>indexed</code> 变量的大小为固定的256比特。事件的哈希以及这三个带<code>indexed</code>的变量在<code>EVM</code>日志中通常被存储为<code>topic</code>。其中<code>topic[0]</code>是此事件的<code>keccak256</code>哈希，<code>topic[1]</code>到<code>topic[3]</code>存储了带<code>indexed</code>变量的<code>keccak256</code>哈希。<br><img src=\"https://wtf.academy/assets/images/12-3-b08311699b4378c7b077f1cd966b51e2.jpg\" alt=\"\"></p>\n<p><code>value</code> 不带 <code>indexed</code> 关键字，会存储在事件的 <code>data</code> 部分中，可以理解为事件的“值”。<code>data</code> 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般 <code>data</code> 部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的 <code>topic</code> 部分中，也是以哈希的方式存储。另外，<code>data</code> 部分的变量在存储上消耗的gas相比于 <code>topic</code> 更少。</p>\n<p>可以在函数里释放事件：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// 定义_transfer函数，执行转账逻辑</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">_transfer</span><span class=\"token punctuation\">(</span>\n    <span class=\"token builtin\">address</span> <span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span>\n    <span class=\"token builtin\">address</span> to<span class=\"token punctuation\">,</span>\n    <span class=\"token builtin\">uint256</span> amount\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token punctuation\">{</span>\n\n    _balances<span class=\"token punctuation\">[</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">10000000</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 给转账地址一些初始代币</span>\n\n    _balances<span class=\"token punctuation\">[</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-=</span>  amount<span class=\"token punctuation\">;</span> <span class=\"token comment\">// from地址减去转账数量</span>\n    _balances<span class=\"token punctuation\">[</span>to<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> amount<span class=\"token punctuation\">;</span> <span class=\"token comment\">// to地址加上转账数量</span>\n\n    <span class=\"token comment\">// 释放事件</span>\n    <span class=\"token keyword\">emit</span> <span class=\"token function\">Transfer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">,</span> amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"13-继承\"><a href=\"#13-继承\" class=\"headerlink\" title=\"13.继承\"></a>13.继承</h2><h3 id=\"规则-1\"><a href=\"#规则-1\" class=\"headerlink\" title=\"规则\"></a>规则</h3><ul>\n<li><code>virtual</code>: 父合约中的函数，如果希望子合约重写，需要加上<code>virtual</code>关键字。</li>\n<li><code>override</code>：子合约重写了父合约中的函数，需要加上<code>override</code>关键字。</li>\n</ul>\n<h3 id=\"简单继承\"><a href=\"#简单继承\" class=\"headerlink\" title=\"简单继承\"></a>简单继承</h3><p>（确实比较简单，直接贴例子）</p>\n<p>先写一个简单的爷爷合约<code>Yeye</code>，里面包含1个<code>Log</code>事件和3个<code>function</code>: <code>hip()</code>, <code>pop()</code>, <code>yeye()</code>，输出都是”Yeye”。</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">contract</span> <span class=\"token class-name\">Yeye</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">event</span> <span class=\"token function\">Log</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span> msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 定义3个function: hip(), pop(), man()，Log值为Yeye。</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">hip</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> virtual<span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">emit</span> <span class=\"token function\">Log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Yeye\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> virtual<span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">emit</span> <span class=\"token function\">Log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Yeye\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">yeye</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> virtual <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">emit</span> <span class=\"token function\">Log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Yeye\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>再定义一个爸爸合约<code>Baba</code>，让他继承<code>Yeye</code>合约，语法就是<code>contract Baba is Yeye</code>，非常直观。在<code>Baba</code>合约里，我们重写一下<code>hip()</code>和<code>pop()</code>这两个函数，加上<code>override</code>关键字，并将他们的输出改为<code>”Baba”</code>；并且加一个新的函数<code>baba</code>，输出也是<code>”Baba”</code>。</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">contract</span> <span class=\"token class-name\">Baba</span> <span class=\"token keyword\">is</span> Yeye<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 继承两个function: hip()和pop()，输出改为Baba。</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">hip</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> virtual override<span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">emit</span> <span class=\"token function\">Log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Baba\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> virtual override<span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">emit</span> <span class=\"token function\">Log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Baba\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">baba</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> virtual<span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">emit</span> <span class=\"token function\">Log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Baba\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>部署合约，可以看到<code>Baba</code>合约里有4个函数，其中<code>hip()</code>和<code>pop()</code>的输出被成功改写成<code>”Baba”</code>，而继承来的<code>yeye()</code>的输出仍然是<code>”Yeye”</code>。</p>\n<h3 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h3><p><code>solidity</code>合约可以继承多个合约</p>\n<p>继承时要按辈分<strong>最高到最低</strong>的顺序排。比如我们写一个<code>Erzi</code>合约，继承<code>Yeye</code>合约和<code>Baba</code>合约，那么就要写成<code>contract Erzi is Yeye, Baba</code>，而不能写成<code>contract Erzi is Baba, Yeye</code>，不然就会报错。 如果某一个函数在多个继承的合约里都存在，比如例子中的<code>hip()</code>和<code>pop()</code>，在子合约里必须重写，不然会报错。 重写在多个父合约中都<strong>重名</strong>的函数时，<code>override</code>关键字后面要加上<strong>所有</strong>父合约名字，例如<code>override(Yeye, Baba)</code>。 例子：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">contract</span> <span class=\"token class-name\">Erzi</span> <span class=\"token keyword\">is</span> Yeye<span class=\"token punctuation\">,</span> Baba<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 继承两个function: hip()和pop()，输出值为Erzi。</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">hip</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> virtual <span class=\"token function\">override</span><span class=\"token punctuation\">(</span>Yeye<span class=\"token punctuation\">,</span> Baba<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">emit</span> <span class=\"token function\">Log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Erzi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> virtual <span class=\"token function\">override</span><span class=\"token punctuation\">(</span>Yeye<span class=\"token punctuation\">,</span> Baba<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">emit</span> <span class=\"token function\">Log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Erzi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"修饰器的继承\"><a href=\"#修饰器的继承\" class=\"headerlink\" title=\"修饰器的继承\"></a>修饰器的继承</h3><p><code>Solidity</code>中的修饰器（<code>Modifier</code>）同样可以继承，用法与函数继承类似，在相应的地方加<code>virtual</code>和<code>override</code>关键字即可。</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">contract</span> <span class=\"token class-name\">Base1</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">modifier</span> <span class=\"token function\">exactDividedBy2And3</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> _a<span class=\"token punctuation\">)</span> virtual <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>_a <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> _a <span class=\"token operator\">%</span> <span class=\"token number\">3</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">_</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">contract</span> <span class=\"token class-name\">Identifier</span> <span class=\"token keyword\">is</span> Base1 <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">//计算一个数分别被2除和被3除的值，但是传入的参数必须是2和3的倍数</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">getExactDividedBy2And3</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> _dividend<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token function\">exactDividedBy2And3</span><span class=\"token punctuation\">(</span>_dividend<span class=\"token punctuation\">)</span> <span class=\"token keyword\">pure</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">getExactDividedBy2And3WithoutModifier</span><span class=\"token punctuation\">(</span>_dividend<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">//计算一个数分别被2除和被3除的值</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">getExactDividedBy2And3WithoutModifier</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> _dividend<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">pure</span> <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token builtin\">uint</span> div2 <span class=\"token operator\">=</span> _dividend <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        <span class=\"token builtin\">uint</span> div3 <span class=\"token operator\">=</span> _dividend <span class=\"token operator\">/</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>div2<span class=\"token punctuation\">,</span> div3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><code>Identifier</code>合约可以直接在代码中使用父合约中的<code>exactDividedBy2And3</code>修饰器，也可以利用<code>override</code>关键字重写修饰器：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">modifier</span> <span class=\"token function\">exactDividedBy2And3</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> _a<span class=\"token punctuation\">)</span> override <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">_</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>_a <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> _a <span class=\"token operator\">%</span> <span class=\"token number\">3</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"构造函数的继承\"><a href=\"#构造函数的继承\" class=\"headerlink\" title=\"构造函数的继承\"></a>构造函数的继承</h3><p>子合约有两种方法继承父合约的构造函数。举个简单的例子，父合约A里面有一个状态变量a，并由构造函数的参数来确定：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token comment\">// 构造函数的继承</span>\nabstract <span class=\"token keyword\">contract</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">uint</span> <span class=\"token keyword\">public</span> a<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> _a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        a <span class=\"token operator\">=</span> _a<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>1.在继承时声明父构造函数的参数，例如：<code>contract B is A(1)</code><br>2.在子合约的构造函数中声明构造函数的参数，例如：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">contract</span> <span class=\"token class-name\">C</span> <span class=\"token keyword\">is</span> A <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> _c<span class=\"token punctuation\">)</span> <span class=\"token function\">A</span><span class=\"token punctuation\">(</span>_c <span class=\"token operator\">*</span> _c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"调用父合约的函数\"><a href=\"#调用父合约的函数\" class=\"headerlink\" title=\"调用父合约的函数\"></a>调用父合约的函数</h3><p>子合约有两种调用父合约的函数</p>\n<ul>\n<li>直接调用：子合约可以直接用<code>父合约名.函数名()</code>的方式来调用父合约函数，例如<code>Yeye.pop()</code>。</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">function</span> <span class=\"token function\">callParent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span><span class=\"token punctuation\">{</span>\n    Yeye<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><code>super</code>关键字：子合约可以利用<code>super.函数名()</code>来调用最近的父合约函数。<code>solidity</code>继承关系按声明时<strong>从右到左</strong>的顺序是：<code>contract Erzi is Yeye, Baba</code>，那么<code>Baba</code>是最近的父合约，<code>super.pop()</code>将调用<code>Baba.pop()</code>而不是<code>Yeye.pop()</code>：</li>\n</ul>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">function</span> <span class=\"token function\">callParentSuper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 将调用最近的父合约函数，Baba.pop()</span>\n    super<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"14-抽象合约和接口\"><a href=\"#14-抽象合约和接口\" class=\"headerlink\" title=\"14.抽象合约和接口\"></a>14.抽象合约和接口</h2><h3 id=\"抽象合约\"><a href=\"#抽象合约\" class=\"headerlink\" title=\"抽象合约\"></a>抽象合约</h3><p>如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体<code>{}</code>中的内容，则必须将该合约标为<code>abstract</code>，不然编译会报错；另外，未实现的函数需要加<code>virtual</code>，以便子合约重写。拿我们之前的<code>插入排序合约</code>为例，如果我们还没想好具体怎么实现插入排序函数，那么可以把合约标为<code>abstract</code>，之后让别人补写上。</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">abstract <span class=\"token keyword\">contract</span> <span class=\"token class-name\">InsertionSort</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">insertionSort</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">memory</span> a<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">pure</span> virtual <span class=\"token keyword\">returns</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">memory</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>接口类似于抽象合约，但不实现任何功能。<br>规则：</p>\n<ul>\n<li>不能包含状态变量</li>\n<li>不能包含构造函数</li>\n<li>不能继承除接口外的其他合约</li>\n<li>所有函数都必须是<code>external</code>且不能有函数体</li>\n<li>继承接口的合约必须实现接口定义的所有功能</li>\n</ul>\n<p>虽然接口不实现任何功能，但它非常重要。接口是智能合约的骨架，定义了合约的功能以及如何触发它们：如果智能合约实现了某种接口（比如<code>ERC20</code>或<code>ERC721</code>），其他Dapps和智能合约就知道如何与它交互。因为接口提供了两个重要的信息：<br>1.合约里每个函数的bytes4选择器，以及基于它们的函数签名函数名(每个参数类型）。<br>2.接口id（更多信息见<a href=\"https://eips.ethereum.org/EIPS/eip-165\">EIP165</a>）</p>\n<p>另外，接口与合约<code>ABI</code>（Application Binary Interface）等价，可以相互转换：编译接口可以得到合约的<code>ABI</code>，利用<a href=\"https://gnidan.github.io/abi-to-sol/\">abi-to-sol工具</a>也可以将<code>ABI json</code>文件转换为<code>接口sol</code>文件。</p>\n<p>我们以<code>ERC721</code>接口合约<code>IERC721</code>为例，它定义了3个<code>event</code>和9个<code>function</code>，所有<code>ERC721</code>标准的NFT都实现了这些函数。我们可以看到，接口和常规合约的区别在于每个函数都以<code>;</code>代替函数体<code>{ }</code>结尾。</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">IERC721</span> <span class=\"token keyword\">is</span> IERC165 <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">event</span> <span class=\"token function\">Transfer</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> <span class=\"token keyword\">indexed</span> <span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">address</span> <span class=\"token keyword\">indexed</span> to<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint256</span> <span class=\"token keyword\">indexed</span> tokenId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">event</span> <span class=\"token function\">Approval</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> <span class=\"token keyword\">indexed</span> owner<span class=\"token punctuation\">,</span> <span class=\"token builtin\">address</span> <span class=\"token keyword\">indexed</span> approved<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint256</span> <span class=\"token keyword\">indexed</span> tokenId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">event</span> <span class=\"token function\">ApprovalForAll</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> <span class=\"token keyword\">indexed</span> owner<span class=\"token punctuation\">,</span> <span class=\"token builtin\">address</span> <span class=\"token keyword\">indexed</span> operator<span class=\"token punctuation\">,</span> <span class=\"token builtin\">bool</span> approved<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">function</span> <span class=\"token function\">balanceOf</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> owner<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> balance<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">ownerOf</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> tokenId<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> owner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">safeTransferFrom</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> <span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">address</span> to<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint256</span> tokenId<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">transferFrom</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> <span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">address</span> to<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint256</span> tokenId<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">approve</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> to<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint256</span> tokenId<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">getApproved</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> tokenId<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> operator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">setApprovalForAll</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> operator<span class=\"token punctuation\">,</span> <span class=\"token builtin\">bool</span> _approved<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">isApprovedForAll</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> owner<span class=\"token punctuation\">,</span> <span class=\"token builtin\">address</span> operator<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">safeTransferFrom</span><span class=\"token punctuation\">(</span> <span class=\"token builtin\">address</span> <span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">address</span> to<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint256</span> tokenId<span class=\"token punctuation\">,</span> <span class=\"token builtin\">bytes</span> <span class=\"token keyword\">calldata</span> data<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"IERC721事件\"><a href=\"#IERC721事件\" class=\"headerlink\" title=\"IERC721事件\"></a>IERC721事件</h3><p><code>IERC721</code>包含3个事件，其中<code>Transfer</code>和<code>Approval</code>事件在<code>ERC20</code>中也有。</p>\n<ul>\n<li><code>Transfer</code>事件：在转账时被释放，记录代币的发出地址<code>from</code>，接收地址<code>to</code>和<code>tokenid</code>。</li>\n<li><code>Approval</code>事件：在授权时释放，记录授权地址<code>owner</code>，被授权地址<code>approved</code>和<code>tokenid</code>。</li>\n<li><code>ApprovalForAll</code>事件：在批量授权时释放，记录批量授权的发出地址<code>owner</code>，被授权地址<code>operator</code>和授权与否的<code>approved</code>。</li>\n</ul>\n<h3 id=\"IERC721函数\"><a href=\"#IERC721函数\" class=\"headerlink\" title=\"IERC721函数\"></a>IERC721函数</h3><ul>\n<li><code>balanceOf</code>：返回某地址的NFT持有量<code>balance</code>。</li>\n<li><code>ownerOf</code>：返回某<code>tokenId</code>的主人<code>owner</code>。</li>\n<li><code>transferFrom</code>：普通转账，参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li>\n<li><code>safeTransferFrom</code>：安全转账（如果接收方是合约地址，会要求实现<code>ERC721Receiver</code>接口）。参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li>\n<li><code>approve</code>：授权另一个地址使用你的NFT。参数为被授权地址<code>approve</code>和<code>tokenId</code>。</li>\n<li><code>getApproved</code>：查询<code>tokenId</code>被批准给了哪个地址。</li>\n<li><code>setApprovalForAll</code>：将自己持有的该系列NFT批量授权给某个地址<code>operator</code>。</li>\n<li><code>isApprovedForAll</code>：查询某地址的NFT是否批量授权给了另一个<code>operator</code>地址。</li>\n<li><code>safeTransferFrom</code>：安全转账的重载函数，参数里面包含了<code>data</code>。</li>\n</ul>\n<h3 id=\"什么时候使用接口\"><a href=\"#什么时候使用接口\" class=\"headerlink\" title=\"什么时候使用接口\"></a>什么时候使用接口</h3><p>如果我们知道一个合约实现了<code>IERC721</code>接口，我们不需要知道它具体代码实现，就可以与它交互。</p>\n<p>无聊猿<code>BAYC</code>属于<code>ERC721</code>代币，实现了<code>IERC721</code>接口的功能。我们不需要知道它的源代码，只需知道它的合约地址，用<code>IERC721</code>接口就可以与它交互，比如用<code>balanceOf()</code>来查询某个地址的<code>BAYC</code>余额，用<code>safeTransferFrom()</code>来转账<code>BAYC</code>。</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">contract</span> <span class=\"token class-name\">interactBAYC</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 利用BAYC地址创建接口合约变量（ETH主网）</span>\n    IERC721 BAYC <span class=\"token operator\">=</span> <span class=\"token function\">IERC721</span><span class=\"token punctuation\">(</span><span class=\"token number\">0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 通过接口调用BAYC的balanceOf()查询持仓量</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">balanceOfBAYC</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> owner<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> balance<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> BAYC<span class=\"token punctuation\">.</span><span class=\"token function\">balanceOf</span><span class=\"token punctuation\">(</span>owner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 通过接口调用BAYC的safeTransferFrom()安全转账</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">safeTransferFromBAYC</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> <span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">address</span> to<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint256</span> tokenId<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">{</span>\n        BAYC<span class=\"token punctuation\">.</span><span class=\"token function\">safeTransferFrom</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">,</span> tokenId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"15-异常\"><a href=\"#15-异常\" class=\"headerlink\" title=\"15.异常\"></a>15.异常</h2><p>写智能合约经常会出<code>bug</code>，<code>solidity</code>中的异常命令帮助我们<code>debug</code>。</p>\n<h3 id=\"Error\"><a href=\"#Error\" class=\"headerlink\" title=\"Error\"></a>Error</h3><p><code>error</code>是<code>solidity 0.8版本</code>新加的内容，方便且高效（省<code>gas</code>）地向用户解释操作失败的原因。人们可以在<code>contract</code>之外定义异常。下面，我们定义一个<code>TransferNotOwner</code>异常，当用户不是代币<code>owner</code>的时候尝试转账，会抛出错误：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\">error <span class=\"token function\">TransferNotOwner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 自定义error</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>在执行当中，<code>error</code>必须搭配<code>revert</code>（回退）命令使用。</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">function</span> <span class=\"token function\">transferOwner1</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> tokenId<span class=\"token punctuation\">,</span> <span class=\"token builtin\">address</span> newOwner<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>_owners<span class=\"token punctuation\">[</span>tokenId<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">revert</span> <span class=\"token function\">TransferNotOwner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    _owners<span class=\"token punctuation\">[</span>tokenId<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> newOwner<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们定义了一个<code>transferOwner1()</code>函数，它会检查代币的<code>owner</code>是不是发起人，如果不是，就会抛出<code>TransferNotOwner</code>异常；如果是的话，就会转账。</p>\n<h3 id=\"Require\"><a href=\"#Require\" class=\"headerlink\" title=\"Require\"></a>Require</h3><p><code>require</code>命令是<code>solidity 0.8版本</code>之前抛出异常的常用方法，目前很多主流合约仍然还在使用它。它很好用，唯一的缺点就是<code>gas</code>随着描述异常的字符串长度增加，比<code>error</code>命令要高。使用方法：<code>require(检查条件，\"异常的描述\")</code>，当检查条件不成立的时候，就会抛出异常。</p>\n<p>我们用<code>require</code>命令重写一下上面的<code>transferOwner</code>函数：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">function</span> <span class=\"token function\">transferOwner2</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> tokenId<span class=\"token punctuation\">,</span> <span class=\"token builtin\">address</span> newOwner<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>_owners<span class=\"token punctuation\">[</span>tokenId<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Transfer Not Owner\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    _owners<span class=\"token punctuation\">[</span>tokenId<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> newOwner<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>贴个在remix上验证的例子吧<br>1.输入任意<code>uint256</code>数字和非0地址，调用<code>transferOwner1</code>，也就是<code>error</code>方法，控制台抛出了异常并显示我们自定义的<code>TransferNotOwner</code>。<br><img src=\"https://wtf.academy/assets/images/15-1-108068d779547bb5f2bbe63c4e350fab.png\" alt=\"\"><br>2.输入任意<code>uint256</code>数字和非0地址，调用<code>transferOwner2</code>，也就是<code>require</code>方法，控制台抛出了异常并打印出<code>require</code>中的字符串。<br><img src=\"https://wtf.academy/assets/images/15-2-5cd86c90ad4a466946c842c346a5ee18.png\" alt=\"\"><br>3.输入任意<code>uint256</code>数字和非0地址，调用<code>transferOwner3</code>，也就是<code>assert</code>方法，控制台只抛出了异常。<br><img src=\"https://wtf.academy/assets/images/15-3-390b3562e3410dd9f6256b66e8d2610f.png\" alt=\"\"></p>\n<h3 id=\"Assert\"><a href=\"#Assert\" class=\"headerlink\" title=\"Assert\"></a>Assert</h3><p><code>assert</code>命令一般用于程序员写程序<code>debug</code>，因为它不能解释抛出异常的原因（比<code>require</code>少个字符串）。它的用法很简单，<code>assert(检查条件）</code>，当检查条件不成立的时候，就会抛出异常。</p>\n<p>我们用<code>assert</code>命令重写一下上面的<code>transferOwner</code>函数：</p>\n<pre class=\"line-numbers language-solidity\" data-language=\"solidity\"><code class=\"language-solidity\"><span class=\"token keyword\">function</span> <span class=\"token function\">transferOwner3</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> tokenId<span class=\"token punctuation\">,</span> <span class=\"token builtin\">address</span> newOwner<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">assert</span><span class=\"token punctuation\">(</span>_owners<span class=\"token punctuation\">[</span>tokenId<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    _owners<span class=\"token punctuation\">[</span>tokenId<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> newOwner<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"三种方法的gas比较\"><a href=\"#三种方法的gas比较\" class=\"headerlink\" title=\"三种方法的gas比较\"></a>三种方法的<code>gas</code>比较</h3><p>我们比较一下三种抛出异常的<code>gas</code>消耗，通过remix控制台的Debug按钮，能查到每次函数调用的<code>gas</code>消耗分别如下：</p>\n<ol>\n<li><strong><code>error</code>方法<code>gas</code>消耗</strong>：24445</li>\n<li><strong><code>require</code>方法<code>gas</code>消耗</strong>：24743</li>\n<li><strong><code>assert</code>方法<code>gas</code>消耗</strong>：24446</li>\n</ol>\n<p>我们可以看到，<code>error</code>方法<code>gas</code>最少，其次是<code>assert</code>，<code>require</code>方法消耗<code>gas</code>最多！因此，<code>error</code>既可以告知用户抛出异常的原因，又能省<code>gas</code>，大家要多用！（注意，由于部署测试时间的不同，每个函数的<code>gas</code>消耗会有所不同，但是比较结果会是一致的。）</p>\n","text":"solidity1.入门// SPDX-License-Identifier: MIT //这个代码所用的软件许可，如果不写许可，编译时会警告 pragma solidity ^0.8.4; //声明源文件所用的solidity版本 contract HelloWeb3{ //创...","link":"","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[],"tags":[{"name":"solidity","slug":"solidity","count":2,"path":"api/tags/solidity.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#solidity\"><span class=\"toc-text\">solidity</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">1.入门</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2.数值类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">数值类型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">3.函数类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8Epure%E5%92%8Cview\"><span class=\"toc-text\">关于pure和view</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5pure%E5%92%8Cview%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">为什么引入pure和view关键字</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8Einternal%E5%92%8Cexternal\"><span class=\"toc-text\">关于internal和external</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#payable\"><span class=\"toc-text\">payable</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BAreturn\"><span class=\"toc-text\">4.函数输出return</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%80%BCreturn%E5%92%8Creturns\"><span class=\"toc-text\">返回值return和returns</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%91%BD%E5%90%8D%E5%BC%8F%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">命名式返回</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%9E%84%E5%BC%8F%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">解构式赋值</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%8F%98%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">5.变量数据存储和作用域</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-Reference-Type\"><span class=\"toc-text\">引用类型(Reference Type)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">数据位置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B5%8B%E5%80%BC%E8%A7%84%E5%88%99\"><span class=\"toc-text\">赋值规则</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">作用域</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">6.引用类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84array\"><span class=\"toc-text\">数组array</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%84%E5%88%99\"><span class=\"toc-text\">创建数组的规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E6%88%90%E5%91%98\"><span class=\"toc-text\">数组成员</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">结构体</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">7.映射类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mapping\"><span class=\"toc-text\">mapping</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%A0%E5%B0%84%E7%9A%84%E8%A7%84%E5%88%99\"><span class=\"toc-text\">映射的规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%A0%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">映射的原理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%80%BC\"><span class=\"toc-text\">8.变量初始值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%88%9D%E5%A7%8B%E5%80%BC\"><span class=\"toc-text\">值类型初始值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%9D%E5%A7%8B%E5%80%BC\"><span class=\"toc-text\">引用类型初始值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#delete%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">delete操作符</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-%E5%B8%B8%E6%95%B0\"><span class=\"toc-text\">9.常数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#constant\"><span class=\"toc-text\">constant</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#immutable\"><span class=\"toc-text\">immutable</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-%E6%8E%A7%E5%88%B6%E6%B5%81\"><span class=\"toc-text\">10.控制流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8solidity%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">用solidity实现插入排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">插入排序</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E4%BF%AE%E9%A5%B0%E5%99%A8\"><span class=\"toc-text\">11.构造函数和修饰器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">构造函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E9%A5%B0%E5%99%A8\"><span class=\"toc-text\">修饰器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">12.事件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%84%E5%88%99\"><span class=\"toc-text\">规则</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">13.继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%84%E5%88%99-1\"><span class=\"toc-text\">规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">简单继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">多重继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E9%A5%B0%E5%99%A8%E7%9A%84%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">修饰器的继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">构造函数的继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E7%88%B6%E5%90%88%E7%BA%A6%E7%9A%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">调用父合约的函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-%E6%8A%BD%E8%B1%A1%E5%90%88%E7%BA%A6%E5%92%8C%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">14.抽象合约和接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E5%90%88%E7%BA%A6\"><span class=\"toc-text\">抽象合约</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IERC721%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">IERC721事件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IERC721%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">IERC721函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">什么时候使用接口</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">15.异常</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Error\"><span class=\"toc-text\">Error</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Require\"><span class=\"toc-text\">Require</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Assert\"><span class=\"toc-text\">Assert</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9A%84gas%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">三种方法的gas比较</span></a></li></ol></li></ol></li></ol>","author":{"name":"cocoZ","slug":"cocoz","avatar":"https://s2.loli.net/2022/12/17/7LdKkiUEVc9wQ1x.jpg","link":"/","description":"想越来越优秀！！！<br/>要变得越来越听话！！！ <br/> @ <b·>QQ:1601760796<b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"solidity进阶","uid":"26cdbf141378457625c3c7f264148e8f","slug":"solidity进阶","date":"2022-12-07T15:23:57.000Z","updated":"2022-12-17T12:18:43.276Z","comments":true,"path":"api/articles/solidity进阶.json","keywords":null,"cover":"https://s2.loli.net/2022/12/17/eOYWR2zZ9rqSchP.jpg","text":"solidity进阶16.函数重载重载solidity中允许函数进行重载（overloading），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，solidity不允许修饰器（modifier）重载。 函数重载举个例子，我们可以定义两个都叫saySo...","link":"","photos":[],"count_time":{"symbolsCount":"35k","symbolsTime":"32 mins."},"categories":[],"tags":[{"name":"solidity","slug":"solidity","count":2,"path":"api/tags/solidity.json"}],"author":{"name":"cocoZ","slug":"cocoz","avatar":"https://s2.loli.net/2022/12/17/7LdKkiUEVc9wQ1x.jpg","link":"/","description":"想越来越优秀！！！<br/>要变得越来越听话！！！ <br/> @ <b·>QQ:1601760796<b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"hexo+github搭建个人博客","uid":"4a8c6c67f0d77f1d7a087ca184ac4b68","slug":"hexo-github搭建个人博客","date":"2022-11-21T14:10:57.000Z","updated":"2022-12-17T12:18:27.108Z","comments":true,"path":"api/articles/hexo-github搭建个人博客.json","keywords":null,"cover":"https://s2.loli.net/2022/12/17/6h9QCTbrRjUsx1c.jpg","text":"搭建个人博客（hexo+github）准备工作安装git、安装node.js、还有npm啥的（在看到任务前就装好了的） 在github上创建仓库仓库名字要和用户名一样！！！（github pages等一会儿就出来了） 安装hexo桌面创建一个文件夹，在文件夹目录下打开git ba...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"博客","slug":"博客","count":2,"path":"api/tags/博客.json"}],"author":{"name":"cocoZ","slug":"cocoz","avatar":"https://s2.loli.net/2022/12/17/7LdKkiUEVc9wQ1x.jpg","link":"/","description":"想越来越优秀！！！<br/>要变得越来越听话！！！ <br/> @ <b·>QQ:1601760796<b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}