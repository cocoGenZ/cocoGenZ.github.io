{"title":"solidity入门","uid":"3b889475d55359c53070293a35d903d7","slug":"solidity入门","date":"2022-11-26T16:55:02.000Z","updated":"2022-11-26T17:06:49.334Z","comments":true,"path":"api/articles/solidity入门.json","keywords":null,"cover":[],"content":"<h1 id=\"solidity\">solidity</h1>\r\n<h2 id=\"入门\">1.入门</h2>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT             //这个代码所用的软件许可，如果不写许可，编译时会警告\r\npragma solidity ^0.8.4;             //声明源文件所用的solidity版本\r\ncontract HelloWeb3{             //创建合约（contract），并声明合约名字为Helloweb3\r\n    string public _string = \"Hello Web3!\";      //合约的内容，声明了一个string（字符串）变量_string，并赋值\r\n}</code></pre>\r\n<h2 id=\"数值类型\">2.数值类型</h2>\r\n<h3 id=\"数值类型-1\">数值类型</h3>\r\n<p>1.布尔型：二值变量，取值为** true<strong>或</strong>false**<br>\r\n<code>bool public  _bool = true;</code><br>\r\n布尔值的运算符：！（逻辑非）、&amp;&amp;（逻辑与）、||（逻辑或）、==（等于）、！=（不等于）</p>\r\n<p>2.整型：</p>\r\n<pre class=\"solidity\"><code>int public _int = -1;           //整数，包括负数\r\nuint public _uint = 1;          //正整数\r\nuint256 public _number = 20220330;       //256位正整数\r\nuint public _coco1 =2**4;       //求指数2^4=16\r\nbool public _numberbool = _Uint &gt; _int;     //比大小</code></pre>\r\n<p>3.地址类型：<br>\r\n存储一个20字节的值（以太坊地址的大小）。<br>\r\n地址类型也由成员变量，并作为所有合约的基础。<br>\r\n地址类型分为<strong>普通的地址</strong>和<strong>可以转账ETH的地址（payable）</strong><br>\r\npayable的地址拥有balance和transfer（）两个成员，方便查询ETH余额以及转账。</p>\r\n<pre class=\"solidity\"><code>address public _address =0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;\r\naddress payable public _address1 = payable(_address);       //payable address可以转账、查余额\r\nuint256 public balance = _address1.balance;  //address1的余额</code></pre>\r\n<p>4.定长字节数组：<br>\r\n字节数组bytes分为定长（byte,bytes8，bytes32）和不定长。（定长的属于数值类型，不定长的属于引用类型）<br>\r\n定长byte可以存一些数据，消耗gas比较少</p>\r\n<pre class=\"solidity\"><code>bytes32 public _byte32 = \"Minisolidity\";        //Minisolidity变量以字节的方式存储进变量_byte32，转换成16进制为：0x4d696e69536f6c69646974790000000000000000000000000000000000000000\r\nbytes1 public _byte = _byte32[0];       //_byte变量存储_byte32的第一个字节，为0x4d</code></pre>\r\n<p>Tip：byte是bytes1的别名</p>\r\n<p><img src=\"https://s2.loli.net/2022/11/27/ug9m4Bn8fUsJVx6.png\" alt=\"image-20221027093034801.png\"><br>\r\n（Q:为啥每个元素会浪费31字节？)</p>\r\n<p>5.枚举enum<br>\r\n枚举是solidity中用户定义的数据类型，主要为uint分配名称，使程序易于阅读和维护（参考c语言）</p>\r\n<pre class=\"solidity\"><code>enum ActionSet{Buy,hold,Sell}       //用enum将unit 0， 1， 2表示为Buy, Hold, Sell\r\nActionSet action = ActionSet.Buy;   //创建enum变量action</code></pre>\r\n<p><img src=\"https://s2.loli.net/2022/11/27/G9NCUmEzTJ6I8u1.png\" alt=\"image-20221027205852761.png\"><br>\r\n（Q:这段话有点看不懂，啥叫显式的和uint相互转换？然后检查是怎么检查的？)</p>\r\n<p><img src=\"https://s2.loli.net/2022/11/27/7EGa9uPgVh2Wfck.png\" alt=\"image-20221027210741846.png\"><br>\r\nemmmmm，懂了，我觉得就是数组名称和数组索引的转换，检查是自动会检查的，如果不在长度内会报错</p>\r\n<h2 id=\"函数类型\">3.函数类型</h2>\r\n<h3 id=\"函数\">函数</h3>\r\n<pre class=\"solidity\"><code>    function &lt;function name&gt;(&lt;parameter types&gt;) {internal|external|public|private} [pure|view|payable] [returns (&lt;return types&gt;)]</code></pre>\r\n<pre class=\"solidity\"><code>    function 函数名(输入到函数的变量类型和名字) 函数可见性说明符 决定函数权限/功能的关键字 returns(函数返回的变量类型和名称)</code></pre>\r\n<p>1.<code>function</code>：声明函数的关键字<br>\r\n2.<code>&lt;function name&gt;</code>：函数名<br>\r\n3.<code>(&lt;parameter types&gt;)</code>：函数的参数，变量类型+变量名<br>\r\n4.<code>{internal|external|public|private}</code>：函数可见性说明符，一共4种（没标明函数类型的，默认<code>internal</code>）</p>\r\n<ul>\r\n<li><code>public</code>：内部外部都可见（也可以用于修饰状态变量，public变量会自动生成<code>getter</code>函数，用于查询数据）</li>\r\n<li><code>private</code>：只能从合约内部访问，继承的合约也不能用（也可用于修饰状态变量）</li>\r\n<li><code>external</code>：只能从合约外部访问（但是可以用<code>this.f()</code>来调用，<code>f</code>是函数名）</li>\r\n<li><code>internal</code>：只能从合约内部访问，继承的合约可以用（也可以用于修饰状态变量）<br>\r\n5.<code>[pure|view|payable]</code>：决定函数权限/功能的关键字。（<code>payable</code>运行时可以给合约转入<code>ETH</code>）<br>\r\n6.<code>[returns()]</code>：函数返回的变量类型和名称</li>\r\n</ul>\r\n<p><img src=\"https://s2.loli.net/2022/11/27/JYtKU5oBQ8g7Dmi.png\" alt=\"image-20221027214317445.png\"></p>\r\n<pre class=\"solidity\"><code>eg: function getData() external view returns(uint256) {\r\n         return data;\r\n     } </code></pre>\r\n<h4 id=\"关于pure和view\">关于<code>pure</code>和<code>view</code></h4>\r\n<p>在合约里面定义一个状态变量<code>number=5</code></p>\r\n<pre class=\"solidity\"><code>// SPDX-License-Indentifier:MIT\r\npragma solidity ^0.8.4;\r\ncontract FunctionTypes{\r\nuint256 public number=5;</code></pre>\r\n<p>定义一个<code>add()</code>函数，每次调用，每次给<code>number+1</code></p>\r\n<pre class=\"solidity\"><code>//默认\r\nfunction add() external{\r\nnumber=number+1;\r\n}</code></pre>\r\n<p>如果<code>add()</code>包含了<code>pure</code>关键字，例如<code>function add() pure external</code>，就会报错。<code>pure</code>没有权限读取合约的相关变量，更没有权限改写。<br>\r\n<code>pure</code>函数能干啥捏？(<code>pure</code>：纯纯牛马emmmmm)<br>\r\neg：可以给函数传递一个参数<code>_number</code>，然后让他返回<code>_number+1</code></p>\r\n<pre class=\"solidity\"><code>function addPure(uint256 _number) external pure returns(uint256 new_number){\r\nnew_number=_number+1;\r\n}</code></pre>\r\n<p><img src=\"https://s2.loli.net/2022/11/27/5XEZmvxpYFQkwT6.png\" alt=\"image-20221029154221351.png\"></p>\r\n<p>如图，在_number位置传入一个参数7，就会执行函数，得到输出结果为8</p>\r\n<p>如果<code>add()</code>包含<code>view</code>，比如<code>function add() view external</code>也会报错。因为<code>view</code>能读取，但是不能够改写状态变量。可以稍微改一下，让其不改写<code>number</code>，而是返回一个新的变量。(<code>view</code>：看客)</p>\r\n<pre class=\"solidity\"><code>uint public number=1;\r\nfunction addView() external view returns(uint256 new_number){\r\nnew_number=number+1;\r\n}</code></pre>\r\n<p><img src=\"https://s2.loli.net/2022/11/27/orpfQxRaWBOweEK.png\" alt=\"image-20221029155635711.png\"></p>\r\n<p>点击addView这个函数就会直接读取number=5，直接输出number3=6</p>\r\n<p>（Q:遇到一个问题，就是这样子写报错了，addView函数里面写uint256\r\nnumber=5也会报错，我觉得是因为view只有读取的权限没有写入的权限，是嘛是嘛？？？）</p>\r\n<p><img src=\"https://s2.loli.net/2022/11/27/vbsONroSlc3zBuj.png\" alt=\"image-20221029160053020.png\"></p>\r\n<p><img src=\"https://s2.loli.net/2022/11/27/pbyiCreHQFcklD2.png\" alt=\"image-20221029160113643.png\"></p>\r\n<h5 id=\"为什么引入pure和view关键字\">为什么引入<code>pure</code>和<code>view</code>关键字</h5>\r\n<p><code>solidity</code>引入<code>pure</code>和<code>view</code>关键字主要是为了<strong>节省<code>gas</code></strong>和<strong>控制函数权限</strong>：如果用户直接调用<code>pure/view</code>方程是不消耗<code>gas</code>的（合约中非<code>pure/gas</code>函数调用它们则会改写链上状态，需要付<code>gas</code>）</p>\r\n<h4 id=\"关于internal和external\">关于<code>internal</code>和<code>external</code></h4>\r\n<p>（Q：我自己问出了一个很蠢的问题：怎么区分合约内部和外部）<br>\r\n我思考了一下，还是要回到<code>1入门</code>那边，最开始学习到的创建一个合约</p>\r\n<p><img src=\"https://s2.loli.net/2022/11/27/X9bjnwNItQz2r17.png\" alt=\"image-20221029160952606.png\"></p>\r\n<p>所以我知道怎么区分了（所以我是pure，纯纯牛马一个</p>\r\n<pre class=\"solidity\"><code>//internal:内部\r\nfunction minus() internal{\r\nnumber=number-1;\r\n}\r\n//合约内的函数可以调用内部函数\r\nfunction minusCall() external(){\r\nminus();\r\n}</code></pre>\r\n<p>定义一个<code>internal</code>的<code>minus()</code>函数，每次调用使number-1。由于是<code>internal</code>，只能从合约内部调用，不能从外部。因此，还要再定义一个<code>external</code>的<code>minusCall()</code>函数，来直接调用内部的<code>minus()</code></p>\r\n<p><img src=\"https://s2.loli.net/2022/11/27/ZEn7ga8vf3UoDhk.png\" alt=\"image-20221029162810919.png\"></p>\r\n<p>图片里面只能看到minus222（）看不到minus（）这样子</p>\r\n<p>（Tip：我的理解是<code>internal</code>有像把函数写进合约内部，然后<code>external</code>是写在外部，直接调用即可。)（这样子理解有问题否？？？？？</p>\r\n<h4 id=\"payable\"><code>payable</code></h4>\r\n<pre class=\"solidity\"><code>//payable：递钱，能给合约支付ETH的函数\r\nfunction minusPayable() external payable returns(uint256 balance){\r\nminus();\r\nbalance=address(this).balance;\r\n}</code></pre>\r\n<p>定义一个<code>external payable</code>的<code>minusPayable()</code>函数，间接的调用<code>minus()</code>，并且返回合约里的<code>ETH</code>余额（<code>this</code>关键字可以让我们引用合约地址）<br>\r\n我们可以再调用<code>minusPayable()</code>时，往合约里转入1个<code>ETH</code></p>\r\n<p><img src=\"https://s2.loli.net/2022/11/27/3KLfpd2maTRN61V.png\" alt=\"image-20221029163704630.png\"></p>\r\n<p>是这样的，可以在左下角看到余额balance：1ETH</p>\r\n<p><img src=\"https://s2.loli.net/2022/11/27/Si6m3EUajLcRYnb.png\" alt=\"image-20221029163754954.png\"></p>\r\n<h2 id=\"函数输出return\">4.函数输出return</h2>\r\n<h3 id=\"返回值return和returns\">返回值return和returns</h3>\r\n<p><code>return</code>和<code>returns</code>这两个关键字与函数输出相关。区别在于：</p>\r\n<ul>\r\n<li><code>returns</code>加在函数名后面，用于声明返回的变量类型及变量名；</li>\r\n<li><code>returns</code>用于函数主体中，返回指定的变量。</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>//返回多个变量\r\nfunction returnMultiple() public pure returns(uint256,bool,uint256[3] memory){\r\nreturn(1,true,[uint256(1),2,5]);\r\n}</code></pre>\r\n<p>声明了<code>returnMultiple()</code>函数将有多个输出：<code>returns(uint256,bool,uint256[3] memory)</code>，接着在函数的主体中用<code>return(1,true,[uint256(1),2,5])</code>确定了返回值</p>\r\n<h3 id=\"命名式返回\">命名式返回</h3>\r\n<p>我们可以在<code>returns</code>中\r\n标明返回变量的名称，这样<code>solidity</code>会自动给这些变量初始化，并且自动返回这些函数的值，不需要加<code>return</code></p>\r\n<pre class=\"solidity\"><code>    // 返回多个变量\r\n    function returnMultiple() public pure returns(uint256, bool, uint256[3] memory){\r\n            return(1, true, [uint256(1),2,5]);\r\n        }</code></pre>\r\n<p>改为</p>\r\n<pre class=\"solidity\"><code>    // 命名式返回\r\n    function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){\r\n        _number = 2;\r\n        _bool = false; \r\n        _array = [uint256(3),2,1];\r\n    }</code></pre>\r\n<p>Tip:也可以在命名式返回中用<code>return</code>来返回变量，跟第一种一样</p>\r\n<h3 id=\"解构式赋值\">解构式赋值</h3>\r\n<ul>\r\n<li>读取所有返回值：声明变量，并且将要赋值的变量用<code>,</code>隔开，按顺序排列。</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>        uint256 _number;\r\n        bool _bool;\r\n        uint256[3] memory _array;\r\n        (_number, _bool, _array) = returnNamed();</code></pre>\r\n<ul>\r\n<li>读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。下面这段代码中，我们只读取<code>_bool</code>，而不读取返回的<code>_number</code>和<code>_array</code>：</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>        (, _bool2, ) = returnNamed();</code></pre>\r\n<h2 id=\"变量数据存储和作用域\">5.变量数据存储和作用域</h2>\r\n<h3 id=\"引用类型reference-type\">引用类型(Reference Type)</h3>\r\n<p>数组(<code>array</code>)、结构体(<code>struct</code>)和映射(<code>mapping</code>)，这类变量占空间大，赋值时候直接传递地址（类似指针）。由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明<strong>数据存储的位置</strong>。</p>\r\n<h3 id=\"数据位置\">数据位置</h3>\r\n<p><code>storage</code>、<code>memory</code>和<code>calldata</code>。<br>\r\n不同存储位置的<code>gas</code>成本不同：<br>\r\n<code>storage</code>类型的数据存在链上，类似计算机的硬盘，消耗<code>gas</code>多；<br>\r\n<code>memory</code>和<code>calldata</code>类型的临时存在内存里，消耗<code>gas</code>少。</p>\r\n<ul>\r\n<li><code>storage</code>：合约里的状态变量默认都是<code>storage</code>，存储在链上。</li>\r\n<li><code>memory</code>：函数里的参数和临时变量一般用<code>memory</code>，存储在内存中，不上链。</li>\r\n<li><code>calldata</code>：和<code>memory</code>类似，存储在内存中，不上链。与<code>memory</code>的不同点在于<code>calldata</code>变量不能修改（<code>immutable</code>），一般用于函数的参数。eg：</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function fCalldata(uint[] calldata _x) public pure returns(uint[] calldata){\r\n        //参数为calldata数组，不能被修改\r\n        // _x[0] = 0 //这样修改会报错\r\n        return(_x);\r\n    }</code></pre>\r\n<h4 id=\"赋值规则\">赋值规则</h4>\r\n<p>在不同存储类型相互赋值时候，有时会产生独立的副本（修改新变量不会影响原变量），有时会产生引用（修改新变量会影响原变量）。规则如下：</p>\r\n<ul>\r\n<li><code>storage</code>（合约的状态变量）赋值给本地<code>storage</code>（函数里的）时候，会创建引用，改变新变量会影响原变量。eg：</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    uint[] x = [1,2,3]; // 状态变量：数组 x\r\n\r\n    function fStorage() public{\r\n        //声明一个storage的变量 xStorage，指向x。修改xStorage也会影响x\r\n        uint[] storage xStorage = x;\r\n        xStorage[0] = 100;\r\n    }</code></pre>\r\n<ul>\r\n<li><code>storage</code>赋值给<code>memory</code>，会创建独立的复本，修改其中一个不会影响另一个；反之亦然。</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    uint[] x = [1,2,3]; // 状态变量：数组 x\r\n    \r\n    function fMemory() public view{\r\n        //声明一个Memory的变量xMemory，复制x。修改xMemory不会影响x\r\n        uint[] memory xMemory = x;\r\n        xMemory[0] = 100;\r\n        xMemory[1] = 200;\r\n        uint[] memory xMemory2 = x;\r\n        xMemory2[0] = 300;\r\n    }</code></pre>\r\n<p><code>debug</code>康康</p>\r\n<p><img src=\"https://s2.loli.net/2022/11/27/9vTGVJyf4qu6cXj.png\" alt=\"image-20221124141004557.png\"></p>\r\n<p><img src=\"https://s2.loli.net/2022/11/27/52lLBitGYp6wxCD.png\" alt=\"image-20221124141019609.png\"></p>\r\n<ul>\r\n<li><code>memory</code>赋值给<code>memory</code>，会创建引用，改变新变量会影响原变量</li>\r\n<li>其他情况，变量赋值给<code>storage</code>，会创建独立的复本，修改其中一个不会影响另一个</li>\r\n</ul>\r\n<h3 id=\"作用域\">作用域</h3>\r\n<ul>\r\n<li><p><strong>状态变量</strong><br>\r\n数据存储在链上的变量，所有的合约内的函数都可以访问，<code>gas</code>消耗高。状态变量在<strong>合约内、函数外</strong>声明（可以在函数里更改状态变量的值）</p></li>\r\n<li><p><strong>局部变量</strong><br>\r\n局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，<code>gas</code>低。局部变量在<strong>函数内</strong>声明</p></li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function bar() external pure returns(uint){\r\n        uint xx = 1;\r\n        uint yy = 3;\r\n        uint zz = xx + yy;\r\n        return(zz);\r\n    }</code></pre>\r\n<ul>\r\n<li><strong>全局变量</strong><br>\r\n全局变量是全局范围工作的变量，都是<code>solidity</code>预留关键字（可以在函数内不声明直接使用）</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function global() external view returns(address, uint, bytes memory){\r\n        address sender = msg.sender;\r\n        uint blockNum = block.number;\r\n        bytes memory data = msg.data;\r\n        return(sender, blockNum, data);\r\n    }</code></pre>\r\n<p><img src=\"https://s2.loli.net/2022/11/27/TPm32juO1kWsnpX.png\" alt=\"image-20221124142321645.png\"></p>\r\n<h2 id=\"引用类型\">6.引用类型</h2>\r\n<h3 id=\"数组array\">数组array</h3>\r\n<p>数组（<code>Array</code>）是<code>solidity</code>常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）</p>\r\n<ul>\r\n<li>固定长度数组：在声明时指定数组的长度。用<code>T[k]</code>的格式表明，其中<code>T</code>是元素的类型，<code>k</code>是长度，eg:</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    // 固定长度 Array\r\n    uint[8] array1;\r\n    bytes1[5] array2;\r\n    address[100] array3;</code></pre>\r\n<ul>\r\n<li>可变长度数组（动态数组）：在声明时不指定数值的长度。用<code>T[]</code>的格式表明，其中<code>T</code>是元素的类型（<code>bytes</code>比较特殊，是数组，但是不加<code>[]</code>），eg：</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    // 可变长度 Array\r\n    uint[] array4;\r\n    bytes1[] array5;\r\n    address[] array6;\r\n    bytes array7;</code></pre>\r\n<h3 id=\"创建数组的规则\">创建数组的规则</h3>\r\n<ul>\r\n<li>对于<code>memory</code>修饰的<code>动态数组</code>，可以用<code>new</code>操作符来创建，但是必须声明长度，并且声明后长度不能改变，eg：</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    // memory动态数组\r\n    uint[] memory array8 = new uint[](5);\r\n    bytes memory array9 = new bytes(9);</code></pre>\r\n<ul>\r\n<li>数组字面常数（Array\r\nLiterals）是写作表达形式的数组，用方括号包着来初始化array的一种方式，并且里面每一个元素的type是以<strong>第一个元素</strong>为准的，例如<code>[1,2,3]</code>里面所有的元素都是uint8类型，因为在solidity中如果一个值没有指定type的话，默认就是<strong>最小单位</strong>的该type，这里int的默认最小单位类型就是uint8。而<code>[uint(1),2,3]</code>里面的元素都是uint类型，因为第一个元素指定了是uint类型了，我们都以第一个元素为准。下面的合约中，对于f函数里面的调用，如果我们没有显式对第一个元素进行uint强转的话，是会报错的，因为如上所述我们其实是传入了uint8类型的array，可是g函数需要的却是uint类型的array，就会报错了。</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: GPL-3.0\r\npragma solidity &gt;=0.4.16 &lt;0.9.0;\r\ncontract C {\r\n    function f() public pure {\r\n        g([uint(1), 2, 3]);  //uint(1)强转了。如果是g([1,2,3]),就是uint8类型\r\n    }\r\n    function g(uint[3] memory) public pure {    //g()这边传入的是uint类型\r\n        // ...\r\n    }\r\n}</code></pre>\r\n<ul>\r\n<li>如果创建的是动态数组，你需要一个一个元素的赋值。</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    uint[] memory x = new uint[](3);\r\n    x[0] = 1;\r\n    x[1] = 3;\r\n    x[2] = 4;</code></pre>\r\n<h3 id=\"数组成员\">数组成员</h3>\r\n<p><img src=\"https://s2.loli.net/2022/11/27/hQUVlj2AEvoHDNw.png\" alt=\"image-20221126150559283.png\"></p>\r\n<h3 id=\"结构体\">结构体</h3>\r\n<p>创建结构体</p>\r\n<pre class=\"solidity\"><code>    // 结构体\r\n    struct Student{\r\n        uint256 id;\r\n        uint256 score; \r\n    }</code></pre>\r\n<pre class=\"solidity\"><code>    Student student; // 初始一个student结构体</code></pre>\r\n<p>给结构体赋值的两种方法</p>\r\n<pre class=\"solidity\"><code>    //  给结构体赋值\r\n    // 方法1:在函数中创建一个storage的struct引用\r\n    function initStudent1() external{\r\n        Student storage _student = student; // assign a copy of student\r\n        _student.id = 11;\r\n        _student.score = 100;\r\n    }</code></pre>\r\n<pre class=\"solidity\"><code>     // 方法2:直接引用状态变量的struct\r\n    function initStudent2() external{\r\n        student.id = 1;\r\n        student.score = 80;\r\n    }</code></pre>\r\n<h2 id=\"映射类型\">7.映射类型</h2>\r\n<h3 id=\"mapping\">mapping</h3>\r\n<p>在映射中，人们可以通过键（<code>Key</code>）来查询对应的值（<code>Value</code>），比如：通过一个人的<code>id</code>来查询他的钱包地址。<br>\r\n<code>mapping(_KeyType =&gt; _ValueType)</code>eg:</p>\r\n<pre class=\"solidity\"><code>    mapping(uint =&gt; address) public idToAddress; // id映射到地址\r\n    mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址</code></pre>\r\n<h3 id=\"映射的规则\">映射的规则</h3>\r\n<ul>\r\n<li><strong>规则1</strong>：映射的<code>_KeyType</code>只能选择<code>solidity</code>默认的类型，比如<code>uint</code>，<code>address</code>等，不能用自定义的结构体。而<code>_ValueType</code>可以使用自定义的类型。</li>\r\n<li><strong>规则2</strong>：映射的存储位置必须是<code>storage</code>，因此可以用于合约的状态变量，函数中的<code>storage</code>变量。不能用于<code>public</code>函数的参数或返回结果中，因为<code>mapping</code>记录的是一种关系\r\n(key - value pair)。</li>\r\n<li><strong>规则3</strong>：如果映射声明为<code>public</code>，那么<code>solidity</code>会<strong>自动</strong>给你创建一个<code>getter</code>函数，可以通过<code>Key</code>来查询对应的<code>Value</code>。</li>\r\n<li><strong>规则4</strong>：给映射新增的键值对的语法为<code>_Var[_Key] = _Value</code>，其中<code>_Var</code>是映射变量名，<code>_Key</code>和<code>_Value</code>对应新增的键值对。eg：</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function writeMap (uint _Key, address _Value) public{\r\n        idToAddress[_Key] = _Value;\r\n    }</code></pre>\r\n<h3 id=\"映射的原理\">映射的原理</h3>\r\n<ul>\r\n<li><strong>原理1</strong>：映射不储存任何键（<code>Key</code>）的资讯，也没有length的资讯。</li>\r\n<li><strong>原理2</strong>：映射使用<code>keccak256(key)</code>当成offset存取value。</li>\r\n<li><strong>原理3</strong>：因为Ethereum会定义所有未使用的空间为0，所以未赋值（<code>Value</code>）的键（<code>Key</code>）初始值都是0。</li>\r\n</ul>\r\n<h2 id=\"变量初始值\">8.变量初始值</h2>\r\n<p>声明但没赋值的变量都是有初始值</p>\r\n<h3 id=\"值类型初始值\">值类型初始值</h3>\r\n<ul>\r\n<li><code>boolean</code>:<code>false</code></li>\r\n<li><code>string</code>:<code>\"\"</code></li>\r\n<li><code>int</code>:<code>0</code></li>\r\n<li><code>uint</code>:<code>o</code></li>\r\n<li><code>enum</code>:枚举的第一个元素</li>\r\n<li><code>address</code>:<code>0x0000000000000000000000000000000000000000</code>(或<code>address(0)</code>)</li>\r\n<li><code>function</code>\r\n<ul>\r\n<li><code>internal</code>:空白方程</li>\r\n<li><code>external</code>:空白方程</li>\r\n</ul></li>\r\n</ul>\r\n<p>可以用<code>public</code>变量的<code>getter</code>函数验证初始值：</p>\r\n<pre class=\"solidity\"><code>    bool public _bool;\r\n    ......</code></pre>\r\n<h3 id=\"引用类型初始值\">引用类型初始值</h3>\r\n<ul>\r\n<li>映射<code>mapping</code>：所有元素都为其默认值的<code>mapping</code></li>\r\n<li>结构体<code>struct</code>：所有成员都设为其默认值的结构题</li>\r\n<li>数组<code>array</code>：\r\n<ul>\r\n<li>动态数组：<code>[]</code></li>\r\n<li>静态数组：所有成员设为其默认值的静态数组</li>\r\n</ul></li>\r\n</ul>\r\n<p>验证方式一样，eg：</p>\r\n<pre class=\"solidity\"><code>    mapping(uint =&gt; address) public _mapping; // 所有元素都为其默认值的mapping\r\n    \r\n        // 所有成员设为其默认值的结构体 0, 0\r\n    struct Student{\r\n        uint256 id;\r\n        uint256 score; \r\n    }\r\n    Student public student;</code></pre>\r\n<h3 id=\"delete操作符\"><code>delete</code>操作符</h3>\r\n<p><code>delete a</code>会让变量<code>a</code>的值变为初始值</p>\r\n<h2 id=\"常数\">9.常数</h2>\r\n<p><code>constant</code>（常量）和<code>immutable</code>（不变量）。状态变量声明这个两个关键字之后，不能在合约后更改数值；并且还可以节省<code>gas</code>。<br>\r\n另外，只有数值变量可以声明<code>constant</code>和<code>immutable</code>；<code>string</code>和<code>bytes</code>可以声明为<code>constant</code>，但不能为<code>immutable</code>。</p>\r\n<h3 id=\"constant\">constant</h3>\r\n<p><code>constant</code>变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过。</p>\r\n<pre class=\"solidity\"><code>    // constant变量必须在声明的时候初始化，之后不能改变\r\n    uint256 constant CONSTANT_NUM = 10;\r\n    string constant CONSTANT_STRING = \"0xAA\";\r\n    bytes constant CONSTANT_BYTES = \"WTF\";\r\n    address constant CONSTANT_ADDRESS = 0x0000000000000000000000000000000000000000;</code></pre>\r\n<h3 id=\"immutable\">immutable</h3>\r\n<p><code>immutable</code>变量可以在<strong>声明时</strong>或<strong>构造函数中</strong>初始化，因此更加灵活。</p>\r\n<pre class=\"solidity\"><code>    // immutable变量可以在constructor里初始化，之后不能改变\r\n    uint256 public immutable IMMUTABLE_NUM = 9999999999;\r\n    address public immutable IMMUTABLE_ADDRESS;\r\n    uint256 public immutable IMMUTABLE_BLOCK;\r\n    uint256 public immutable IMMUTABLE_TEST;</code></pre>\r\n<p>可以使用全局变量例如<code>address(this)</code>，<code>block.number</code>\r\n，或者自定义的函数给<code>immutable</code>变量初始化。在下面这个例子，我们利用了<code>test()</code>函数给<code>IMMUTABLE_TEST</code>初始化为<code>9</code>：</p>\r\n<pre class=\"solidity\"><code>    // 利用constructor初始化immutable变量，因此可以利用\r\n    constructor(){\r\n        IMMUTABLE_ADDRESS = address(this);\r\n        IMMUTABLE_BLOCK = block.number;\r\n        IMMUTABLE_TEST = test();\r\n    }\r\n\r\n    function test() public pure returns(uint256){\r\n        uint256 what = 9;\r\n        return(what);\r\n    }</code></pre>\r\n<h2 id=\"控制流\">10.控制流</h2>\r\n<ul>\r\n<li><code>if-else</code></li>\r\n<li><code>for循环</code></li>\r\n<li><code>whie循环</code></li>\r\n<li><code>do-while循环</code></li>\r\n<li><code>三元运算符</code>：三元运算符是<code>solidity</code>中唯一一个接受三个操作数的运算符，规则<code>条件? 条件为真的表达式:条件为假的表达式</code>。\r\n此运算符经常用作 if 语句的快捷方式。</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>// 三元运算符 ternary/conditional operator\r\nfunction ternaryTest(uint256 x, uint256 y) public pure returns(uint256){\r\n    // return the max of x and y\r\n    return x &gt;= y ? x: y; \r\n}</code></pre>\r\n<h3 id=\"用solidity实现插入排序\">用<code>solidity</code>实现插入排序</h3>\r\n<h4 id=\"插入排序\">插入排序</h4>\r\n<p>排序算法解决的问题是将无序的一组数字，例如<code>[2, 5, 3, 1]</code>，从小到大依次排列好。（思路：从前往后，依次将每一个数和排在他前面的数字比大小，如果比前面的数字小，就互换位置。）</p>\r\n<p>贴个<code>python</code>代码</p>\r\n<div class=\"sourceCode\" id=\"cb42\"><pre class=\"sourceCode python\"><code class=\"sourceCode python\"><span id=\"cb42-1\"><a href=\"#cb42-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\"># Python program for implementation of Insertion Sort</span></span>\r\n<span id=\"cb42-2\"><a href=\"#cb42-2\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">def</span> insertionSort(arr):</span>\r\n<span id=\"cb42-3\"><a href=\"#cb42-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">for</span> i <span class=\"kw\">in</span> <span class=\"bu\">range</span>(<span class=\"dv\">1</span>, <span class=\"bu\">len</span>(arr)):</span>\r\n<span id=\"cb42-4\"><a href=\"#cb42-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>        key <span class=\"op\">=</span> arr[i]</span>\r\n<span id=\"cb42-5\"><a href=\"#cb42-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>        j <span class=\"op\">=</span> i<span class=\"op\">-</span><span class=\"dv\">1</span></span>\r\n<span id=\"cb42-6\"><a href=\"#cb42-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>        <span class=\"cf\">while</span> j <span class=\"op\">&gt;=</span><span class=\"dv\">0</span> <span class=\"kw\">and</span> key <span class=\"op\">&lt;</span> arr[j] :</span>\r\n<span id=\"cb42-7\"><a href=\"#cb42-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>                arr[j<span class=\"op\">+</span><span class=\"dv\">1</span>] <span class=\"op\">=</span> arr[j]</span>\r\n<span id=\"cb42-8\"><a href=\"#cb42-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>                j <span class=\"op\">-=</span> <span class=\"dv\">1</span></span>\r\n<span id=\"cb42-9\"><a href=\"#cb42-9\" aria-hidden=\"true\" tabindex=\"-1\"></a>        arr[j<span class=\"op\">+</span><span class=\"dv\">1</span>] <span class=\"op\">=</span> key</span></code></pre></div>\r\n<p>改写成<code>solidity</code>后有BUG！</p>\r\n<pre class=\"solidity\"><code>    // 插入排序 错误版\r\n    function insertionSortWrong(uint[] memory a) public pure returns(uint[] memory) {\r\n        \r\n        for (uint i = 1;i &lt; a.length;i++){\r\n            uint temp = a[i];\r\n            uint j=i-1;\r\n            while( (j &gt;= 0) &amp;&amp; (temp &lt; a[j])){\r\n                a[j+1] = a[j];\r\n                j--;\r\n            }\r\n            a[j+1] = temp;\r\n        }\r\n        return(a);\r\n    }</code></pre>\r\n<p>原因：<code>solidity</code>中最常用的变量类型是<code>uint</code>，也就是正整数，取到负值的话，会报<code>underflow</code>错误。而在插入算法中，变量<code>j</code>有可能会取到<code>-1</code>，引起报错。<br>\r\n这里把<code>j</code>加1，让它无法取到赋值</p>\r\n<pre class=\"solidity\"><code>    // 插入排序 正确版\r\n    function insertionSort(uint[] memory a) public pure returns(uint[] memory) {\r\n        // note that uint can not take negative value\r\n        for (uint i = 1;i &lt; a.length;i++){\r\n            uint temp = a[i];\r\n            uint j=i;\r\n            while( (j &gt;= 1) &amp;&amp; (temp &lt; a[j-1])){\r\n                a[j] = a[j-1];\r\n                j--;\r\n            }\r\n            a[j] = temp;\r\n        }\r\n        return(a);\r\n    }</code></pre>\r\n<h2 id=\"构造函数和修饰器\">11.构造函数和修饰器</h2>\r\n<h3 id=\"构造函数\">构造函数</h3>\r\n<p>构造函数（<code>constructor</code>）是一种特殊的函数，每个合约可以定义一个，并在部署合约的时候自动运行一次。它可以用来初始化合约的一些参数，例如初始化合约的<code>owner</code>地址：</p>\r\n<pre class=\"solidity\"><code>   address owner; // 定义owner变量\r\n\r\n   // 构造函数\r\n   constructor() {\r\n      owner = msg.sender; // 在部署合约的时候，将owner设置为部署者的地址\r\n   }</code></pre>\r\n<p>Tip:构造函数在不同的solidity版本中的语法并不一致，在Solidity\r\n0.4.22之前，构造函数不使用 <code>constructor</code>\r\n而是使用与合约名同名的函数作为构造函数而使用，由于这种旧写法容易使开发者在书写时发生疏漏（例如合约名叫\r\n<code>Parents</code>，构造函数名写成\r\n<code>parents</code>），使得构造函数变成普通函数，引发漏洞，所以0.4.22版本及之后，采用了全新的\r\n<code>constructor</code> 写法。</p>\r\n<pre class=\"solidity\"><code>pragma solidity =0.4.21;\r\ncontract Parents {\r\n    // 与合约名Parents同名的函数就是构造函数\r\n    function Parents () public {\r\n    }\r\n}</code></pre>\r\n<h3 id=\"修饰器\">修饰器</h3>\r\n<p>修饰器（<code>modifier</code>）是<code>solidity</code>特有的语法，类似于面向对象编程中的<code>decorator</code>，声明函数拥有的特性，并减少代码冗余。<br>\r\n<code>modifier</code>的主要使用场景是运行函数前的检查，例如地址，变量，余额等。</p>\r\n<pre class=\"solidity\"><code>   // 定义modifier\r\n   modifier onlyOwner {\r\n      require(msg.sender == owner); // 检查调用者是否为owner地址\r\n      _; // 如果是的话，继续运行函数主体；否则报错并revert交易\r\n   }</code></pre>\r\n<p>带有<code>onlyOwner</code>修饰符的函数只能被<code>owner</code>地址调用，比如下面这个例子：</p>\r\n<pre class=\"solidity\"><code>   function changeOwner(address _newOwner) external onlyOwner{\r\n      owner = _newOwner; // 只有owner地址运行这个函数，并改变owner\r\n   }</code></pre>\r\n<p>我们定义了一个<code>changeOwner</code>函数，运行他可以改变合约的<code>owner</code>，但是由于<code>onlyOwner</code>修饰符的存在，只有原先的<code>owner</code>可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。</p>\r\n<h2 id=\"事件\">12.事件</h2>\r\n<p><code>Solidity</code>中的事件（<code>event</code>）是<code>EVM</code>上日志的抽象，它具有两个特点：</p>\r\n<ul>\r\n<li>应用程序（<a href=\"https://learnblockchain.cn/docs/ethers.js/api-contract.html#id18\"><code>ether.js</code></a>）可以通过<code>RPC</code>接口订阅和监听这些事件，并在前端做响应。</li>\r\n<li>事件是<code>EVM</code>上比较经济的存储数据的方式，每个大概消耗2,000\r\n<code>gas</code>；相比之下，链上存储一个新变量至少需要20,000\r\n<code>gas</code>。</li>\r\n</ul>\r\n<h3 id=\"规则\">规则</h3>\r\n<p>事件的声明由<code>event</code>关键字开头，然后跟事件名称，括号里面写好事件需要记录的变量类型和变量名。以<code>ERC20</code>代币合约的<code>Transfer</code>事件为例：</p>\r\n<pre class=\"solidity\"><code>event Transfer(address indexed from, address indexed to, uint256 value);</code></pre>\r\n<p><code>Transfer</code>事件共记录了3个变量<code>from</code>，<code>to</code>和<code>value</code>，分别对应代币的转账地址，接收地址和转账数量。</p>\r\n<p>同时<code>from</code>和<code>to</code>前面带着<code>indexed</code>关键字，每个<code>indexed</code>标记的变量可以理解为<strong>检索事件的索引“键”</strong>，在以太坊上单独作为一个<code>topic</code>进行存储和索引，程序可以轻松的筛选出特定转账地址和接收地址的转账事件。每个事件<strong>最多</strong>有3个带<code>indexed</code>的变量。每个\r\n<code>indexed</code>\r\n变量的大小为固定的256比特。事件的哈希以及这三个带<code>indexed</code>的变量在<code>EVM</code>日志中通常被存储为<code>topic</code>。其中<code>topic[0]</code>是此事件的<code>keccak256</code>哈希，<code>topic[1]</code>到<code>topic[3]</code>存储了带<code>indexed</code>变量的<code>keccak256</code>哈希。<br>\r\n<img src=\"https://wtf.academy/assets/images/12-3-b08311699b4378c7b077f1cd966b51e2.jpg\"></p>\r\n<p><code>value</code> 不带 <code>indexed</code> 关键字，会存储在事件的\r\n<code>data</code> 部分中，可以理解为事件的“值”。<code>data</code>\r\n部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般\r\n<code>data</code>\r\n部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的\r\n<code>topic</code> 部分中，也是以哈希的方式存储。另外，<code>data</code>\r\n部分的变量在存储上消耗的gas相比于 <code>topic</code> 更少。</p>\r\n<p>可以在函数里释放事件：</p>\r\n<pre class=\"solidity\"><code>    // 定义_transfer函数，执行转账逻辑\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external {\r\n\r\n        _balances[from] = 10000000; // 给转账地址一些初始代币\r\n\r\n        _balances[from] -=  amount; // from地址减去转账数量\r\n        _balances[to] += amount; // to地址加上转账数量\r\n\r\n        // 释放事件\r\n        emit Transfer(from, to, amount);\r\n    }</code></pre>\r\n<h2 id=\"继承\">13.继承</h2>\r\n<h3 id=\"规则-1\">规则</h3>\r\n<ul>\r\n<li><code>virtual</code>:\r\n父合约中的函数，如果希望子合约重写，需要加上<code>virtual</code>关键字。</li>\r\n<li><code>override</code>：子合约重写了父合约中的函数，需要加上<code>override</code>关键字。</li>\r\n</ul>\r\n<h3 id=\"简单继承\">简单继承</h3>\r\n<p>（确实比较简单，直接贴例子）</p>\r\n<p>先写一个简单的爷爷合约<code>Yeye</code>，里面包含1个<code>Log</code>事件和3个<code>function</code>:\r\n<code>hip()</code>, <code>pop()</code>,\r\n<code>yeye()</code>，输出都是”Yeye”。</p>\r\n<pre class=\"solidity\"><code>contract Yeye {\r\n    event Log(string msg);\r\n\r\n    // 定义3个function: hip(), pop(), man()，Log值为Yeye。\r\n    function hip() public virtual{\r\n        emit Log(\"Yeye\");\r\n    }\r\n\r\n    function pop() public virtual{\r\n        emit Log(\"Yeye\");\r\n    }\r\n\r\n    function yeye() public virtual {\r\n        emit Log(\"Yeye\");\r\n    }\r\n}</code></pre>\r\n<p>再定义一个爸爸合约<code>Baba</code>，让他继承<code>Yeye</code>合约，语法就是<code>contract Baba is Yeye</code>，非常直观。在<code>Baba</code>合约里，我们重写一下<code>hip()</code>和<code>pop()</code>这两个函数，加上<code>override</code>关键字，并将他们的输出改为<code>”Baba”</code>；并且加一个新的函数<code>baba</code>，输出也是<code>”Baba”</code>。</p>\r\n<pre class=\"solidity\"><code>contract Baba is Yeye{\r\n    // 继承两个function: hip()和pop()，输出改为Baba。\r\n    function hip() public virtual override{\r\n        emit Log(\"Baba\");\r\n    }\r\n\r\n    function pop() public virtual override{\r\n        emit Log(\"Baba\");\r\n    }\r\n\r\n    function baba() public virtual{\r\n        emit Log(\"Baba\");\r\n    }\r\n}</code></pre>\r\n<p>部署合约，可以看到<code>Baba</code>合约里有4个函数，其中<code>hip()</code>和<code>pop()</code>的输出被成功改写成<code>”Baba”</code>，而继承来的<code>yeye()</code>的输出仍然是<code>”Yeye”</code>。</p>\r\n<h3 id=\"多重继承\">多重继承</h3>\r\n<p><code>solidity</code>合约可以继承多个合约</p>\r\n<p>继承时要按辈分<strong>最高到最低</strong>的顺序排。比如我们写一个<code>Erzi</code>合约，继承<code>Yeye</code>合约和<code>Baba</code>合约，那么就要写成<code>contract Erzi is Yeye, Baba</code>，而不能写成<code>contract Erzi is Baba, Yeye</code>，不然就会报错。\r\n如果某一个函数在多个继承的合约里都存在，比如例子中的<code>hip()</code>和<code>pop()</code>，在子合约里必须重写，不然会报错。\r\n重写在多个父合约中都<strong>重名</strong>的函数时，<code>override</code>关键字后面要加上<strong>所有</strong>父合约名字，例如<code>override(Yeye, Baba)</code>。\r\n例子：</p>\r\n<pre class=\"solidity\"><code>contract Erzi is Yeye, Baba{\r\n    // 继承两个function: hip()和pop()，输出值为Erzi。\r\n    function hip() public virtual override(Yeye, Baba){\r\n        emit Log(\"Erzi\");\r\n    }\r\n\r\n    function pop() public virtual override(Yeye, Baba) {\r\n        emit Log(\"Erzi\");\r\n    }</code></pre>\r\n<h3 id=\"修饰器的继承\">修饰器的继承</h3>\r\n<p><code>Solidity</code>中的修饰器（<code>Modifier</code>）同样可以继承，用法与函数继承类似，在相应的地方加<code>virtual</code>和<code>override</code>关键字即可。</p>\r\n<pre class=\"solidity\"><code>contract Base1 {\r\n    modifier exactDividedBy2And3(uint _a) virtual {\r\n        require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Identifier is Base1 {\r\n\r\n    //计算一个数分别被2除和被3除的值，但是传入的参数必须是2和3的倍数\r\n    function getExactDividedBy2And3(uint _dividend) public exactDividedBy2And3(_dividend) pure returns(uint, uint) {\r\n        return getExactDividedBy2And3WithoutModifier(_dividend);\r\n    }\r\n\r\n    //计算一个数分别被2除和被3除的值\r\n    function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returns(uint, uint){\r\n        uint div2 = _dividend / 2;\r\n        uint div3 = _dividend / 3;\r\n        return (div2, div3);\r\n    }\r\n}</code></pre>\r\n<p><code>Identifier</code>合约可以直接在代码中使用父合约中的<code>exactDividedBy2And3</code>修饰器，也可以利用<code>override</code>关键字重写修饰器：</p>\r\n<pre class=\"solidity\"><code>    modifier exactDividedBy2And3(uint _a) override {\r\n        _;\r\n        require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);\r\n    }</code></pre>\r\n<h3 id=\"构造函数的继承\">构造函数的继承</h3>\r\n<p>子合约有两种方法继承父合约的构造函数。举个简单的例子，父合约A里面有一个状态变量a，并由构造函数的参数来确定：</p>\r\n<pre class=\"solidity\"><code>// 构造函数的继承\r\nabstract contract A {\r\n    uint public a;\r\n\r\n    constructor(uint _a) {\r\n        a = _a;\r\n    }\r\n}</code></pre>\r\n<p>1.在继承时声明父构造函数的参数，例如：<code>contract B is A(1)</code><br>\r\n2.在子合约的构造函数中声明构造函数的参数，例如：</p>\r\n<pre class=\"solidity\"><code>contract C is A {\r\n    constructor(uint _c) A(_c * _c) {}\r\n}</code></pre>\r\n<h3 id=\"调用父合约的函数\">调用父合约的函数</h3>\r\n<p>子合约有两种调用父合约的函数</p>\r\n<ul>\r\n<li>直接调用：子合约可以直接用<code>父合约名.函数名()</code>的方式来调用父合约函数，例如<code>Yeye.pop()</code>。</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function callParent() public{\r\n        Yeye.pop();\r\n    }</code></pre>\r\n<ul>\r\n<li><code>super</code>关键字：子合约可以利用<code>super.函数名()</code>来调用最近的父合约函数。<code>solidity</code>继承关系按声明时<strong>从右到左</strong>的顺序是：<code>contract Erzi is Yeye, Baba</code>，那么<code>Baba</code>是最近的父合约，<code>super.pop()</code>将调用<code>Baba.pop()</code>而不是<code>Yeye.pop()</code>：</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function callParentSuper() public{\r\n        // 将调用最近的父合约函数，Baba.pop()\r\n        super.pop();\r\n    }</code></pre>\r\n<h2 id=\"抽象合约和接口\">14.抽象合约和接口</h2>\r\n<h3 id=\"抽象合约\">抽象合约</h3>\r\n<p>如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体<code>{}</code>中的内容，则必须将该合约标为<code>abstract</code>，不然编译会报错；另外，未实现的函数需要加<code>virtual</code>，以便子合约重写。拿我们之前的<code>插入排序合约</code>为例，如果我们还没想好具体怎么实现插入排序函数，那么可以把合约标为<code>abstract</code>，之后让别人补写上。</p>\r\n<pre class=\"solidity\"><code>abstract contract InsertionSort{\r\n    function insertionSort(uint[] memory a) public pure virtual returns(uint[] memory);\r\n}</code></pre>\r\n<h3 id=\"接口\">接口</h3>\r\n<p>接口类似于抽象合约，但不实现任何功能。<br>\r\n规则：</p>\r\n<ul>\r\n<li>不能包含状态变量</li>\r\n<li>不能包含构造函数</li>\r\n<li>不能继承除接口外的其他合约</li>\r\n<li>所有函数都必须是<code>external</code>且不能有函数体</li>\r\n<li>继承接口的合约必须实现接口定义的所有功能</li>\r\n</ul>\r\n<p>虽然接口不实现任何功能，但它非常重要。接口是智能合约的骨架，定义了合约的功能以及如何触发它们：如果智能合约实现了某种接口（比如<code>ERC20</code>或<code>ERC721</code>），其他Dapps和智能合约就知道如何与它交互。因为接口提供了两个重要的信息：<br>\r\n1.合约里每个函数的bytes4选择器，以及基于它们的函数签名函数名(每个参数类型）。<br>\r\n2.接口id（更多信息见<a href=\"https://eips.ethereum.org/EIPS/eip-165\">EIP165</a>）</p>\r\n<p>另外，接口与合约<code>ABI</code>（Application Binary\r\nInterface）等价，可以相互转换：编译接口可以得到合约的<code>ABI</code>，利用<a href=\"https://gnidan.github.io/abi-to-sol/\">abi-to-sol工具</a>也可以将<code>ABI json</code>文件转换为<code>接口sol</code>文件。</p>\r\n<p>我们以<code>ERC721</code>接口合约<code>IERC721</code>为例，它定义了3个<code>event</code>和9个<code>function</code>，所有<code>ERC721</code>标准的NFT都实现了这些函数。我们可以看到，接口和常规合约的区别在于每个函数都以<code>;</code>代替函数体<code>{ }</code>结尾。</p>\r\n<pre class=\"solidity\"><code>interface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    \r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}</code></pre>\r\n<h3 id=\"ierc721事件\">IERC721事件</h3>\r\n<p><code>IERC721</code>包含3个事件，其中<code>Transfer</code>和<code>Approval</code>事件在<code>ERC20</code>中也有。</p>\r\n<ul>\r\n<li><code>Transfer</code>事件：在转账时被释放，记录代币的发出地址<code>from</code>，接收地址<code>to</code>和<code>tokenid</code>。</li>\r\n<li><code>Approval</code>事件：在授权时释放，记录授权地址<code>owner</code>，被授权地址<code>approved</code>和<code>tokenid</code>。</li>\r\n<li><code>ApprovalForAll</code>事件：在批量授权时释放，记录批量授权的发出地址<code>owner</code>，被授权地址<code>operator</code>和授权与否的<code>approved</code>。</li>\r\n</ul>\r\n<h3 id=\"ierc721函数\">IERC721函数</h3>\r\n<ul>\r\n<li><code>balanceOf</code>：返回某地址的NFT持有量<code>balance</code>。</li>\r\n<li><code>ownerOf</code>：返回某<code>tokenId</code>的主人<code>owner</code>。</li>\r\n<li><code>transferFrom</code>：普通转账，参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li>\r\n<li><code>safeTransferFrom</code>：安全转账（如果接收方是合约地址，会要求实现<code>ERC721Receiver</code>接口）。参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li>\r\n<li><code>approve</code>：授权另一个地址使用你的NFT。参数为被授权地址<code>approve</code>和<code>tokenId</code>。</li>\r\n<li><code>getApproved</code>：查询<code>tokenId</code>被批准给了哪个地址。</li>\r\n<li><code>setApprovalForAll</code>：将自己持有的该系列NFT批量授权给某个地址<code>operator</code>。</li>\r\n<li><code>isApprovedForAll</code>：查询某地址的NFT是否批量授权给了另一个<code>operator</code>地址。</li>\r\n<li><code>safeTransferFrom</code>：安全转账的重载函数，参数里面包含了<code>data</code>。</li>\r\n</ul>\r\n<h3 id=\"什么时候使用接口\">什么时候使用接口</h3>\r\n<p>如果我们知道一个合约实现了<code>IERC721</code>接口，我们不需要知道它具体代码实现，就可以与它交互。</p>\r\n<p>无聊猿<code>BAYC</code>属于<code>ERC721</code>代币，实现了<code>IERC721</code>接口的功能。我们不需要知道它的源代码，只需知道它的合约地址，用<code>IERC721</code>接口就可以与它交互，比如用<code>balanceOf()</code>来查询某个地址的<code>BAYC</code>余额，用<code>safeTransferFrom()</code>来转账<code>BAYC</code>。</p>\r\n<pre class=\"solidity\"><code>contract interactBAYC {\r\n    // 利用BAYC地址创建接口合约变量（ETH主网）\r\n    IERC721 BAYC = IERC721(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D);\r\n\r\n    // 通过接口调用BAYC的balanceOf()查询持仓量\r\n    function balanceOfBAYC(address owner) external view returns (uint256 balance){\r\n        return BAYC.balanceOf(owner);\r\n    }\r\n\r\n    // 通过接口调用BAYC的safeTransferFrom()安全转账\r\n    function safeTransferFromBAYC(address from, address to, uint256 tokenId) external{\r\n        BAYC.safeTransferFrom(from, to, tokenId);\r\n    }\r\n}</code></pre>\r\n<h2 id=\"异常\">15.异常</h2>\r\n<p>写智能合约经常会出<code>bug</code>，<code>solidity</code>中的异常命令帮助我们<code>debug</code>。</p>\r\n<h3 id=\"error\">Error</h3>\r\n<p><code>error</code>是<code>solidity 0.8版本</code>新加的内容，方便且高效（省<code>gas</code>）地向用户解释操作失败的原因。人们可以在<code>contract</code>之外定义异常。下面，我们定义一个<code>TransferNotOwner</code>异常，当用户不是代币<code>owner</code>的时候尝试转账，会抛出错误：</p>\r\n<pre class=\"solidity\"><code>error TransferNotOwner(); // 自定义error</code></pre>\r\n<p>在执行当中，<code>error</code>必须搭配<code>revert</code>（回退）命令使用。</p>\r\n<pre class=\"solidity\"><code>    function transferOwner1(uint256 tokenId, address newOwner) public {\r\n        if(_owners[tokenId] != msg.sender){\r\n            revert TransferNotOwner();\r\n        }\r\n        _owners[tokenId] = newOwner;\r\n    }</code></pre>\r\n<p>我们定义了一个<code>transferOwner1()</code>函数，它会检查代币的<code>owner</code>是不是发起人，如果不是，就会抛出<code>TransferNotOwner</code>异常；如果是的话，就会转账。</p>\r\n<h3 id=\"require\">Require</h3>\r\n<p><code>require</code>命令是<code>solidity 0.8版本</code>之前抛出异常的常用方法，目前很多主流合约仍然还在使用它。它很好用，唯一的缺点就是<code>gas</code>随着描述异常的字符串长度增加，比<code>error</code>命令要高。使用方法：<code>require(检查条件，\"异常的描述\")</code>，当检查条件不成立的时候，就会抛出异常。</p>\r\n<p>我们用<code>require</code>命令重写一下上面的<code>transferOwner</code>函数：</p>\r\n<pre class=\"solidity\"><code>    function transferOwner2(uint256 tokenId, address newOwner) public {\r\n        require(_owners[tokenId] == msg.sender, \"Transfer Not Owner\");\r\n        _owners[tokenId] = newOwner;\r\n    }</code></pre>\r\n<p>贴个在remix上验证的例子吧<br>\r\n1.输入任意<code>uint256</code>数字和非0地址，调用<code>transferOwner1</code>，也就是<code>error</code>方法，控制台抛出了异常并显示我们自定义的<code>TransferNotOwner</code>。<br>\r\n<img src=\"https://wtf.academy/assets/images/15-1-108068d779547bb5f2bbe63c4e350fab.png\"><br>\r\n2.输入任意<code>uint256</code>数字和非0地址，调用<code>transferOwner2</code>，也就是<code>require</code>方法，控制台抛出了异常并打印出<code>require</code>中的字符串。<br>\r\n<img src=\"https://wtf.academy/assets/images/15-2-5cd86c90ad4a466946c842c346a5ee18.png\"><br>\r\n3.输入任意<code>uint256</code>数字和非0地址，调用<code>transferOwner3</code>，也就是<code>assert</code>方法，控制台只抛出了异常。<br>\r\n<img src=\"https://wtf.academy/assets/images/15-3-390b3562e3410dd9f6256b66e8d2610f.png\"></p>\r\n<h3 id=\"assert\">Assert</h3>\r\n<p><code>assert</code>命令一般用于程序员写程序<code>debug</code>，因为它不能解释抛出异常的原因（比<code>require</code>少个字符串）。它的用法很简单，<code>assert(检查条件）</code>，当检查条件不成立的时候，就会抛出异常。</p>\r\n<p>我们用<code>assert</code>命令重写一下上面的<code>transferOwner</code>函数：</p>\r\n<pre class=\"solidity\"><code>    function transferOwner3(uint256 tokenId, address newOwner) public {\r\n        assert(_owners[tokenId] == msg.sender);\r\n        _owners[tokenId] = newOwner;\r\n    }</code></pre>\r\n<h3 id=\"三种方法的gas比较\">三种方法的<code>gas</code>比较</h3>\r\n<p>我们比较一下三种抛出异常的<code>gas</code>消耗，通过remix控制台的Debug按钮，能查到每次函数调用的<code>gas</code>消耗分别如下：</p>\r\n<ol type=\"1\">\r\n<li><strong><code>error</code>方法<code>gas</code>消耗</strong>：24445</li>\r\n<li><strong><code>require</code>方法<code>gas</code>消耗</strong>：24743</li>\r\n<li><strong><code>assert</code>方法<code>gas</code>消耗</strong>：24446</li>\r\n</ol>\r\n<p>我们可以看到，<code>error</code>方法<code>gas</code>最少，其次是<code>assert</code>，<code>require</code>方法消耗<code>gas</code>最多！因此，<code>error</code>既可以告知用户抛出异常的原因，又能省<code>gas</code>，大家要多用！（注意，由于部署测试时间的不同，每个函数的<code>gas</code>消耗会有所不同，但是比较结果会是一致的。）</p>\r\n","feature":true,"text":"solidity 1.入门 // SPDX-License-Identifier: MIT //这个代码所用的软件许可，如果不写许可，编译时会警告 pragma solidity ^0.8.4; //声明源文件所用的solidity版本 contract HelloWeb3{ /...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[],"tags":[{"name":"solidity","slug":"solidity","count":2,"path":"api/tags/solidity.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#solidity\"><span class=\"toc-text\">solidity</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">1.入门</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2.数值类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B-1\"><span class=\"toc-text\">数值类型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">3.函数类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8Epure%E5%92%8Cview\"><span class=\"toc-text\">关于pure和view</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5pure%E5%92%8Cview%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">为什么引入pure和view关键字</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8Einternal%E5%92%8Cexternal\"><span class=\"toc-text\">关于internal和external</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#payable\"><span class=\"toc-text\">payable</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BAreturn\"><span class=\"toc-text\">4.函数输出return</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%80%BCreturn%E5%92%8Creturns\"><span class=\"toc-text\">返回值return和returns</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%91%BD%E5%90%8D%E5%BC%8F%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">命名式返回</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%9E%84%E5%BC%8F%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">解构式赋值</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">5.变量数据存储和作用域</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8Breference-type\"><span class=\"toc-text\">引用类型(Reference Type)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">数据位置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B5%8B%E5%80%BC%E8%A7%84%E5%88%99\"><span class=\"toc-text\">赋值规则</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">作用域</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">6.引用类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84array\"><span class=\"toc-text\">数组array</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%84%E5%88%99\"><span class=\"toc-text\">创建数组的规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E6%88%90%E5%91%98\"><span class=\"toc-text\">数组成员</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">结构体</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">7.映射类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mapping\"><span class=\"toc-text\">mapping</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%A0%E5%B0%84%E7%9A%84%E8%A7%84%E5%88%99\"><span class=\"toc-text\">映射的规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%A0%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">映射的原理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%80%BC\"><span class=\"toc-text\">8.变量初始值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%88%9D%E5%A7%8B%E5%80%BC\"><span class=\"toc-text\">值类型初始值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%9D%E5%A7%8B%E5%80%BC\"><span class=\"toc-text\">引用类型初始值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#delete%E6%93%8D%E4%BD%9C%E7%AC%A6\"><span class=\"toc-text\">delete操作符</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E6%95%B0\"><span class=\"toc-text\">9.常数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#constant\"><span class=\"toc-text\">constant</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#immutable\"><span class=\"toc-text\">immutable</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A7%E5%88%B6%E6%B5%81\"><span class=\"toc-text\">10.控制流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8solidity%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">用solidity实现插入排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">插入排序</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E4%BF%AE%E9%A5%B0%E5%99%A8\"><span class=\"toc-text\">11.构造函数和修饰器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">构造函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E9%A5%B0%E5%99%A8\"><span class=\"toc-text\">修饰器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">12.事件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%84%E5%88%99\"><span class=\"toc-text\">规则</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">13.继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%84%E5%88%99-1\"><span class=\"toc-text\">规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">简单继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">多重继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E9%A5%B0%E5%99%A8%E7%9A%84%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">修饰器的继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">构造函数的继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E7%88%B6%E5%90%88%E7%BA%A6%E7%9A%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">调用父合约的函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E5%90%88%E7%BA%A6%E5%92%8C%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">14.抽象合约和接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E5%90%88%E7%BA%A6\"><span class=\"toc-text\">抽象合约</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ierc721%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">IERC721事件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ierc721%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">IERC721函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">什么时候使用接口</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">15.异常</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#error\"><span class=\"toc-text\">Error</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#require\"><span class=\"toc-text\">Require</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#assert\"><span class=\"toc-text\">Assert</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9A%84gas%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">三种方法的gas比较</span></a></li></ol></li></ol></li></ol>","author":{"name":"cocoZ","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"想永远活在17岁！！！想越来越优秀！！！过去的遗憾现在弥补！！！ <br/> @ <b>QQ:1601760796<b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"solidity进阶","uid":"26cdbf141378457625c3c7f264148e8f","slug":"solidity进阶","date":"2022-12-07T15:23:57.000Z","updated":"2022-12-07T15:25:33.484Z","comments":true,"path":"api/articles/solidity进阶.json","keywords":null,"cover":[],"text":"solidity进阶 16.函数重载 重载 solidity中允许函数进行重载（overloading），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，solidity不允许修饰器（modifier）重载。 函数重载 举个例子，我们可以定义两个都叫s...","link":"","photos":[],"count_time":{"symbolsCount":"37k","symbolsTime":"34 mins."},"categories":[],"tags":[{"name":"solidity","slug":"solidity","count":2,"path":"api/tags/solidity.json"}],"author":{"name":"cocoZ","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"想永远活在17岁！！！想越来越优秀！！！过去的遗憾现在弥补！！！ <br/> @ <b>QQ:1601760796<b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"hexo+github搭建个人博客","uid":"4a8c6c67f0d77f1d7a087ca184ac4b68","slug":"hexo-github搭建个人博客","date":"2022-11-21T14:10:57.000Z","updated":"2022-11-26T06:40:25.224Z","comments":true,"path":"api/articles/hexo-github搭建个人博客.json","keywords":null,"cover":[],"text":"搭建个人博客（hexo+github） 准备工作 安装git、安装node.js、还有npm啥的（在看到任务前就装好了的） ## 在github上创建仓库 仓库名字要和用户名一样！！！ （github pages等一会儿就出来了） 安装hexo 桌面创建一个文件夹，在文件夹目录下...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"博客","slug":"博客","count":1,"path":"api/tags/博客.json"}],"author":{"name":"cocoZ","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"想永远活在17岁！！！想越来越优秀！！！过去的遗憾现在弥补！！！ <br/> @ <b>QQ:1601760796<b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}