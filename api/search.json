[{"id":"3b889475d55359c53070293a35d903d7","title":"solidity入门","content":"# solidity\n# 1. 入门\n// SPDX-License-Identifier: MIT\t\t\t\t// 这个代码所用的软件许可，如果不写许可，编译时会警告pragma solidity ^0.8.4;\t\t\t\t// 声明源文件所用的 solidity 版本contract HelloWeb3{\t\t\t\t// 创建合约（contract），并声明合约名字为 Helloweb3    string public _string = \"Hello Web3!\";\t\t// 合约的内容，声明了一个 string（字符串）变量_string，并赋值}# 2. 数值类型\n# 数值类型\n1. 布尔型：二值变量，取值为 ** true 或 false**\n bool public  _bool = true; \n 布尔值的运算符：！（逻辑非）、&amp;&amp;（逻辑与）、||（逻辑或）、==（等于）、！=（不等于）\n2. 整型：\nint public _int = -1;\t\t\t// 整数，包括负数uint public _uint = 1;\t\t\t// 正整数uint256 public _number = 20220330;\t\t //256 位正整数uint public _coco1 =2**4;\t\t// 求指数 2^4=16bool public _numberbool = _Uint &gt; _int;\t\t// 比大小3. 地址类型：\n存储一个 20 字节的值（以太坊地址的大小）。\n地址类型也由成员变量，并作为所有合约的基础。\n地址类型分为普通的地址和可以转账 ETH 的地址（payable）\npayable 的地址拥有 balance 和 transfer（）两个成员，方便查询 ETH 余额以及转账。\naddress public _address =0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;address payable public _address1 = payable(_address);\t\t//payable address 可以转账、查余额uint256 public balance = _address1.balance;  //address1 的余额4. 定长字节数组：\n字节数组 bytes 分为定长（byte,bytes8，bytes32）和不定长。（定长的属于数值类型，不定长的属于引用类型）\n定长 byte 可以存一些数据，消耗 gas 比较少\nbytes32 public _byte32 = \"Minisolidity\";\t\t//Minisolidity 变量以字节的方式存储进变量_byte32，转换成 16 进制为：0x4d696e69536f6c69646974790000000000000000000000000000000000000000bytes1 public _byte = _byte32[0];\t\t//_byte 变量存储_byte32 的第一个字节，为 0x4dTip：byte 是 bytes1 的别名\n\n（Q: 为啥每个元素会浪费 31 字节？)\n5. 枚举 enum\n 枚举是 solidity 中用户定义的数据类型，主要为 uint 分配名称，使程序易于阅读和维护（参考 c 语言）\nenum ActionSet{Buy,hold,Sell}\t\t// 用 enum 将 unit 0， 1， 2 表示为 Buy, Hold, SellActionSet action = ActionSet.Buy;\t// 创建 enum 变量 action\n（Q: 这段话有点看不懂，啥叫显式的和 uint 相互转换？然后检查是怎么检查的？)\n\nemmmmm，懂了，我觉得就是数组名称和数组索引的转换，检查是自动会检查的，如果不在长度内会报错\n# 3. 函数类型\n# 函数\nfunction &lt;function name&gt;(&lt;parameter types&gt;) {internal|external|public|private} [pure|view|payable] [returns (&lt;return types&gt;)]function 函数名(输入到函数的变量类型和名字) 函数可见性说明符 决定函数权限/功能的关键字 returns(函数返回的变量类型和名称)1. function ：声明函数的关键字\n 2. &lt;function name&gt; ：函数名\n 3. (&lt;parameter types&gt;) ：函数的参数，变量类型 + 变量名\n 4. {internal|external|public|private} ：函数可见性说明符，一共 4 种（没标明函数类型的，默认 internal ）\n\npublic ：内部外部都可见（也可以用于修饰状态变量，public 变量会自动生成 getter  函数，用于查询数据）\nprivate ：只能从合约内部访问，继承的合约也不能用（也可用于修饰状态变量）\nexternal ：只能从合约外部访问（但是可以用 this.f()  来调用， f  是函数名）\ninternal ：只能从合约内部访问，继承的合约可以用（也可以用于修饰状态变量）\n5. [pure|view|payable] ：决定函数权限 / 功能的关键字。（ payable  运行时可以给合约转入 ETH ）\n6. [returns()] ：函数返回的变量类型和名称\n\n\neg: function getData() external view returns(uint256) {         return data;     }# 关于 pure  和 view\n在合约里面定义一个状态变量 number=5\n// SPDX-License-Indentifier:MITpragma solidity ^0.8.4;contract FunctionTypes{uint256 public number=5;定义一个 add()  函数，每次调用，每次给 number+1\n// 默认function add() external{number=number+1;}如果 add()  包含了 pure  关键字，例如 function add() pure external ，就会报错。 pure  没有权限读取合约的相关变量，更没有权限改写。\n pure  函数能干啥捏？( pure ：纯纯牛马 emmmmm)\n eg：可以给函数传递一个参数 _number ，然后让他返回 _number+1\nfunction addPure(uint256 _number) external pure returns(uint256 new_number){new_number=_number+1;}\n如图，在_number 位置传入一个参数 7，就会执行函数，得到输出结果为 8\n如果 add()  包含 view ，比如 function add() view external  也会报错。因为 view  能读取，但是不能够改写状态变量。可以稍微改一下，让其不改写 number ，而是返回一个新的变量。( view ：看客)\nuint public number=1;function addView() external view returns(uint256 new_number){new_number=number+1;}\n点击 addView 这个函数就会直接读取 number=5，直接输出 number3=6\n（Q: 遇到一个问题，就是这样子写报错了，addView 函数里面写 uint256 number=5 也会报错，我觉得是因为 view 只有读取的权限没有写入的权限，是嘛是嘛？？？）\n\n\n# 为什么引入 pure  和 view  关键字\nsolidity  引入 pure  和 view  关键字主要是为了节省 gas  和控制函数权限：如果用户直接调用 pure/view  方程是不消耗 gas  的（合约中非 pure/gas  函数调用它们则会改写链上状态，需要付 gas ）\n# 关于 internal  和 external\n（Q：我自己问出了一个很蠢的问题：怎么区分合约内部和外部）\n我思考了一下，还是要回到 1入门 那边，最开始学习到的创建一个合约\n\n所以我知道怎么区分了（所以我是 pure，纯纯牛马一个\n//internal: 内部function minus() internal{number=number-1;}// 合约内的函数可以调用内部函数function minusCall() external(){minus();}定义一个 internal  的 minus()  函数，每次调用使 number-1。由于是 internal ，只能从合约内部调用，不能从外部。因此，还要再定义一个 external  的 minusCall()  函数，来直接调用内部的 minus()\n\n图片里面只能看到 minus222（）看不到 minus（）这样子\n（Tip：我的理解是 internal  有像把函数写进合约内部，然后 external  是写在外部，直接调用即可。)（这样子理解有问题否？？？？？\n#  payable\n//payable：递钱，能给合约支付 ETH 的函数function minusPayable() external payable returns(uint256 balance){minus();balance=address(this).balance;}定义一个 external payable  的 minusPayable()  函数，间接的调用 minus() ，并且返回合约里的 ETH  余额（ this  关键字可以让我们引用合约地址）\n我们可以再调用 minusPayable()  时，往合约里转入 1 个 ETH\n\n是这样的，可以在左下角看到余额 balance：1ETH\n\n# 4. 函数输出 return\n# 返回值 return 和 returns\nreturn  和 returns  这两个关键字与函数输出相关。区别在于：\n\nreturns  加在函数名后面，用于声明返回的变量类型及变量名；\nreturns  用于函数主体中，返回指定的变量。\n\n// 返回多个变量function returnMultiple() public pure returns(uint256,bool,uint256[3] memory){return(1,true,[uint256(1),2,5]);}声明了 returnMultiple()  函数将有多个输出： returns(uint256,bool,uint256[3] memory) ，接着在函数的主体中用 return(1,true,[uint256(1),2,5])  确定了返回值\n# 命名式返回\n我们可以在 returns  中 标明返回变量的名称，这样 solidity  会自动给这些变量初始化，并且自动返回这些函数的值，不需要加 return\n// 返回多个变量    function returnMultiple() public pure returns(uint256, bool, uint256[3] memory){            return(1, true, [uint256(1),2,5]);        }改为\n// 命名式返回    function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){        _number = 2;        _bool = false;         _array = [uint256(3),2,1];    }Tip: 也可以在命名式返回中用 return  来返回变量，跟第一种一样\n# 解构式赋值\n\n读取所有返回值：声明变量，并且将要赋值的变量用 ,  隔开，按顺序排列。\n\nuint256 _number;        bool _bool;        uint256[3] memory _array;        (_number, _bool, _array) = returnNamed();\n读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。下面这段代码中，我们只读取 _bool ，而不读取返回的 _number  和 _array ：\n\n(, _bool2, ) = returnNamed();# 5. 变量数据存储和作用域\n# 引用类型 (Reference Type)\n数组 ( array )、结构体 ( struct ) 和映射 ( mapping )，这类变量占空间大，赋值时候直接传递地址（类似指针）。由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明数据存储的位置。\n# 数据位置\nstorage 、 memory  和 calldata 。\n不同存储位置的 gas  成本不同：\n storage  类型的数据存在链上，类似计算机的硬盘，消耗 gas  多；\n memory  和 calldata  类型的临时存在内存里，消耗 gas  少。\n\nstorage ：合约里的状态变量默认都是 storage ，存储在链上。\nmemory ：函数里的参数和临时变量一般用 memory ，存储在内存中，不上链。\ncalldata ：和 memory  类似，存储在内存中，不上链。与 memory  的不同点在于 calldata  变量不能修改（ immutable ），一般用于函数的参数。eg：\n\nfunction fCalldata(uint[] calldata _x) public pure returns(uint[] calldata){        // 参数为 calldata 数组，不能被修改        //_x [0] = 0 // 这样修改会报错        return(_x);    }# 赋值规则\n在不同存储类型相互赋值时候，有时会产生独立的副本（修改新变量不会影响原变量），有时会产生引用（修改新变量会影响原变量）。规则如下：\n\nstorage （合约的状态变量）赋值给本地 storage （函数里的）时候，会创建引用，改变新变量会影响原变量。eg：\n\nuint[] x = [1,2,3]; // 状态变量：数组 x    function fStorage() public{        // 声明一个 storage 的变量 xStorage，指向 x。修改 xStorage 也会影响 x        uint[] storage xStorage = x;        xStorage[0] = 100;    }\nstorage  赋值给 memory ，会创建独立的复本，修改其中一个不会影响另一个；反之亦然。\n\nuint[] x = [1,2,3]; // 状态变量：数组 x        function fMemory() public view{        // 声明一个 Memory 的变量 xMemory，复制 x。修改 xMemory 不会影响 x        uint[] memory xMemory = x;        xMemory[0] = 100;        xMemory[1] = 200;        uint[] memory xMemory2 = x;        xMemory2[0] = 300;    }debug  康康\n\n\n\nmemory  赋值给 memory ，会创建引用，改变新变量会影响原变量\n其他情况，变量赋值给 storage ，会创建独立的复本，修改其中一个不会影响另一个\n\n# 作用域\n\n\n状态变量\n数据存储在链上的变量，所有的合约内的函数都可以访问， gas  消耗高。状态变量在合约内、函数外声明（可以在函数里更改状态变量的值）\n\n\n局部变量\n局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链， gas  低。局部变量在函数内声明\n\n\nfunction bar() external pure returns(uint){        uint xx = 1;        uint yy = 3;        uint zz = xx + yy;        return(zz);    }\n全局变量\n全局变量是全局范围工作的变量，都是 solidity  预留关键字（可以在函数内不声明直接使用）\n\nfunction global() external view returns(address, uint, bytes memory){        address sender = msg.sender;        uint blockNum = block.number;        bytes memory data = msg.data;        return(sender, blockNum, data);    }\n# 6. 引用类型\n# 数组 array\n数组（ Array ）是 solidity  常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）\n\n固定长度数组：在声明时指定数组的长度。用 T[k]  的格式表明，其中 T  是元素的类型， k  是长度，eg:\n\n// 固定长度 Array    uint[8] array1;    bytes1[5] array2;    address[100] array3;\n可变长度数组（动态数组）：在声明时不指定数值的长度。用 T[]  的格式表明，其中 T  是元素的类型（ bytes  比较特殊，是数组，但是不加 [] ），eg：\n\n// 可变长度 Array    uint[] array4;    bytes1[] array5;    address[] array6;    bytes array7;# 创建数组的规则\n\n对于 memory  修饰的 动态数组 ，可以用 new  操作符来创建，但是必须声明长度，并且声明后长度不能改变，eg：\n\n//memory 动态数组    uint[] memory array8 = new uint[](5);    bytes memory array9 = new bytes(9);\n数组字面常数（Array Literals）是写作表达形式的数组，用方括号包着来初始化 array 的一种方式，并且里面每一个元素的 type 是以第一个元素为准的，例如 [1,2,3]  里面所有的元素都是 uint8 类型，因为在 solidity 中如果一个值没有指定 type 的话，默认就是最小单位的该 type，这里 int 的默认最小单位类型就是 uint8。而 [uint(1),2,3]  里面的元素都是 uint 类型，因为第一个元素指定了是 uint 类型了，我们都以第一个元素为准。下面的合约中，对于 f 函数里面的调用，如果我们没有显式对第一个元素进行 uint 强转的话，是会报错的，因为如上所述我们其实是传入了 uint8 类型的 array，可是 g 函数需要的却是 uint 类型的 array，就会报错了。\n\n// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.4.16 &lt;0.9.0;contract C {    function f() public pure {        g([uint(1), 2, 3]);\t //uint (1) 强转了。如果是 g ([1,2,3]), 就是 uint8 类型    }    function g(uint[3] memory) public pure {\t//g () 这边传入的是 uint 类型        // ...    }}\n如果创建的是动态数组，你需要一个一个元素的赋值。\n\nuint[] memory x = new uint[](3);    x[0] = 1;    x[1] = 3;    x[2] = 4;# 数组成员\n\n# 结构体\n创建结构体\n// 结构体    struct Student{        uint256 id;        uint256 score;     }Student student; // 初始一个 student 结构体给结构体赋值的两种方法\n//  给结构体赋值    // 方法 1: 在函数中创建一个 storage 的 struct 引用    function initStudent1() external{        Student storage _student = student; // assign a copy of student        _student.id = 11;        _student.score = 100;    }// 方法 2: 直接引用状态变量的 struct    function initStudent2() external{        student.id = 1;        student.score = 80;    }# 7. 映射类型\n# mapping\n在映射中，人们可以通过键（ Key ）来查询对应的值（ Value ），比如：通过一个人的 id  来查询他的钱包地址。\n mapping(_KeyType =&gt; _ValueType) eg:\nmapping(uint =&gt; address) public idToAddress; //id 映射到地址    mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址# 映射的规则\n\n规则 1：映射的 _KeyType  只能选择 solidity  默认的类型，比如 uint ， address  等，不能用自定义的结构体。而 _ValueType  可以使用自定义的类型。\n规则 2：映射的存储位置必须是 storage ，因此可以用于合约的状态变量，函数中的 storage  变量。不能用于 public  函数的参数或返回结果中，因为 mapping  记录的是一种关系 (key - value pair)。\n规则 3：如果映射声明为 public ，那么 solidity  会自动给你创建一个 getter  函数，可以通过 Key  来查询对应的 Value 。\n规则 4：给映射新增的键值对的语法为 _Var[_Key] = _Value ，其中 _Var  是映射变量名， _Key  和 _Value  对应新增的键值对。eg：\n\nfunction writeMap (uint _Key, address _Value) public{        idToAddress[_Key] = _Value;    }# 映射的原理\n\n原理 1：映射不储存任何键（ Key ）的资讯，也没有 length 的资讯。\n原理 2：映射使用 keccak256(key)  当成 offset 存取 value。\n原理 3：因为 Ethereum 会定义所有未使用的空间为 0，所以未赋值（ Value ）的键（ Key ）初始值都是 0。\n\n# 8. 变量初始值\n声明但没赋值的变量都是有初始值\n# 值类型初始值\n\nboolean : false\nstring : \"\"\nint : 0\nuint : o\nenum : 枚举的第一个元素\naddress : 0x0000000000000000000000000000000000000000  (或 address(0) )\nfunction\n\ninternal : 空白方程\nexternal : 空白方程\n\n\n\n可以用 public  变量的 getter  函数验证初始值：\nbool public _bool;\t......# 引用类型初始值\n\n映射 mapping ：所有元素都为其默认值的 mapping\n结构体 struct ：所有成员都设为其默认值的结构题\n数组 array ：\n\n动态数组： []\n静态数组：所有成员设为其默认值的静态数组\n\n\n\n验证方式一样，eg：\nmapping(uint =&gt; address) public _mapping; // 所有元素都为其默认值的 mapping            // 所有成员设为其默认值的结构体 0, 0    struct Student{        uint256 id;        uint256 score;     }    Student public student;#  delete  操作符\ndelete a  会让变量 a  的值变为初始值\n# 9. 常数\nconstant （常量）和 immutable （不变量）。状态变量声明这个两个关键字之后，不能在合约后更改数值；并且还可以节省 gas 。\n另外，只有数值变量可以声明 constant  和 immutable ； string  和 bytes  可以声明为 constant ，但不能为 immutable 。\n# constant\nconstant  变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过。\n//constant 变量必须在声明的时候初始化，之后不能改变    uint256 constant CONSTANT_NUM = 10;    string constant CONSTANT_STRING = \"0xAA\";    bytes constant CONSTANT_BYTES = \"WTF\";    address constant CONSTANT_ADDRESS = 0x0000000000000000000000000000000000000000;# immutable\nimmutable  变量可以在声明时或构造函数中初始化，因此更加灵活。\n//immutable 变量可以在 constructor 里初始化，之后不能改变    uint256 public immutable IMMUTABLE_NUM = 9999999999;    address public immutable IMMUTABLE_ADDRESS;    uint256 public immutable IMMUTABLE_BLOCK;    uint256 public immutable IMMUTABLE_TEST;可以使用全局变量例如 address(this) ， block.number  ，或者自定义的函数给 immutable  变量初始化。在下面这个例子，我们利用了 test()  函数给 IMMUTABLE_TEST  初始化为 9 ：\n// 利用 constructor 初始化 immutable 变量，因此可以利用    constructor(){        IMMUTABLE_ADDRESS = address(this);        IMMUTABLE_BLOCK = block.number;        IMMUTABLE_TEST = test();    }    function test() public pure returns(uint256){        uint256 what = 9;        return(what);    }# 10. 控制流\n\nif-else\nfor循环\nwhie循环\ndo-while循环\n三元运算符 ：三元运算符是 solidity  中唯一一个接受三个操作数的运算符，规则 条件? 条件为真的表达式:条件为假的表达式 。 此运算符经常用作 if 语句的快捷方式。\n\n// 三元运算符 ternary/conditional operatorfunction ternaryTest(uint256 x, uint256 y) public pure returns(uint256){    // return the max of x and y    return x &gt;= y ? x: y; }# 用 solidity  实现插入排序\n# 插入排序\n排序算法解决的问题是将无序的一组数字，例如 [2, 5, 3, 1] ，从小到大依次排列好。（思路：从前往后，依次将每一个数和排在他前面的数字比大小，如果比前面的数字小，就互换位置。）\n贴个 python  代码\n# Python program for implementation of Insertion Sortdef insertionSort(arr):    for i in range(1, len(arr)):        key = arr[i]        j = i-1        while j &gt;=0 and key &lt; arr[j] :                arr[j+1] = arr[j]                j -= 1        arr[j+1] = key改写成 solidity  后有 BUG！\n// 插入排序 错误版    function insertionSortWrong(uint[] memory a) public pure returns(uint[] memory) {                for (uint i = 1;i &lt; a.length;i++){            uint temp = a[i];            uint j=i-1;            while( (j &gt;= 0) &amp;&amp; (temp &lt; a[j])){                a[j+1] = a[j];                j--;            }            a[j+1] = temp;        }        return(a);    }原因： solidity  中最常用的变量类型是 uint ，也就是正整数，取到负值的话，会报 underflow  错误。而在插入算法中，变量 j  有可能会取到 -1 ，引起报错。\n这里把 j  加 1，让它无法取到赋值\n// 插入排序 正确版    function insertionSort(uint[] memory a) public pure returns(uint[] memory) {        // note that uint can not take negative value        for (uint i = 1;i &lt; a.length;i++){            uint temp = a[i];            uint j=i;            while( (j &gt;= 1) &amp;&amp; (temp &lt; a[j-1])){                a[j] = a[j-1];                j--;            }            a[j] = temp;        }        return(a);    }# 11. 构造函数和修饰器\n# 构造函数\n构造函数（ constructor ）是一种特殊的函数，每个合约可以定义一个，并在部署合约的时候自动运行一次。它可以用来初始化合约的一些参数，例如初始化合约的 owner  地址：\naddress owner; // 定义 owner 变量   // 构造函数   constructor() {      owner = msg.sender; // 在部署合约的时候，将 owner 设置为部署者的地址   }Tip: 构造函数在不同的 solidity 版本中的语法并不一致，在 Solidity 0.4.22 之前，构造函数不使用  constructor  而是使用与合约名同名的函数作为构造函数而使用，由于这种旧写法容易使开发者在书写时发生疏漏（例如合约名叫  Parents ，构造函数名写成  parents ），使得构造函数变成普通函数，引发漏洞，所以 0.4.22 版本及之后，采用了全新的  constructor  写法。\npragma solidity =0.4.21;contract Parents {    // 与合约名 Parents 同名的函数就是构造函数    function Parents () public {    }}# 修饰器\n修饰器（ modifier ）是 solidity  特有的语法，类似于面向对象编程中的 decorator ，声明函数拥有的特性，并减少代码冗余。\n modifier  的主要使用场景是运行函数前的检查，例如地址，变量，余额等。\n// 定义 modifier   modifier onlyOwner {      require(msg.sender == owner); // 检查调用者是否为 owner 地址      _; // 如果是的话，继续运行函数主体；否则报错并 revert 交易   }带有 onlyOwner  修饰符的函数只能被 owner  地址调用，比如下面这个例子：\nfunction changeOwner(address _newOwner) external onlyOwner{      owner = _newOwner; // 只有 owner 地址运行这个函数，并改变 owner   }我们定义了一个 changeOwner  函数，运行他可以改变合约的 owner ，但是由于 onlyOwner  修饰符的存在，只有原先的 owner  可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。\n# 12. 事件\nSolidity  中的事件（ event ）是 EVM  上日志的抽象，它具有两个特点：\n\n应用程序（ ether.js ）可以通过 RPC  接口订阅和监听这些事件，并在前端做响应。\n事件是 EVM  上比较经济的存储数据的方式，每个大概消耗 2,000  gas ；相比之下，链上存储一个新变量至少需要 20,000  gas 。\n\n# 规则\n事件的声明由 event  关键字开头，然后跟事件名称，括号里面写好事件需要记录的变量类型和变量名。以 ERC20  代币合约的 Transfer  事件为例：\nevent Transfer(address indexed from, address indexed to, uint256 value);Transfer  事件共记录了 3 个变量 from ， to  和 value ，分别对应代币的转账地址，接收地址和转账数量。\n同时 from  和 to  前面带着 indexed  关键字，每个 indexed  标记的变量可以理解为检索事件的索引 “键”，在以太坊上单独作为一个 topic  进行存储和索引，程序可以轻松的筛选出特定转账地址和接收地址的转账事件。每个事件最多有 3 个带 indexed  的变量。每个  indexed  变量的大小为固定的 256 比特。事件的哈希以及这三个带 indexed  的变量在 EVM  日志中通常被存储为 topic 。其中 topic[0]  是此事件的 keccak256  哈希， topic[1]  到 topic[3]  存储了带 indexed  变量的 keccak256  哈希。\n\nvalue  不带  indexed  关键字，会存储在事件的  data  部分中，可以理解为事件的 “值”。 data  部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般  data  部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了 256 比特，即使存储在事件的  topic  部分中，也是以哈希的方式存储。另外， data  部分的变量在存储上消耗的 gas 相比于  topic  更少。\n可以在函数里释放事件：\n// 定义_transfer 函数，执行转账逻辑    function _transfer(        address from,        address to,        uint256 amount    ) external {        _balances[from] = 10000000; // 给转账地址一些初始代币        _balances[from] -=  amount; //from 地址减去转账数量        _balances[to] += amount; //to 地址加上转账数量        // 释放事件        emit Transfer(from, to, amount);    }# 13. 继承\n# 规则\n\nvirtual : 父合约中的函数，如果希望子合约重写，需要加上 virtual  关键字。\noverride ：子合约重写了父合约中的函数，需要加上 override  关键字。\n\n# 简单继承\n（确实比较简单，直接贴例子）\n先写一个简单的爷爷合约 Yeye ，里面包含 1 个 Log  事件和 3 个 function :  hip() ,  pop() ,  yeye() ，输出都是”Yeye”。\ncontract Yeye {    event Log(string msg);    // 定义 3 个 function: hip (), pop (), man ()，Log 值为 Yeye。    function hip() public virtual{        emit Log(\"Yeye\");    }    function pop() public virtual{        emit Log(\"Yeye\");    }    function yeye() public virtual {        emit Log(\"Yeye\");    }}再定义一个爸爸合约 Baba ，让他继承 Yeye  合约，语法就是 contract Baba is Yeye ，非常直观。在 Baba  合约里，我们重写一下 hip()  和 pop()  这两个函数，加上 override  关键字，并将他们的输出改为 ”Baba” ；并且加一个新的函数 baba ，输出也是 ”Baba” 。\ncontract Baba is Yeye{    // 继承两个 function: hip () 和 pop ()，输出改为 Baba。    function hip() public virtual override{        emit Log(\"Baba\");    }    function pop() public virtual override{        emit Log(\"Baba\");    }    function baba() public virtual{        emit Log(\"Baba\");    }}部署合约，可以看到 Baba  合约里有 4 个函数，其中 hip()  和 pop()  的输出被成功改写成 ”Baba” ，而继承来的 yeye()  的输出仍然是 ”Yeye” 。\n# 多重继承\nsolidity  合约可以继承多个合约\n继承时要按辈分最高到最低的顺序排。比如我们写一个 Erzi  合约，继承 Yeye  合约和 Baba  合约，那么就要写成 contract Erzi is Yeye, Baba ，而不能写成 contract Erzi is Baba, Yeye ，不然就会报错。 如果某一个函数在多个继承的合约里都存在，比如例子中的 hip()  和 pop() ，在子合约里必须重写，不然会报错。 重写在多个父合约中都重名的函数时， override  关键字后面要加上所有父合约名字，例如 override(Yeye, Baba) 。 例子：\ncontract Erzi is Yeye, Baba{    // 继承两个 function: hip () 和 pop ()，输出值为 Erzi。    function hip() public virtual override(Yeye, Baba){        emit Log(\"Erzi\");    }    function pop() public virtual override(Yeye, Baba) {        emit Log(\"Erzi\");    }# 修饰器的继承\nSolidity  中的修饰器（ Modifier ）同样可以继承，用法与函数继承类似，在相应的地方加 virtual  和 override  关键字即可。\ncontract Base1 {    modifier exactDividedBy2And3(uint _a) virtual {        require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);        _;    }}contract Identifier is Base1 {    // 计算一个数分别被 2 除和被 3 除的值，但是传入的参数必须是 2 和 3 的倍数    function getExactDividedBy2And3(uint _dividend) public exactDividedBy2And3(_dividend) pure returns(uint, uint) {        return getExactDividedBy2And3WithoutModifier(_dividend);    }    // 计算一个数分别被 2 除和被 3 除的值    function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returns(uint, uint){        uint div2 = _dividend / 2;        uint div3 = _dividend / 3;        return (div2, div3);    }}Identifier  合约可以直接在代码中使用父合约中的 exactDividedBy2And3  修饰器，也可以利用 override  关键字重写修饰器：\nmodifier exactDividedBy2And3(uint _a) override {        _;        require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);    }# 构造函数的继承\n子合约有两种方法继承父合约的构造函数。举个简单的例子，父合约 A 里面有一个状态变量 a，并由构造函数的参数来确定：\n// 构造函数的继承abstract contract A {    uint public a;    constructor(uint _a) {        a = _a;    }}1. 在继承时声明父构造函数的参数，例如： contract B is A(1) \n 2. 在子合约的构造函数中声明构造函数的参数，例如：\ncontract C is A {    constructor(uint _c) A(_c * _c) {}}# 调用父合约的函数\n子合约有两种调用父合约的函数\n\n直接调用：子合约可以直接用 父合约名.函数名()  的方式来调用父合约函数，例如 Yeye.pop() 。\n\nfunction callParent() public{        Yeye.pop();    }\nsuper  关键字：子合约可以利用 super.函数名()  来调用最近的父合约函数。 solidity  继承关系按声明时从右到左的顺序是： contract Erzi is Yeye, Baba ，那么 Baba  是最近的父合约， super.pop()  将调用 Baba.pop()  而不是 Yeye.pop() ：\n\nfunction callParentSuper() public{        // 将调用最近的父合约函数，Baba.pop ()        super.pop();    }# 14. 抽象合约和接口\n# 抽象合约\n如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体 {}  中的内容，则必须将该合约标为 abstract ，不然编译会报错；另外，未实现的函数需要加 virtual ，以便子合约重写。拿我们之前的 插入排序合约 为例，如果我们还没想好具体怎么实现插入排序函数，那么可以把合约标为 abstract ，之后让别人补写上。\nabstract contract InsertionSort{    function insertionSort(uint[] memory a) public pure virtual returns(uint[] memory);}# 接口\n接口类似于抽象合约，但不实现任何功能。\n规则：\n\n不能包含状态变量\n不能包含构造函数\n不能继承除接口外的其他合约\n所有函数都必须是 external  且不能有函数体\n继承接口的合约必须实现接口定义的所有功能\n\n虽然接口不实现任何功能，但它非常重要。接口是智能合约的骨架，定义了合约的功能以及如何触发它们：如果智能合约实现了某种接口（比如 ERC20  或 ERC721 ），其他 Dapps 和智能合约就知道如何与它交互。因为接口提供了两个重要的信息：\n1. 合约里每个函数的 bytes4 选择器，以及基于它们的函数签名函数名 (每个参数类型）。\n2. 接口 id（更多信息见 EIP165）\n另外，接口与合约 ABI （Application Binary Interface）等价，可以相互转换：编译接口可以得到合约的 ABI ，利用 abi-to-sol 工具也可以将 ABI json  文件转换为 接口sol  文件。\n我们以 ERC721  接口合约 IERC721  为例，它定义了 3 个 event  和 9 个 function ，所有 ERC721  标准的 NFT 都实现了这些函数。我们可以看到，接口和常规合约的区别在于每个函数都以 ;  代替函数体 { }  结尾。\ninterface IERC721 is IERC165 {    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);        function balanceOf(address owner) external view returns (uint256 balance);    function ownerOf(uint256 tokenId) external view returns (address owner);    function safeTransferFrom(address from, address to, uint256 tokenId) external;    function transferFrom(address from, address to, uint256 tokenId) external;    function approve(address to, uint256 tokenId) external;    function getApproved(uint256 tokenId) external view returns (address operator);    function setApprovalForAll(address operator, bool _approved) external;    function isApprovedForAll(address owner, address operator) external view returns (bool);    function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data) external;}# IERC721 事件\nIERC721  包含 3 个事件，其中 Transfer  和 Approval  事件在 ERC20  中也有。\n\nTransfer  事件：在转账时被释放，记录代币的发出地址 from ，接收地址 to  和 tokenid 。\nApproval  事件：在授权时释放，记录授权地址 owner ，被授权地址 approved  和 tokenid 。\nApprovalForAll  事件：在批量授权时释放，记录批量授权的发出地址 owner ，被授权地址 operator  和授权与否的 approved 。\n\n# IERC721 函数\n\nbalanceOf ：返回某地址的 NFT 持有量 balance 。\nownerOf ：返回某 tokenId  的主人 owner 。\ntransferFrom ：普通转账，参数为转出地址 from ，接收地址 to  和 tokenId 。\nsafeTransferFrom ：安全转账（如果接收方是合约地址，会要求实现 ERC721Receiver  接口）。参数为转出地址 from ，接收地址 to  和 tokenId 。\napprove ：授权另一个地址使用你的 NFT。参数为被授权地址 approve  和 tokenId 。\ngetApproved ：查询 tokenId  被批准给了哪个地址。\nsetApprovalForAll ：将自己持有的该系列 NFT 批量授权给某个地址 operator 。\nisApprovedForAll ：查询某地址的 NFT 是否批量授权给了另一个 operator  地址。\nsafeTransferFrom ：安全转账的重载函数，参数里面包含了 data 。\n\n# 什么时候使用接口\n如果我们知道一个合约实现了 IERC721  接口，我们不需要知道它具体代码实现，就可以与它交互。\n无聊猿 BAYC  属于 ERC721  代币，实现了 IERC721  接口的功能。我们不需要知道它的源代码，只需知道它的合约地址，用 IERC721  接口就可以与它交互，比如用 balanceOf()  来查询某个地址的 BAYC  余额，用 safeTransferFrom()  来转账 BAYC 。\ncontract interactBAYC {    // 利用 BAYC 地址创建接口合约变量（ETH 主网）    IERC721 BAYC = IERC721(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D);    // 通过接口调用 BAYC 的 balanceOf () 查询持仓量    function balanceOfBAYC(address owner) external view returns (uint256 balance){        return BAYC.balanceOf(owner);    }    // 通过接口调用 BAYC 的 safeTransferFrom () 安全转账    function safeTransferFromBAYC(address from, address to, uint256 tokenId) external{        BAYC.safeTransferFrom(from, to, tokenId);    }}# 15. 异常\n写智能合约经常会出 bug ， solidity  中的异常命令帮助我们 debug 。\n# Error\nerror  是 solidity 0.8版本 新加的内容，方便且高效（省 gas ）地向用户解释操作失败的原因。人们可以在 contract  之外定义异常。下面，我们定义一个 TransferNotOwner  异常，当用户不是代币 owner  的时候尝试转账，会抛出错误：\nerror TransferNotOwner(); // 自定义 error在执行当中， error  必须搭配 revert （回退）命令使用。\nfunction transferOwner1(uint256 tokenId, address newOwner) public {        if(_owners[tokenId] != msg.sender){            revert TransferNotOwner();        }        _owners[tokenId] = newOwner;    }我们定义了一个 transferOwner1()  函数，它会检查代币的 owner  是不是发起人，如果不是，就会抛出 TransferNotOwner  异常；如果是的话，就会转账。\n# Require\nrequire  命令是 solidity 0.8版本 之前抛出异常的常用方法，目前很多主流合约仍然还在使用它。它很好用，唯一的缺点就是 gas  随着描述异常的字符串长度增加，比 error  命令要高。使用方法： require(检查条件，\"异常的描述\") ，当检查条件不成立的时候，就会抛出异常。\n我们用 require  命令重写一下上面的 transferOwner  函数：\nfunction transferOwner2(uint256 tokenId, address newOwner) public {        require(_owners[tokenId] == msg.sender, \"Transfer Not Owner\");        _owners[tokenId] = newOwner;    }贴个在 remix 上验证的例子吧\n 1. 输入任意 uint256  数字和非 0 地址，调用 transferOwner1 ，也就是 error  方法，控制台抛出了异常并显示我们自定义的 TransferNotOwner 。\n\n2. 输入任意 uint256  数字和非 0 地址，调用 transferOwner2 ，也就是 require  方法，控制台抛出了异常并打印出 require  中的字符串。\n\n3. 输入任意 uint256  数字和非 0 地址，调用 transferOwner3 ，也就是 assert  方法，控制台只抛出了异常。\n\n# Assert\nassert  命令一般用于程序员写程序 debug ，因为它不能解释抛出异常的原因（比 require  少个字符串）。它的用法很简单， assert(检查条件） ，当检查条件不成立的时候，就会抛出异常。\n我们用 assert  命令重写一下上面的 transferOwner  函数：\nfunction transferOwner3(uint256 tokenId, address newOwner) public {        assert(_owners[tokenId] == msg.sender);        _owners[tokenId] = newOwner;    }# 三种方法的 gas  比较\n我们比较一下三种抛出异常的 gas  消耗，通过 remix 控制台的 Debug 按钮，能查到每次函数调用的 gas  消耗分别如下：\n\n error  方法 gas  消耗：24445\n require  方法 gas  消耗：24743\n assert  方法 gas  消耗：24446\n\n我们可以看到， error  方法 gas  最少，其次是 assert ， require  方法消耗 gas  最多！因此， error  既可以告知用户抛出异常的原因，又能省 gas ，大家要多用！（注意，由于部署测试时间的不同，每个函数的 gas  消耗会有所不同，但是比较结果会是一致的。）\n","slug":"solidity入门","date":"2022-11-26T16:55:02.000Z","categories_index":"","tags_index":"solidity","author_index":"cocoZ"},{"id":"4a8c6c67f0d77f1d7a087ca184ac4b68","title":"hexo+github搭建个人博客","content":"# 搭建个人博客（hexo+github）\n准备工作\n安装 git、安装 node.js、还有 npm 啥的（在看到任务前就装好了的）\n# 在 github 上创建仓库\n仓库名字要和用户名一样！！！\n（github pages 等一会儿就出来了）\n\n# 安装 hexo\n桌面创建一个文件夹，在文件夹目录下打开 git bash here\n\n安装 hexo\n npm install -g hexo-cli\n查看版本\n hexo -v\n初始化 hexo、\n hexo init\n生成本地的 hexo 页面\n hexo s\n输入 hexo g  生成静态网站\n输入 hexo s ，然后浏览器打开 localhost:4000 ，就可以本地访问了（ Ctrl+c  退出）\n# 连接 GitHub 与本地\n绑定个密钥：\n生成 SSH Keys \n ssh-keygen -t rsa -C \"你的邮箱地址\"\n在 C/用户/16017/.ssh  目录下打开这个，复制\n\n打开 github  的总 setting ，添加 SSH Keys\n\n在目录下打开 git bash here ，输入以下命令\n git config --global user.name cocoGenZ \n git config --global user.email 160760796@qq.com\n打开博客根目录下的 _config.yml  文件，修改最后一行的配置\n  type: git\n  repository: https://github.com/cocoGenZ/cocoGenZ.github.io.git\n  branch: main\n\nTip: 上面的 repository  在 GitHub 里面复制 HTTPS  那个\n\n安装一键部署插件\n cnpm install hexo-deployer-git --save  (不知道为什么有这个 save 的我安装不了，就另外装了个 cnpm 来安装)（更新完就 ok 了 `npm -g install npm@latest）\n分别输入一下三条命令\n hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public \n hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写) \n hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)\n最后访问博客的地址就可以啦 https://cocogenz.github.io/\n\n# 改个主题吧\n安装一个 yarn（命令行就能装，用 npm 来装）\n yarn add hexo-theme-aurora\n\n改改参数\n\n# 关于上传图片显示的问题\n将图片上传到网上，再用 markdown 引用\n https://sm.ms/\n 这个网址很方便\n","slug":"hexo-github搭建个人博客","date":"2022-11-21T14:10:57.000Z","categories_index":"","tags_index":"博客","author_index":"cocoZ"},{"id":"7b9812fe6cbf2aba598dcdf2de807daf","title":"Test","content":"第一次搭博客，浅浅做个测试\n","slug":"Test","date":"2022-11-15T03:55:53.000Z","categories_index":"","tags_index":"","author_index":"cocoZ"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n# Quick Start\n# Create a new post\nh$ hexo new \"My New Post\"More info: Writing\n# Run server\nh$ hexo serverMore info: Server\n# Generate static files\nh$ hexo generateMore info: Generating\n# Deploy to remote sites\nh$ hexo deployMore info: Deployment\n","slug":"hello-world","date":"2022-11-15T02:54:10.513Z","categories_index":"","tags_index":"","author_index":"cocoZ"}]