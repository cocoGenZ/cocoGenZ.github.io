[{"id":"26cdbf141378457625c3c7f264148e8f","title":"solidity进阶","content":"solidity进阶\r\n16.函数重载\r\n重载\r\nsolidity中允许函数进行重载（overloading），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，solidity不允许修饰器（modifier）重载。\r\n函数重载\r\n举个例子，我们可以定义两个都叫saySomething()的函数，一个没有任何参数，输出\"Nothing\"；另一个接收一个string参数，输出这个string。\r\nfunction saySomething() public pure returns(string memory){\r\n    return(\"Nothing\");\r\n}\r\n\r\nfunction saySomething(string memory something) public pure returns(string memory){\r\n    return(something);\r\n}\r\n最终重载函数在经过编译器编译后，由于不同的参数类型，都变成了不同的函数选择器（selector）。(选择器在29的内容)\r\n实参匹配（Argument Matching）\r\n在调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配。\r\n如果出现多个匹配的重载函数，则会报错。下面这个例子有两个叫f()的函数，一个参数为uint8，另一个为uint256：\r\n    function f(uint8 _in) public pure returns (uint8 out) {\r\n        out = _in;\r\n    }\r\n\r\n    function f(uint256 _in) public pure returns (uint256 out) {\r\n        out = _in;\r\n    }\r\n我们调用f(50)，因为50既可以被转换为uint8，也可以被转换为uint256，因此会报错。\r\n17.库合约\r\n库函数\r\n库函数是一种特殊的合约，为了提升solidity代码的复用性和减少gas而存在。库合约一般都是一些好用的函数合集（库函数），由大神或者项目方创作，咱们站在巨人的肩膀上，会用就行了。\r\n库函数和普通合约的不同：\r\n1.不能存在状态变量\r\n2.不能够继承或被继承\r\n3.不能接受以太币\r\n4.不可以被销毁\r\nString库合约\r\nString库合约是将uint256类型转换为相应的string类型的代码库，样例代码如下：\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) public pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) public pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp &gt;&gt;= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) public pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i &gt; 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value &amp; 0xf];\r\n            value &gt;&gt;= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n他主要包含两个函数，toString()将uint256转为string，toHexString()将uint256转换为16进制，在转换为string。\r\n如何使用库合约\r\n1.利用using for指令\r\n指令using A for B;可用于附加库函数（从库\r\nA）到任何类型（B）。添加完指令后，库A中的函数会自动添加为B类型变量的成员，可以直接调用。注意：在调用的时候，这个变量会被当作第一个参数传递给函数：\r\n    // 利用using for指令\r\n    using Strings for uint256;\r\n    function getString1(uint256 _number) public pure returns(string memory){\r\n        // 库函数会自动添加为uint256型变量的成员\r\n        return _number.toHexString();\r\n    }\r\n2.通过库合约名称调用库函数\r\n    // 直接通过库合约名调用\r\n    function getString2(uint256 _number) public pure returns(string memory){\r\n        return Strings.toHexString(_number);\r\n    }\r\n\r\nString：将uint256转换为String\r\nAddress：判断某个地址是否为合约地址\r\nCreate2：更安全的使用Create2 EVM opcode\r\nArrays：跟数组相关的库函数\r\n\r\n18.Import\r\nsolidity支持利用import关键字导入其他源代码中的合约，让开发更加模块化。\r\nimport用法\r\n\r\n通过源文件相对位置导入，eg：\r\n\r\n文件结构\r\n├── Import.sol\r\n└── Yeye.sol\r\n\r\n// 通过文件相对位置import\r\nimport './Yeye.sol';\r\n\r\n通过源文件网址导入网上的合约，eg：\r\n\r\n// 通过网址引用\r\nimport 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol';\r\n\r\n通过npm的目录导入，eg：\r\n\r\nimport '@openzeppelin/contracts/access/Ownable.sol';\r\n\r\n通过全局符号导入特定的合约，eg：\r\n\r\nimport {Yeye} from './Yeye.sol';\r\n\r\n引用(import)在代码中的位置为：在声明版本号之后，在其余代码之前。\r\n\r\n19.接受ETH\r\nSolidity支持两种特殊的回调函数，receive()和fallback()，他们主要在两种情况下被使用：\r\n\r\n接收ETH\r\n处理合约中不存在的函数调用（代理合约proxy contract）\r\n\r\n注意⚠️：在solidity 0.6.x版本之前，语法上只有 fallback()\r\n函数，用来接收用户发送的ETH时调用以及在被调用函数签名没有匹配到时，来调用。\r\n0.6版本之后，solidity才将 fallback() 函数拆分成\r\nreceive() 和 fallback() 两个函数。\r\n接受ETH函数receive\r\nreceive()只用于处理接收ETH。一个合约最多有一个receive()函数，声明方式与一般函数不一样，不需要function关键字：receive() external payable { ... }。receive()函数不能有任何的参数，不能返回任何值，必须包含external和payable。\r\n当合约接收ETH的时候，receive()会被触发。receive()最好不要执行太多的逻辑因为如果别人用send和transfer方法发送ETH的话，gas会限制在2300，receive()太复杂可能会触发Out of Gas报错；如果用call就可以自定义gas执行更复杂的逻辑（这三种发送ETH的方法我们之后会讲到）。\r\n可以在receive()里发送一个event，eg：\r\n    // 定义事件\r\n    event Received(address Sender, uint Value);\r\n    // 接收ETH时释放Received事件\r\n    receive() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n有些恶意合约，会在receive() 函数（老版本的话，就是\r\nfallback()\r\n函数）嵌入恶意消耗gas的内容或者使得执行故意失败的代码，导致一些包含退款和转账逻辑的合约不能正常工作，因此写包含退款等逻辑的合约时候，一定要注意这种情况。\r\n回退函数fallback\r\nfallback()函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约proxy contract。fallback()声明时不需要function关键字，必须由external修饰，一般也会用payable修饰，用于接收ETH:fallback() external payable { ... }。\r\n我们定义一个fallback()函数，被触发时候会释放fallbackCalled事件，并输出msg.sender，msg.value和msg.data:\r\n    // fallback\r\n    fallback() external payable{\r\n        emit fallbackCalled(msg.sender, msg.value, msg.data);\r\n    }\r\nreceive和fallback的区别\r\nreceive和fallback都能够用于接收ETH，他们触发的规则如下：\r\n触发fallback() 还是 receive()?\r\n           接收ETH\r\n              |\r\n         msg.data是空？\r\n            /  \\\r\n          是    否\r\n          /      \\\r\nreceive()存在?   fallback()\r\n        / \\\r\n       是  否\r\n      /     \\\r\nreceive()   fallback()\r\n简单来说，合约接收ETH时，msg.data为空且存在receive()时，会触发receive()；msg.data不为空或不存在receive()时，会触发fallback()，此时fallback()必须为payable。\r\nreceive()和payable fallback()均不存在的时候，向合约发送ETH将会报错。\r\n20.发送ETH\r\n接受ETH合约\r\n我们先部署一个接收ETH合约ReceiveETH。ReceiveETH合约里有一个事件Log，记录收到的ETH数量和gas剩余。还有两个函数，一个是receive()函数，收到ETH被触发，并发送Log事件；另一个是查询合约ETH余额的getBalance()函数。\r\ncontract ReceiveETH {\r\n    // 收到eth事件，记录amount和gas\r\n    event Log(uint amount, uint gas);\r\n    \r\n    // receive方法，接收eth时被触发\r\n    receive() external payable{\r\n        emit Log(msg.value, gasleft());\r\n    }\r\n    \r\n    // 返回合约ETH余额\r\n    function getBalance() view public returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n}\r\n部署ReceiveETH合约后，运行getBalance()函数，可以看到当前合约的ETH余额为0。\r\n发送ETH合约\r\n我们将实现三种方法向ReceiveETH合约发送ETH。首先，先在发送ETH合约SendETH中实现payable的构造函数和receive()，让我们能够在部署时和部署后向合约转账。\r\ncontract SendETH {\r\n    // 构造函数，payable使得部署的时候可以转eth进去\r\n    constructor() payable{}\r\n    // receive方法，接收eth时被触发\r\n    receive() external payable{}\r\n}\r\ntransfer\r\n\r\n用法是接收方地址.transfer(发送ETH数额)。\r\ntransfer()的gas限制是2300，足够用于转账，但对方合约的fallback()或receive()函数不能实现太复杂的逻辑。\r\ntransfer()如果转账失败，会自动revert（回滚交易）。\r\n\r\n代码样例，注意里面的_to填ReceiveETH合约的地址，amount是ETH转账金额：\r\n// 用transfer()发送ETH\r\nfunction transferETH(address payable _to, uint256 amount) external payable{\r\n    _to.transfer(amount);\r\n}\r\nsend\r\n\r\n用法是接收方地址.send(发送ETH数额)。\r\nsend()的gas限制是2300，足够用于转账，但对方合约的fallback()或receive()函数不能实现太复杂的逻辑。\r\nsend()如果转账失败，不会revert。\r\nsend()的返回值是bool，代表着转账成功或失败，需要额外代码处理一下。\r\n\r\n代码样例：\r\n// send()发送ETH\r\nfunction sendETH(address payable _to, uint256 amount) external payable{\r\n    // 处理下send的返回值，如果失败，revert交易并发送error\r\n    bool success = _to.send(amount);\r\n    if(!success){\r\n        revert SendFailed();\r\n    }\r\n}\r\ncall\r\n\r\n用法是接收方地址.call{value: 发送ETH数额}(\"\")。\r\ncall()没有gas限制，可以支持对方合约fallback()或receive()函数实现复杂逻辑。\r\ncall()如果转账失败，不会revert。\r\ncall()的返回值是(bool, data)，其中bool代表着转账成功或失败，需要额外代码处理一下。\r\n\r\n代码样例：\r\n// call()发送ETH\r\nfunction callETH(address payable _to, uint256 amount) external payable{\r\n    // 处理下call的返回值，如果失败，revert交易并发送error\r\n    (bool success,) = _to.call{value: amount}(\"\");\r\n    if(!success){\r\n        revert CallFailed();\r\n    }\r\n}\r\n三者的选择\r\n\r\ncall没有gas限制，最为灵活，是最提倡的方法；\r\ntransfer有2300 gas限制，但是发送失败会自动revert交易，是次优选择；\r\nsend有2300 gas限制，而且发送失败不会自动revert交易，几乎没有人用它。\r\n\r\n21.调用其他合约\r\n调用已部署合约\r\n开发者写智能合约来调用其他合约，这让以太坊网络上的程序可以复用，从而建立繁荣的生态。很多web3项目依赖于调用其他合约，比如收益农场（yield farming）。这一讲，我们介绍如何在已知合约代码（或接口）和地址情况下调用目标合约的函数。\r\n目标合约\r\n先写一个简单的合约OtherContract来调用。\r\ncontract OtherContract {\r\n    uint256 private _x = 0; // 状态变量_x\r\n    // 收到eth的事件，记录amount和gas\r\n    event Log(uint amount, uint gas);\r\n    \r\n    // 返回合约ETH余额\r\n    function getBalance() view public returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)\r\n    function setX(uint256 x) external payable{\r\n        _x = x;\r\n        // 如果转入ETH，则释放Log事件\r\n        if(msg.value &gt; 0){\r\n            emit Log(msg.value, gasleft());\r\n        }\r\n    }\r\n\r\n    // 读取_x\r\n    function getX() external view returns(uint x){\r\n        x = _x;\r\n    }\r\n}\r\n这个合约包含一个状态变量_x，一个事件Log在收到ETH时触发，三个函数：\r\n\r\ngetBalance(): 返回合约ETH余额。\r\nsetX():\r\nexternal payable函数，可以设置_x的值，并向合约发送ETH。\r\ngetX(): 读取_x的值。\r\n\r\n调用OtherContract合约\r\n（先贴个源码吧，本来以为要创建两个文件的，只要一个文件部署两个合约就可以了）\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ncontract OtherContract {\r\n    uint256 private _x = 0; // 状态变量x\r\n    // 收到eth事件，记录amount和gas\r\n    event Log(uint amount, uint gas);\r\n    \r\n    // 返回合约ETH余额\r\n    function getBalance() view public returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)\r\n    function setX(uint256 x) external payable{\r\n        _x = x;\r\n        // 如果转入ETH，则释放Log事件\r\n        if(msg.value &gt; 0){\r\n            emit Log(msg.value, gasleft());\r\n        }\r\n    }\r\n\r\n    // 读取x\r\n    function getX() external view returns(uint x){\r\n        x = _x;\r\n    }\r\n}\r\n\r\ncontract CallContract{\r\n    function callSetX(address _Address, uint256 x) external{\r\n        OtherContract(_Address).setX(x);\r\n    }\r\n\r\n    function callGetX(OtherContract _Address) external view returns(uint x){\r\n        x = _Address.getX();\r\n    }\r\n\r\n    function callGetX2(address _Address) external view returns(uint x){\r\n        OtherContract oc = OtherContract(_Address);\r\n        x = oc.getX();\r\n    }\r\n\r\n    function setXTransferETH(address otherContract, uint256 x) payable external{\r\n        OtherContract(otherContract).setX{value: msg.value}(x);\r\n    }\r\n}\r\n我们可以利用合约的地址和合约代码（或接口）来创建合约的引用：_Name(_Address)，其中_Name是合约名，_Address是合约地址。然后用合约的引用来调用它的函数：_Name(_Address).f()，其中f()是要调用的函数。\r\n下面我们介绍4个调用合约的例子，在remix中编译合约后，分别部署OtherContract和CallContract：(还没怎么搞得懂)\r\n\r\n\r\n\r\n1.传入合约地址\r\n我们可以在函数里传入目标合约地址，生成目标合约的引用，然后调用目标函数。以调用OtherContract合约的setX函数为例，我们在新合约中写一个callSetX函数，传入已部署好的OtherContract合约地址_Address和setX的参数x：\r\n    function callSetX(address _Address, uint256 x) external{\r\n        OtherContract(_Address).setX(x);\r\n    }\r\n复制OtherContract合约的地址，填入callSetX函数的参数中，成功调用后，调用OtherContract合约中的getX验证x变为123\r\n\r\n\r\n2.传入合约变量\r\n我们可以直接在函数里传入合约的引用，只需要把上面参数的address类型改为目标合约名，比如OtherContract。下面例子实现了调用目标合约的getX()函数。\r\n注意该函数参数OtherContract _Address底层类型仍然是address，生成的ABI中、调用callGetX时传入的参数都是address类型\r\n    function callGetX(OtherContract _Address) external view returns(uint x){\r\n        x = _Address.getX();\r\n    }\r\n复制OtherContract合约的地址，填入callGetX函数的参数中，调用后成功获取x的值\r\n\r\n3.创建合约变量\r\n我们可以创建合约变量，然后通过它来调用目标函数。下面例子，我们给变量oc存储了OtherContract合约的引用：\r\n    function callGetX2(address _Address) external view returns(uint x){\r\n        OtherContract oc = OtherContract(_Address);\r\n        x = oc.getX();\r\n    }\r\n复制OtherContract合约的地址，填入callGetX2函数的参数中，调用后成功获取x的值\r\n\r\n4.调用合约并发送ETH\r\n如果目标合约的函数是payable的，那么我们可以通过调用它来给合约转账：_Name(_Address).f{value: _Value}()，其中_Name是合约名，_Address是合约地址，f是目标函数名，_Value是要转的ETH数额（以wei为单位）。\r\nOtherContract合约的setX函数是payable的，在下面这个例子中我们通过调用setX来往目标合约转账。\r\n    function setXTransferETH(address otherContract, uint256 x) payable external{\r\n        OtherContract(otherContract).setX{value: msg.value}(x);\r\n    }\r\n复制OtherContract合约的地址，填入setXTransferETH函数的参数中，并转入10ETH\r\n\r\n转账后，我们可以通过Log事件和getBalance()函数观察目标合约ETH余额的变化。\r\n\r\n22.Call\r\ncall\r\n是address类型的低级成员函数，它用来与其他合约交互。它的返回值为(bool, data)，分别对应call是否成功以及目标函数的返回值。\r\n\r\ncall是solidity官方推荐的通过触发fallback或receive函数发送ETH的方法。\r\n不推荐用call来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数，见第21讲：调用其他合约\r\n当我们不知道对方合约的源代码或ABI，就没法生成合约变量；这时，我们仍可以通过call调用对方合约的函数。\r\n\r\ncall的使用规则\r\n目标合约地址.call(二进制编码);\r\n其中二进制编码利用结构化编码函数abi.encodeWithSignature获得：\r\nabi.encodeWithSignature(\"函数签名\", 逗号分隔的具体参数)\r\n函数签名为\"函数名（逗号分隔的参数类型)\"。例如abi.encodeWithSignature(\"f(uint256,address)\", _x, _addr)。\r\n另外call在调用合约时可以指定交易发送的ETH数额和gas：\r\n目标合约地址.call{value:发送数额, gas:gas数额}(二进制编码);\r\n(看不懂......举个栗子康康)\r\n目标合约\r\n先写一个简单的目标合约OtherContract并部署，代码与第19讲中基本相同，只是多了fallback函数。\r\ncontract OtherContract {\r\n    uint256 private _x = 0; // 状态变量x\r\n    // 收到eth的事件，记录amount和gas\r\n    event Log(uint amount, uint gas);\r\n    \r\n    fallback() external payable{}\r\n\r\n    // 返回合约ETH余额\r\n    function getBalance() view public returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)\r\n    function setX(uint256 x) external payable{\r\n        _x = x;\r\n        // 如果转入ETH，则释放Log事件\r\n        if(msg.value &gt; 0){\r\n            emit Log(msg.value, gasleft());\r\n        }\r\n    }\r\n\r\n    // 读取x\r\n    function getX() external view returns(uint x){\r\n        x = _x;\r\n    }\r\n}\r\n这个合约包含一个状态变量x，一个在收到ETH时触发的事件Log，三个函数：\r\n\r\ngetBalance(): 返回合约ETH余额。\r\nsetX():\r\nexternal payable函数，可以设置x的值，并向合约发送ETH。\r\ngetX(): 读取x的值。\r\n\r\n利用call调用目标合约\r\n1.Response事件\r\n我们写一个Call合约来调用目标合约函数。首先定义一个Response事件，输出call返回的success和data，方便我们观察返回值。\r\n// 定义Response事件，输出call返回的结果success和data\r\nevent Response(bool success, bytes data);\r\n2.调用setX函数\r\n我们定义callSetX函数来调用目标合约的setX()，转入msg.value数额的ETH，并释放Response事件输出success和data：\r\nfunction callSetX(address payable _addr, uint256 x) public payable {\r\n    // call setX()，同时可以发送ETH\r\n    (bool success, bytes memory data) = _addr.call{value: msg.value}(\r\n        abi.encodeWithSignature(\"setX(uint256)\", x)\r\n    );\r\n\r\n    emit Response(success, data); //释放事件\r\n}\r\n接下来我们调用callSetX把状态变量_x改为5，参数为OtherContract地址和5，由于目标函数setX()没有返回值，因此Response事件输出的data为0x，也就是空。\r\n\r\n3.调用getX函数\r\n下面我们调用getX()函数，它将返回目标合约_x的值，类型为uint256。我们可以利用abi.decode来解码call的返回值data，并读出数值。\r\nfunction callGetX(address _addr) external returns(uint256){\r\n    // call getX()\r\n    (bool success, bytes memory data) = _addr.call(\r\n        abi.encodeWithSignature(\"getX()\")\r\n    );\r\n\r\n    emit Response(success, data); //释放事件\r\n    return abi.decode(data, (uint256));\r\n}\r\n从Response事件的输出，我们可以看到data为0x0000000000000000000000000000000000000000000000000000000000000005。而经过abi.decode，最终返回值为5。\r\n\r\n4.调用不存在的函数\r\n如果我们给call输入的函数不存在于目标合约，那么目标合约的fallback函数会被触发。\r\nfunction callNonExist(address _addr) external{\r\n    // call getX()\r\n    (bool success, bytes memory data) = _addr.call(\r\n        abi.encodeWithSignature(\"foo(uint256)\")\r\n    );\r\n\r\n    emit Response(success, data); //释放事件\r\n}\r\n上面例子中，我们call了不存在的foo函数。call仍能执行成功，并返回success，但其实调用的目标合约fallback函数。\r\n\r\ncall不是调用合约的推荐方法，因为不安全。但他能让我们在不知道源代码和ABI的情况下调用目标合约，很有用。\r\n(最后直接贴上所有代码)\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ncontract OtherContract {\r\n    uint256 private _x = 0; // 状态变量x\r\n    // 收到eth的事件，记录amount和gas\r\n    event Log(uint amount, uint gas);\r\n    \r\n    fallback() external payable{}\r\n\r\n    // 返回合约ETH余额\r\n    function getBalance() view public returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)\r\n    function setX(uint256 x) external payable{\r\n        _x = x;\r\n        // 如果转入ETH，则释放Log事件\r\n        if(msg.value &gt; 0){\r\n            emit Log(msg.value, gasleft());\r\n        }\r\n    }\r\n\r\n    // 读取x\r\n    function getX() external view returns(uint x){\r\n        x = _x;\r\n    }\r\n}\r\n\r\n    contract call{\r\n        function callGetX(address _addr) external returns(uint256){\r\n    // call getX()\r\n    (bool success, bytes memory data) = _addr.call(\r\n        abi.encodeWithSignature(\"getX()\")\r\n    );\r\n\r\n    emit Response(success, data); //释放事件\r\n    return abi.decode(data, (uint256));\r\n}\r\n\r\n        event Response(bool success, bytes data);\r\n\r\n        function callSetX(address payable _addr, uint256 x) public payable {\r\n    // call setX()，同时可以发送ETH\r\n    (bool success, bytes memory data) = _addr.call{value: msg.value}(\r\n        abi.encodeWithSignature(\"setX(uint256)\", x)\r\n    );\r\n\r\n    emit Response(success, data); //释放事件\r\n}\r\n    function callNonExist(address _addr) external{\r\n    // call getX()\r\n    (bool success, bytes memory data) = _addr.call(\r\n        abi.encodeWithSignature(\"foo(uint256)\")\r\n    );\r\n\r\n    emit Response(success, data); //释放事件\r\n}\r\n    }\r\n23.Delegatecall\r\ndelegatecall与call类似，是solidity中地址类型的低级成员函数。delegate中是委托/代表的意思，那么delegatecall委托了什么？\r\n当用户A通过合约B来call合约C的时候，执行的是合约C的函数，语境(Context，可以理解为包含变量和状态的环境)也是合约C的：msg.sender是B的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约C的变量上。\r\n\r\n而当用户A通过合约B来delegatecall合约C的时候，执行的是合约C的函数，但是语境仍是合约B的：msg.sender是A的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约B的变量上。\r\n\r\n大家可以这样理解：一个富商把它的资产（状态变量）都交给一个VC代理（目标合约的函数）来打理。执行的是VC的函数，但是改变的是富商的状态。\r\ndelegatecall语法和call类似，也是：\r\n目标合约地址.delegatecall(二进制编码);\r\n其中二进制编码利用结构化编码函数abi.encodeWithSignature获得：\r\nabi.encodeWithSignature(\"函数签名\", 逗号分隔的具体参数)\r\n函数签名为\"函数名（逗号分隔的参数类型)\"。例如abi.encodeWithSignature(\"f(uint256,address)\", _x, _addr)。\r\n和call不一样，delegatecall在调用合约时可以指定交易发送的gas，但不能指定发送的ETH数额\r\n\r\n注意：delegatecall有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。\r\n\r\n什么情况下会用到delegatecall\r\n目前delegatecall主要有两个应用场景：\r\n\r\n代理合约（Proxy Contract）：将智能合约的存储合约和逻辑合约分开：代理合约（Proxy Contract）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（Logic Contract）里，通过delegatecall执行。当升级时，只需要将代理合约指向新的逻辑合约即可。\r\nEIP-2535\r\nDiamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合同的代理合同。\r\n\r\ndelegatecall例子\r\n调用结构：你（A）通过合约B调用目标合约C。\r\n被调用的合约C\r\n我们先写一个简单的目标合约C：有两个public变量：num和sender，分别是uint256和address类型；有一个函数，可以将num设定为传入的_num，并且将sender设为msg.sender。\r\n// 被调用的合约C\r\ncontract C {\r\n    uint public num;\r\n    address public sender;\r\n\r\n    function setVars(uint _num) public payable {\r\n        num = _num;\r\n        sender = msg.sender;\r\n    }\r\n}\r\n发起调用的合约B\r\n首先，合约B和目标合约C的变量存储布局必须相同，两个变量，并且顺序为num和sender\r\ncontract B {\r\n    uint public num;\r\n    address public sender;\r\n接下来，我们分别用call和delegatecall来调用合约C的setVars函数，更好的理解它们的区别。\r\ncallSetVars函数通过call来调用setVars。它有两个参数_addr和_num，分别对应合约C的地址和setVars的参数。\r\n    // 通过call来调用C的setVars()函数，将改变合约C里的状态变量\r\n    function callSetVars(address _addr, uint _num) external payable{\r\n        // call setVars()\r\n        (bool success, bytes memory data) = _addr.call(\r\n            abi.encodeWithSignature(\"setVars(uint256)\", _num)\r\n        );\r\n    }\r\n而delegatecallSetVars函数通过delegatecall来调用setVars。与上面的callSetVars函数相同，有两个参数_addr和_num，分别对应合约C的地址和setVars的参数。\r\n    // 通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量\r\n    function delegatecallSetVars(address _addr, uint _num) external payable{\r\n        // delegatecall setVars()\r\n        (bool success, bytes memory data) = _addr.delegatecall(\r\n            abi.encodeWithSignature(\"setVars(uint256)\", _num)\r\n        );\r\n    }\r\n}\r\n在remix上验证\r\n1.首先，我们把合约B和C都部署好\r\n\r\n2.部署之后，查看C合约状态变量的初始值，B合约的状态变量也是一样。\r\n\r\n3.此时，调用合约B中的callSetVars，传入参数为合约C地址和10\r\n\r\n4.运行后，合约C中的状态变量将被修改：num被改为10，sender变为合约B的地址\r\n\r\n5.接下来，我们调用合约B中的delegatecallSetVars，传入参数为合约C地址和100\r\n\r\n6.由于是delegatecall，语境为合约B。在运行后，合约B中的状态变量将被修改：num被改为100，sender变为你的钱包地址。合约C中的状态变量不会被修改。\r\n\r\n24.在合约中创建新合约\r\n在以太坊链上，用户（外部账户，EOA）可以创建智能合约，智能合约同样也可以创建新的智能合约。去中心化交易所uniswap就是利用工厂合约（Factory）创建了无数个币对合约（Pair）。这一讲，我会用简化版的uniswap讲如何通过合约创建合约。\r\ncreate和create2\r\n有两种方法可以在合约中创建新合约，create和create2，这里我们讲create，下一讲会介绍create2。\r\ncreate的用法很简单，就是new一个合约，并传入新合约构造函数所需的参数：\r\nContract x = new Contract{value: _value}(params)\r\n其中Contract是要创建的合约名，x是合约对象（地址），如果构造函数是payable，可以创建时转入_value数量的ETH，params是新合约构造函数的参数。\r\n极简Uniswap\r\nUniswap V2核心合约中包含两个合约：\r\n\r\nUniswapV2Pair: 币对合约，用于管理币对地址、流动性、买卖。\r\nUniswapV2Factory: 工厂合约，用于创建新的币对，并管理币对地址。\r\n\r\n下面我们用create方法实现一个极简版的Uniswap：Pair币对合约负责管理币对地址，PairFactory工厂合约用于创建新的币对，并管理币对地址。\r\nPair合约\r\ncontract Pair{\r\n    address public factory; // 工厂合约地址\r\n    address public token0; // 代币1\r\n    address public token1; // 代币2\r\n\r\n    constructor() payable {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    // called once by the factory at time of deployment\r\n    function initialize(address _token0, address _token1) external {\r\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n    }\r\n}\r\nPair合约很简单，包含3个状态变量：factory，token0和token1。\r\n构造函数constructor在部署时将factory赋值为工厂合约地址。initialize函数会在Pair合约创建的时候被工厂合约调用一次，将token0和token1更新为币对中两种代币的地址。\r\n\r\n提问：为什么uniswap不在constructor中将token0和token1地址更新好？\r\n答：因为uniswap使用的是create2创建合约，限制构造函数不能有参数。当使用create时，Pair合约允许构造函数有参数，可以在constructor中将token0和token1地址更新好。\r\n\r\nPairFactory\r\ncontract PairFactory{\r\n    mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址\r\n    address[] public allPairs; // 保存所有Pair地址\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pairAddr) {\r\n        // 创建新合约\r\n        Pair pair = new Pair(); \r\n        // 调用新合约的initialize方法\r\n        pair.initialize(tokenA, tokenB);\r\n        // 更新地址map\r\n        pairAddr = address(pair);\r\n        allPairs.push(pairAddr);\r\n        getPair[tokenA][tokenB] = pairAddr;\r\n        getPair[tokenB][tokenA] = pairAddr;\r\n    }\r\n}\r\n工厂合约（PairFactory）有两个状态变量getPair是两个代币地址到币对地址的map，方便根据代币找到币对地址；allPairs是币对地址的数组，存储了所有代币地址。\r\nPairFactory合约只有一个createPair函数，根据输入的两个代币地址tokenA和tokenB来创建新的Pair合约。其中\r\n    Pair pair = new Pair(); \r\n就是创建合约的代码，非常简单。大家可以部署好PairFactory合约，然后用下面两个地址作为参数调用createPair，看看创建的币对地址是什么：\r\nWBNB地址: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78\r\nBSC链上的PEOPLE地址:\r\n0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\r\n在remix上验证\r\n1.使用WBNB和PEOPLE的地址作为参数调用createPair,得到Pair合约地址：0xD3e2008b4Da2cD6DEAF73471590fF30C86778A48\r\n\r\n（刚开始没整出来，加个步骤，复制得到的Pair合约地址，放到At Address里面，同时上面部署合约要改回Pair,点击At Address得到合约）\r\n\r\n2.查看Pair合约变量\r\n\r\n3.Debug查看create操作码\r\n\r\n25.Create2\r\nCREATE2\r\n操作码使我们在智能合约部署在以太坊网络之前就能预测合约的地址。Uniswap创建Pair合约用的就是CREATE2而不是CREATE。\r\nCreate如何计算地址\r\n智能合约可以由其他合约和普通账户利用CREATE操作码创建。\r\n在这两种情况下，新合约的地址都以相同的方式计算：创建者的地址(通常为部署的钱包地址或者合约地址)和nonce(该地址发送交易的总数,对于合约账户是创建的合约总数,每创建一个合约nonce+1))的哈希。\r\n新地址 = hash(创建者地址, nonce)\r\n创建者地址不会变，但nonce可能会随时间而改变，因此用CREATE创建的合约地址不好预测。\r\nCreate2如何计算地址\r\nCREATE2的目的是为了让合约地址独立于未来的事件。不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上。用CREATE2创建的合约地址由4个部分决定：\r\n\r\n0xFF：一个常数，避免和CREATE冲突\r\n创建者地址\r\nsalt（盐）：一个创建者给定的数值\r\n待部署合约的字节码（bytecode）\r\n\r\n新地址 = hash(\"0xFF\",创建者地址, salt, bytecode)\r\nCREATE2 确保，如果创建者使用 CREATE2\r\n和提供的 salt\r\n部署给定的合约bytecode，它将存储在 新地址\r\n中。\r\n如何使用Create2\r\nCREATE2的用法和之前讲的Create类似，同样是new一个合约，并传入新合约构造函数所需的参数，只不过要多传一个salt参数：\r\nContract x = new Contract{salt: _salt, value: _value}(params)\r\n其中Contract是要创建的合约名，x是合约对象（地址），_salt是指定的盐；如果构造函数是payable，可以创建时转入_value数量的ETH，params是新合约构造函数的参数。\r\n极简Uniswap2\r\nPair\r\ncontract Pair{\r\n    address public factory; // 工厂合约地址\r\n    address public token0; // 代币1\r\n    address public token1; // 代币2\r\n\r\n    constructor() payable {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    // called once by the factory at time of deployment\r\n    function initialize(address _token0, address _token1) external {\r\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n    }\r\n}\r\nPair合约很简单，包含3个状态变量：factory，token0和token1。\r\n构造函数constructor在部署时将factory赋值为工厂合约地址。initialize函数会在Pair合约创建的时候被工厂合约调用一次，将token0和token1更新为币对中两种代币的地址。\r\nPairFactory2\r\ncontract PairFactory2{\r\n        mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址\r\n        address[] public allPairs; // 保存所有Pair地址\r\n\r\n        function createPair2(address tokenA, address tokenB) external returns (address pairAddr) {\r\n            require(tokenA != tokenB, 'IDENTICAL_ADDRESSES'); //避免tokenA和tokenB相同产生的冲突\r\n            // 计算用tokenA和tokenB地址计算salt\r\n            (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序\r\n            bytes32 salt = keccak256(abi.encodePacked(token0, token1));\r\n            // 用create2部署新合约\r\n            Pair pair = new Pair{salt: salt}(); \r\n            // 调用新合约的initialize方法\r\n            pair.initialize(tokenA, tokenB);\r\n            // 更新地址map\r\n            pairAddr = address(pair);\r\n            allPairs.push(pairAddr);\r\n            getPair[tokenA][tokenB] = pairAddr;\r\n            getPair[tokenB][tokenA] = pairAddr;\r\n        }\r\n    }\r\n工厂合约（PairFactory2）有两个状态变量getPair是两个代币地址到币对地址的map，方便根据代币找到币对地址；allPairs是币对地址的数组，存储了所有币对地址。\r\nPairFactory2合约只有一个createPair2函数，使用CREATE2根据输入的两个代币地址tokenA和tokenB来创建新的Pair合约。其中\r\n    Pair pair = new Pair{salt: salt}(); \r\n就是利用CREATE2创建合约的代码，非常简单，而salt为token1和token2的hash：\r\n            bytes32 salt = keccak256(abi.encodePacked(token0, token1));\r\n事先计算Pair地址\r\n        // 提前计算pair合约地址\r\n        function calculateAddr(address tokenA, address tokenB) public view returns(address predictedAddress){\r\n            require(tokenA != tokenB, 'IDENTICAL_ADDRESSES'); //避免tokenA和tokenB相同产生的冲突\r\n            // 计算用tokenA和tokenB地址计算salt\r\n            (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序\r\n            bytes32 salt = keccak256(abi.encodePacked(token0, token1));\r\n            // 计算合约地址方法 hash()\r\n            predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(\r\n                bytes1(0xff),\r\n                address(this),\r\n                salt,\r\n                keccak256(type(Pair).creationCode)\r\n            )))));\r\n        }\r\n我们写了一个calculateAddr函数来事先计算tokenA和tokenB将会生成的Pair地址。通过它，我们可以验证我们事先计算的地址和实际地址是否相同。\r\n大家可以部署好PairFactory2合约，然后用下面两个地址作为参数调用createPair2，看看创建的币对地址是什么，是否与事先计算的地址一样：\r\nWBNB地址: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78\r\nBSC链上的PEOPLE地址:\r\n0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\r\n在remix上验证\r\n\r\n首先用WBNB和PEOPLE的地址哈希作为salt来计算出Pair合约的地址\r\n调用PairFactory2.createPair2传入参数为WBNB和PEOPLE的地址，获取出创建的pair合约地址\r\n对比合约地址\r\n\r\n\r\ncreate2的实际应用场景\r\n\r\n交易所为新用户预留创建钱包合约地址。\r\n由 CREATE2 驱动的 factory\r\n合约，在uniswapV2中交易对的创建是在\r\nFactory中调用create2完成。这样做的好处是:\r\n它可以得到一个确定的pair地址, 使得\r\nRouter中就可以通过 (tokenA, tokenB)\r\n计算出pair地址, 不再需要执行一次\r\nFactory.getPair(tokenA, tokenB) 的跨合约调用。\r\n\r\n26.删除合约\r\nselfdestruct\r\nselfdestruct命令可以用来删除智能合约，并将该合约剩余ETH转到指定地址。selfdestruct是为了应对合约出错的极端情况而设计的。它最早被命名为suicide（自杀），但是这个词太敏感。为了保护抑郁的程序员，改名为selfdestruct。\r\n如何使用selfdestruct\r\nselfdestruct使用起来非常简单：\r\nselfdestruct(_addr)；\r\n其中_addr是接收合约中剩余ETH的地址。\r\n例子\r\ncontract DeleteContract {\r\n\r\n    uint public value = 10;\r\n\r\n    constructor() payable {}\r\n\r\n    receive() external payable {}\r\n\r\n    function deleteContract() external {\r\n        // 调用selfdestruct销毁合约，并把剩余的ETH转给msg.sender\r\n        selfdestruct(payable(msg.sender));\r\n    }\r\n\r\n    function getBalance() external view returns(uint balance){\r\n        balance = address(this).balance;\r\n    }\r\n}\r\n在DeleteContract合约中，我们写了一个public状态变量value，两个函数：getBalance()用于获取合约ETH余额，deleteContract()用于自毁合约，并把ETH转入给发起人。\r\n部署好合约后，我们向DeleteContract合约转入1\r\nETH。这时，getBalance()会返回1\r\nETH，value变量是10。\r\n当我们调用deleteContract()函数，合约将自毁，所有变量都清空，此时value变为默认值0，getBalance()也返回空值。\r\n注意事项\r\n\r\n对外提供合约销毁接口时，最好设置为只有合约所有者可以调用，可以使用函数修饰符onlyOwner进行函数声明。\r\n当合约被销毁后与智能合约的交互也能成功，并且返回0。\r\n当合约中有selfdestruct功能时常常会带来安全问题和信任问题，合约中的Selfdestruct功能会为攻击者打开攻击向量(例如使用selfdestruct向一个合约频繁转入token进行攻击，这将大大节省了GAS的费用，虽然很少人这么做)，此外，此功能还会降低用户对合约的信心。\r\n\r\n27.ABI编码解码\r\nABI (Application Binary\r\nInterface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。\r\nSolidity中，ABI编码有4个函数：abi.encode,\r\nabi.encodePacked, abi.encodeWithSignature,\r\nabi.encodeWithSelector。而ABI解码有1个函数：abi.decode，用于解码abi.encode的数据。\r\nABI编码\r\n我们将用编码4个变量，他们的类型分别是uint256,\r\naddress, string, uint256[2]：\r\n    uint x = 10;\r\n    address addr = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;\r\n    string name = \"0xAA\";\r\n    uint[2] array = [5, 6]; \r\nabi.encode\r\n将给定参数利用ABI规则编码。ABI被设计出来跟智能合约交互，他将每个参数填充为32字节的数据，并拼接在一起。如果你要和合约交互，你要用的就是abi.encode。\r\n    function encode() public view returns(bytes memory result) {\r\n        result = abi.encode(x, addr, name, array);\r\n    }\r\n编码的结果为0x000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000，由于abi.encode将每个数据都填充为32字节，中间有很多0。\r\nabi.encodePacked\r\n将给定参数根据其所需最低空间编码。它类似\r\nabi.encode，但是会把其中填充的很多0省略。比如，只用1字节来编码uint类型。当你想省空间，并且不与合约交互的时候，可以使用abi.encodePacked，例如算一些数据的hash时。\r\n    function encodePacked() public view returns(bytes memory result) {\r\n        result = abi.encodePacked(x, addr, name, array);\r\n    }\r\n编码的结果为0x000000000000000000000000000000000000000000000000000000000000000a7a58c0be72be218b41c608b7fe7c5bb630736c713078414100000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006，由于abi.encodePacked对编码进行了压缩，长度比abi.encode短很多。\r\nabi.encodeWithSignature\r\n与abi.encode功能类似，只不过第一个参数为函数签名，比如\"foo(uint256,address)\"。当调用其他合约的时候可以使用。\r\n    function encodeWithSignature() public view returns(bytes memory result) {\r\n        result = abi.encodeWithSignature(\"foo(uint256,address,string,uint256[2])\", x, addr, name, array);\r\n    }\r\n编码的结果为0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000，等同于在abi.encode编码结果前加上了4字节的函数选择器说明。\r\n说明:\r\n函数选择器就是通过函数名和参数进行签名处理(Keccak–Sha3)来标识函数，可以用于不同合约之间的函数调用\r\nabi.encodeWithSelector\r\n与abi.encodeWithSignature功能类似，只不过第一个参数为函数选择器，为函数签名Keccak哈希的前4个字节。\r\n    function encodeWithSelector() public view returns(bytes memory result) {\r\n        result = abi.encodeWithSelector(bytes4(keccak256(\"foo(uint256,address,string,uint256[2])\")), x, addr, name, array);\r\n    }\r\n编码的结果为0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000，与abi.encodeWithSignature结果一样。\r\nABI解码\r\nabi.decode\r\nabi.decode用于解码abi.encode生成的二进制编码，将它还原成原本的参数。\r\n    function decode(bytes memory data) public pure returns(uint dx, address daddr, string memory dname, uint[2] memory darray) {\r\n        (dx, daddr, dname, darray) = abi.decode(data, (uint, address, string, uint[2]));\r\n    }\r\n我们将abi.encode的二进制编码输入给decode，将解码出原来的参数：\r\n\r\nABI的使用场景\r\n1.在合约开发中，ABI常配合call来实现对合约的底层调用。\r\n    bytes4 selector = contract.getValue.selector;\r\n\r\n    bytes memory data = abi.encodeWithSelector(selector, _x);\r\n    (bool success, bytes memory returnedData) = address(contract).staticcall(data);\r\n    require(success);\r\n\r\n    return abi.decode(returnedData, (uint256));\r\n2.ethers.js中常用ABI实现合约的导入和函数调用。\r\n    const wavePortalContract = new ethers.Contract(contractAddress, contractABI, signer);\r\n    /*\r\n        * Call the getAllWaves method from your Smart Contract\r\n        */\r\n    const waves = await wavePortalContract.getAllWaves();\r\n3.对不开源合约进行反编译后，某些函数无法查到函数签名，可通过ABI进行调用。\r\n\r\n0x533ba33a()\r\n是一个反编译后显示的函数，只有函数编码后的结果，并且无法查到函数签名\r\n\r\n这种情况无法通过构造interface接口或contract来进行调用\r\n\r\n\r\n这种情况下，就可以通过ABI函数选择器来调用\r\n    bytes memory data = abi.encodeWithSelector(bytes4(0x533ba33a));\r\n\r\n    (bool success, bytes memory returnedData) = address(contract).staticcall(data);\r\n    require(success);\r\n\r\n    return abi.decode(returnedData, (uint256));\r\n28.Hash\r\n哈希函数（hash\r\nfunction）是一个密码学概念，它可以将任意长度的消息转换为一个固定长度的值，这个值也称作哈希（hash）。\r\nHash的性质\r\n一个好的哈希函数应该具有以下几个特性：\r\n\r\n单向性：从输入的消息到它的哈希的正向运算简单且唯一确定，而反过来非常难，只能靠暴力枚举。\r\n灵敏性：输入的消息改变一点对它的哈希改变很大。\r\n高效性：从输入的消息到哈希的运算高效。\r\n均一性：每个哈希值被取到的概率应该基本相等。\r\n抗碰撞性：\r\n\r\n弱抗碰撞性：给定一个消息x，找到另一个消息x'使得hash(x) = hash(x')是困难的。\r\n强抗碰撞性：找到任意x和x'，使得hash(x) = hash(x')是困难的。\r\n\r\n\r\nHash的应用\r\n\r\n生成数据唯一标识\r\n加密签名\r\n安全加密\r\n\r\nKeccak256\r\nKeccak256函数是solidity中最常用的哈希函数，用法非常简单：\r\n哈希 = keccak256(数据);\r\nKeccak256和sha3\r\n\r\nsha3由keccak标准化而来，在很多场合下Keccak和SHA3是同义词，但在2015年8月SHA3最终完成标准化时，NIST调整了填充算法。所以SHA3就和keccak计算的结果不一样，这点在实际开发中要注意。\r\n以太坊在开发的时候sha3还在标准化中，所以采用了keccak，所以Ethereum和Solidity智能合约代码中的SHA3是指Keccak256，而不是标准的NIST-SHA3，为了避免混淆，直接在合约代码中写成Keccak256是最清晰的。\r\n\r\n生成数据唯一标志\r\n我们可以利用keccak256来生成一些数据的唯一标识。比如我们有几个不同类型的数据：uint，string，address，我们可以先用abi.encodePacked方法将他们打包编码，然后再用keccak256来生成唯一标识：\r\n    function hash(\r\n        uint _num,\r\n        string memory _string,\r\n        address _addr\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_num, _string, _addr));\r\n    }\r\n弱抗碰撞性\r\n我们用keccak256演示一下之前讲到的弱抗碰撞性，即给定一个消息x，找到另一个消息x'使得hash(x) = hash(x')是困难的。\r\n我们给定一个消息0xAA，试图去找另一个消息，使得它们的哈希值相等：\r\n    // 弱抗碰撞性\r\n    function weak(\r\n        string memory string1\r\n    )public view returns (bool){\r\n        return keccak256(abi.encodePacked(string1)) == _msg;\r\n    }\r\n（大家可以试个10次，看看能不能幸运的碰撞上。）\r\n强抗碰撞性\r\n我们用keccak256演示一下之前讲到的强抗碰撞性，即找到任意不同的x和x'，使得hash(x) = hash(x')是困难的。\r\n我们构造一个函数strong，接收两个不同的string参数string1和string2，然后判断它们的哈希是否相同：\r\n    // 强抗碰撞性\r\n    function strong(\r\n        string memory string1,\r\n        string memory string2\r\n    )public pure returns (bool){\r\n        return keccak256(abi.encodePacked(string1)) == keccak256(abi.encodePacked(string2));\r\n    }\r\n（大家可以试个10次，看看能不能幸运的碰撞上。）\r\n29.选择器\r\nselector\r\n当我们调用智能合约时，本质上是向目标合约发送了一段calldata，在remix中发送一次交易后，可以在详细信息中看见input即为此次交易的calldata\r\n\r\n发送的calldata中前4个字节是selector（函数选择器）。\r\nmsg.data\r\nmsg.data是solidity中的一个全局变量，值为完整的calldata（调用函数时传入的数据）。\r\n在下面的代码中，我们可以通过Log事件来输出调用mint函数的calldata：\r\n    // event 返回msg.data\r\n    event Log(bytes data);\r\n\r\n    function mint(address to) external{\r\n        emit Log(msg.data);\r\n    }\r\n当参数为0x2c44b726ADF1963cA47Af88B284C06f30380fC78时，输出的calldata为\r\n0x6a6278420000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78\r\n这段很乱的字节码可以分成两部分：\r\n前4个字节为函数选择器selector：\r\n0x6a627842\r\n\r\n后面32个字节为输入的参数：\r\n0x0000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78\r\n其实calldata就是告诉智能合约，我要调用哪个函数，以及参数是什么。\r\nmethod id、selector和函数签名\r\nmethod id定义为函数签名的Keccak哈希后的前4个字节，当selector与method id相匹配时，即表示调用该函数，那么函数签名是什么？\r\n其实在第21讲中，我们简单介绍了函数签名，为\"函数名（逗号分隔的参数类型)\"。举个例子，上面代码中mint的函数签名为\"mint(address)\"。在同一个智能合约中，不同的函数有不同的函数签名，因此我们可以通过函数签名来确定要调用哪个函数。\r\n注意：在函数签名中，uint和int要写为uint256和int256。\r\n我们写一个函数，来验证mint函数的method id是否为0x6a627842。大家可以运行下面的函数，看看结果。\r\n    function mintSelector() external pure returns(bytes4 mSelector){\r\n        return bytes4(keccak256(\"mint(address)\"));\r\n    }\r\n结果正是0x6a627842：\r\n\r\n使用selector\r\n我们可以利用selector来调用目标函数。例如我想调用mint函数，我只需要利用abi.encodeWithSelector将mint函数的method id作为selector和参数打包编码，传给call函数：\r\n    function callWithSignature() external returns(bool, bytes memory){\r\n        (bool success, bytes memory data) = address(this).call(abi.encodeWithSelector(0x6a627842, \"0x2c44b726ADF1963cA47Af88B284C06f30380fC78\"));\r\n        return(success, data);\r\n    }\r\n在日志中，我们可以看到mint函数被成功调用，并输出Log事件。\r\n\r\n30.Try Catch\r\ntry-catch是现代编程语言几乎都有的处理异常的一种标准方式，solidity0.6版本也添加了它。\r\ntry-catch\r\n在solidity中，try-catch只能被用于external函数或创建合约时constructor（被视为external函数）的调用。基本语法如下：\r\n        try externalContract.f() {\r\n            // call成功的情况下 运行一些代码\r\n        } catch {\r\n            // call失败的情况下 运行一些代码\r\n        }\r\n其中externalContract.f()是某个外部合约的函数调用，try模块在调用成功的情况下运行，而catch模块则在调用失败时运行。\r\n同样可以使用this.f()来替代externalContract.f()，this.f()也被视作为外部调用，但不可在构造函数中使用，因为此时合约还未创建。\r\n如果调用的函数有返回值，那么必须在try之后声明returns(returnType val)，并且在try模块中可以使用返回的变量；如果是创建合约，那么返回值是新创建的合约变量。\r\n        try externalContract.f() returns(returnType val){\r\n            // call成功的情况下 运行一些代码\r\n        } catch {\r\n            // call失败的情况下 运行一些代码\r\n        }\r\n另外，catch模块支持捕获特殊的异常原因：\r\n        try externalContract.f() returns(returnType){\r\n            // call成功的情况下 运行一些代码\r\n        } catch Error(string memory reason) {\r\n            // 捕获失败的 revert() 和 require()\r\n        } catch (bytes memory reason) {\r\n            // 捕获失败的 assert()\r\n        }\r\ntry-catch实战\r\nonlyEven\r\n我们创建一个外部合约OnlyEven，并使用try-catch来处理异常：\r\ncontract OnlyEven{\r\n    constructor(uint a){\r\n        require(a != 0, \"invalid number\");\r\n        assert(a != 1);\r\n    }\r\n\r\n    function onlyEven(uint256 b) external pure returns(bool success){\r\n        // 输入奇数时revert\r\n        require(b % 2 == 0, \"Ups! Reverting\");\r\n        success = true;\r\n    }\r\n}\r\nOnlyEven合约包含一个构造函数和一个onlyEven函数。\r\n\r\n构造函数有一个参数a，当a=0时，require会抛出异常；当a=1时，assert会抛出异常；其他情况均正常。\r\nonlyEven函数有一个参数b，当b为奇数时，require会抛出异常。\r\n\r\n处理外部函数调用异常\r\n首先，在TryCatch合约中定义一些事件和状态变量：\r\n    // 成功event\r\n    event SuccessEvent();\r\n\r\n    // 失败event\r\n    event CatchEvent(string message);\r\n    event CatchByte(bytes data);\r\n\r\n    // 声明OnlyEven合约变量\r\n    OnlyEven even;\r\n\r\n    constructor() {\r\n        even = new OnlyEven(2);\r\n    }\r\nSuccessEvent是调用成功会释放的事件，而CatchEvent和CatchByte是抛出异常时会释放的事件，分别对应require/revert和assert异常的情况。even是个OnlyEven合约类型的状态变量。\r\n然后我们在execute函数中使用try-catch处理调用外部函数onlyEven中的异常：\r\n    // 在external call中使用try-catch\r\n    function execute(uint amount) external returns (bool success) {\r\n        try even.onlyEven(amount) returns(bool _success){\r\n            // call成功的情况下\r\n            emit SuccessEvent();\r\n            return _success;\r\n        } catch Error(string memory reason){\r\n            // call不成功的情况下\r\n            emit CatchEvent(reason);\r\n        }\r\n    }\r\n","slug":"solidity进阶","date":"2022-12-07T15:23:57.000Z","categories_index":"","tags_index":"solidity","author_index":"cocoZ"},{"id":"3b889475d55359c53070293a35d903d7","title":"solidity入门","content":"solidity\r\n1.入门\r\n// SPDX-License-Identifier: MIT             //这个代码所用的软件许可，如果不写许可，编译时会警告\r\npragma solidity ^0.8.4;             //声明源文件所用的solidity版本\r\ncontract HelloWeb3{             //创建合约（contract），并声明合约名字为Helloweb3\r\n    string public _string = \"Hello Web3!\";      //合约的内容，声明了一个string（字符串）变量_string，并赋值\r\n}\r\n2.数值类型\r\n数值类型\r\n1.布尔型：二值变量，取值为** true或false**\r\nbool public  _bool = true;\r\n布尔值的运算符：！（逻辑非）、&amp;&amp;（逻辑与）、||（逻辑或）、==（等于）、！=（不等于）\r\n2.整型：\r\nint public _int = -1;           //整数，包括负数\r\nuint public _uint = 1;          //正整数\r\nuint256 public _number = 20220330;       //256位正整数\r\nuint public _coco1 =2**4;       //求指数2^4=16\r\nbool public _numberbool = _Uint &gt; _int;     //比大小\r\n3.地址类型：\r\n存储一个20字节的值（以太坊地址的大小）。\r\n地址类型也由成员变量，并作为所有合约的基础。\r\n地址类型分为普通的地址和可以转账ETH的地址（payable）\r\npayable的地址拥有balance和transfer（）两个成员，方便查询ETH余额以及转账。\r\naddress public _address =0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;\r\naddress payable public _address1 = payable(_address);       //payable address可以转账、查余额\r\nuint256 public balance = _address1.balance;  //address1的余额\r\n4.定长字节数组：\r\n字节数组bytes分为定长（byte,bytes8，bytes32）和不定长。（定长的属于数值类型，不定长的属于引用类型）\r\n定长byte可以存一些数据，消耗gas比较少\r\nbytes32 public _byte32 = \"Minisolidity\";        //Minisolidity变量以字节的方式存储进变量_byte32，转换成16进制为：0x4d696e69536f6c69646974790000000000000000000000000000000000000000\r\nbytes1 public _byte = _byte32[0];       //_byte变量存储_byte32的第一个字节，为0x4d\r\nTip：byte是bytes1的别名\r\n\r\n（Q:为啥每个元素会浪费31字节？)\r\n5.枚举enum\r\n枚举是solidity中用户定义的数据类型，主要为uint分配名称，使程序易于阅读和维护（参考c语言）\r\nenum ActionSet{Buy,hold,Sell}       //用enum将unit 0， 1， 2表示为Buy, Hold, Sell\r\nActionSet action = ActionSet.Buy;   //创建enum变量action\r\n\r\n（Q:这段话有点看不懂，啥叫显式的和uint相互转换？然后检查是怎么检查的？)\r\n\r\nemmmmm，懂了，我觉得就是数组名称和数组索引的转换，检查是自动会检查的，如果不在长度内会报错\r\n3.函数类型\r\n函数\r\n    function &lt;function name&gt;(&lt;parameter types&gt;) {internal|external|public|private} [pure|view|payable] [returns (&lt;return types&gt;)]\r\n    function 函数名(输入到函数的变量类型和名字) 函数可见性说明符 决定函数权限/功能的关键字 returns(函数返回的变量类型和名称)\r\n1.function：声明函数的关键字\r\n2.&lt;function name&gt;：函数名\r\n3.(&lt;parameter types&gt;)：函数的参数，变量类型+变量名\r\n4.{internal|external|public|private}：函数可见性说明符，一共4种（没标明函数类型的，默认internal）\r\n\r\npublic：内部外部都可见（也可以用于修饰状态变量，public变量会自动生成getter函数，用于查询数据）\r\nprivate：只能从合约内部访问，继承的合约也不能用（也可用于修饰状态变量）\r\nexternal：只能从合约外部访问（但是可以用this.f()来调用，f是函数名）\r\ninternal：只能从合约内部访问，继承的合约可以用（也可以用于修饰状态变量）\r\n5.[pure|view|payable]：决定函数权限/功能的关键字。（payable运行时可以给合约转入ETH）\r\n6.[returns()]：函数返回的变量类型和名称\r\n\r\n\r\neg: function getData() external view returns(uint256) {\r\n         return data;\r\n     } \r\n关于pure和view\r\n在合约里面定义一个状态变量number=5\r\n// SPDX-License-Indentifier:MIT\r\npragma solidity ^0.8.4;\r\ncontract FunctionTypes{\r\nuint256 public number=5;\r\n定义一个add()函数，每次调用，每次给number+1\r\n//默认\r\nfunction add() external{\r\nnumber=number+1;\r\n}\r\n如果add()包含了pure关键字，例如function add() pure external，就会报错。pure没有权限读取合约的相关变量，更没有权限改写。\r\npure函数能干啥捏？(pure：纯纯牛马emmmmm)\r\neg：可以给函数传递一个参数_number，然后让他返回_number+1\r\nfunction addPure(uint256 _number) external pure returns(uint256 new_number){\r\nnew_number=_number+1;\r\n}\r\n\r\n如图，在_number位置传入一个参数7，就会执行函数，得到输出结果为8\r\n如果add()包含view，比如function add() view external也会报错。因为view能读取，但是不能够改写状态变量。可以稍微改一下，让其不改写number，而是返回一个新的变量。(view：看客)\r\nuint public number=1;\r\nfunction addView() external view returns(uint256 new_number){\r\nnew_number=number+1;\r\n}\r\n\r\n点击addView这个函数就会直接读取number=5，直接输出number3=6\r\n（Q:遇到一个问题，就是这样子写报错了，addView函数里面写uint256\r\nnumber=5也会报错，我觉得是因为view只有读取的权限没有写入的权限，是嘛是嘛？？？）\r\n\r\n\r\n为什么引入pure和view关键字\r\nsolidity引入pure和view关键字主要是为了节省gas和控制函数权限：如果用户直接调用pure/view方程是不消耗gas的（合约中非pure/gas函数调用它们则会改写链上状态，需要付gas）\r\n关于internal和external\r\n（Q：我自己问出了一个很蠢的问题：怎么区分合约内部和外部）\r\n我思考了一下，还是要回到1入门那边，最开始学习到的创建一个合约\r\n\r\n所以我知道怎么区分了（所以我是pure，纯纯牛马一个\r\n//internal:内部\r\nfunction minus() internal{\r\nnumber=number-1;\r\n}\r\n//合约内的函数可以调用内部函数\r\nfunction minusCall() external(){\r\nminus();\r\n}\r\n定义一个internal的minus()函数，每次调用使number-1。由于是internal，只能从合约内部调用，不能从外部。因此，还要再定义一个external的minusCall()函数，来直接调用内部的minus()\r\n\r\n图片里面只能看到minus222（）看不到minus（）这样子\r\n（Tip：我的理解是internal有像把函数写进合约内部，然后external是写在外部，直接调用即可。)（这样子理解有问题否？？？？？\r\npayable\r\n//payable：递钱，能给合约支付ETH的函数\r\nfunction minusPayable() external payable returns(uint256 balance){\r\nminus();\r\nbalance=address(this).balance;\r\n}\r\n定义一个external payable的minusPayable()函数，间接的调用minus()，并且返回合约里的ETH余额（this关键字可以让我们引用合约地址）\r\n我们可以再调用minusPayable()时，往合约里转入1个ETH\r\n\r\n是这样的，可以在左下角看到余额balance：1ETH\r\n\r\n4.函数输出return\r\n返回值return和returns\r\nreturn和returns这两个关键字与函数输出相关。区别在于：\r\n\r\nreturns加在函数名后面，用于声明返回的变量类型及变量名；\r\nreturns用于函数主体中，返回指定的变量。\r\n\r\n//返回多个变量\r\nfunction returnMultiple() public pure returns(uint256,bool,uint256[3] memory){\r\nreturn(1,true,[uint256(1),2,5]);\r\n}\r\n声明了returnMultiple()函数将有多个输出：returns(uint256,bool,uint256[3] memory)，接着在函数的主体中用return(1,true,[uint256(1),2,5])确定了返回值\r\n命名式返回\r\n我们可以在returns中\r\n标明返回变量的名称，这样solidity会自动给这些变量初始化，并且自动返回这些函数的值，不需要加return\r\n    // 返回多个变量\r\n    function returnMultiple() public pure returns(uint256, bool, uint256[3] memory){\r\n            return(1, true, [uint256(1),2,5]);\r\n        }\r\n改为\r\n    // 命名式返回\r\n    function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){\r\n        _number = 2;\r\n        _bool = false; \r\n        _array = [uint256(3),2,1];\r\n    }\r\nTip:也可以在命名式返回中用return来返回变量，跟第一种一样\r\n解构式赋值\r\n\r\n读取所有返回值：声明变量，并且将要赋值的变量用,隔开，按顺序排列。\r\n\r\n        uint256 _number;\r\n        bool _bool;\r\n        uint256[3] memory _array;\r\n        (_number, _bool, _array) = returnNamed();\r\n\r\n读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。下面这段代码中，我们只读取_bool，而不读取返回的_number和_array：\r\n\r\n        (, _bool2, ) = returnNamed();\r\n5.变量数据存储和作用域\r\n引用类型(Reference Type)\r\n数组(array)、结构体(struct)和映射(mapping)，这类变量占空间大，赋值时候直接传递地址（类似指针）。由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明数据存储的位置。\r\n数据位置\r\nstorage、memory和calldata。\r\n不同存储位置的gas成本不同：\r\nstorage类型的数据存在链上，类似计算机的硬盘，消耗gas多；\r\nmemory和calldata类型的临时存在内存里，消耗gas少。\r\n\r\nstorage：合约里的状态变量默认都是storage，存储在链上。\r\nmemory：函数里的参数和临时变量一般用memory，存储在内存中，不上链。\r\ncalldata：和memory类似，存储在内存中，不上链。与memory的不同点在于calldata变量不能修改（immutable），一般用于函数的参数。eg：\r\n\r\n    function fCalldata(uint[] calldata _x) public pure returns(uint[] calldata){\r\n        //参数为calldata数组，不能被修改\r\n        // _x[0] = 0 //这样修改会报错\r\n        return(_x);\r\n    }\r\n赋值规则\r\n在不同存储类型相互赋值时候，有时会产生独立的副本（修改新变量不会影响原变量），有时会产生引用（修改新变量会影响原变量）。规则如下：\r\n\r\nstorage（合约的状态变量）赋值给本地storage（函数里的）时候，会创建引用，改变新变量会影响原变量。eg：\r\n\r\n    uint[] x = [1,2,3]; // 状态变量：数组 x\r\n\r\n    function fStorage() public{\r\n        //声明一个storage的变量 xStorage，指向x。修改xStorage也会影响x\r\n        uint[] storage xStorage = x;\r\n        xStorage[0] = 100;\r\n    }\r\n\r\nstorage赋值给memory，会创建独立的复本，修改其中一个不会影响另一个；反之亦然。\r\n\r\n    uint[] x = [1,2,3]; // 状态变量：数组 x\r\n    \r\n    function fMemory() public view{\r\n        //声明一个Memory的变量xMemory，复制x。修改xMemory不会影响x\r\n        uint[] memory xMemory = x;\r\n        xMemory[0] = 100;\r\n        xMemory[1] = 200;\r\n        uint[] memory xMemory2 = x;\r\n        xMemory2[0] = 300;\r\n    }\r\ndebug康康\r\n\r\n\r\n\r\nmemory赋值给memory，会创建引用，改变新变量会影响原变量\r\n其他情况，变量赋值给storage，会创建独立的复本，修改其中一个不会影响另一个\r\n\r\n作用域\r\n\r\n状态变量\r\n数据存储在链上的变量，所有的合约内的函数都可以访问，gas消耗高。状态变量在合约内、函数外声明（可以在函数里更改状态变量的值）\r\n局部变量\r\n局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，gas低。局部变量在函数内声明\r\n\r\n    function bar() external pure returns(uint){\r\n        uint xx = 1;\r\n        uint yy = 3;\r\n        uint zz = xx + yy;\r\n        return(zz);\r\n    }\r\n\r\n全局变量\r\n全局变量是全局范围工作的变量，都是solidity预留关键字（可以在函数内不声明直接使用）\r\n\r\n    function global() external view returns(address, uint, bytes memory){\r\n        address sender = msg.sender;\r\n        uint blockNum = block.number;\r\n        bytes memory data = msg.data;\r\n        return(sender, blockNum, data);\r\n    }\r\n\r\n6.引用类型\r\n数组array\r\n数组（Array）是solidity常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）\r\n\r\n固定长度数组：在声明时指定数组的长度。用T[k]的格式表明，其中T是元素的类型，k是长度，eg:\r\n\r\n    // 固定长度 Array\r\n    uint[8] array1;\r\n    bytes1[5] array2;\r\n    address[100] array3;\r\n\r\n可变长度数组（动态数组）：在声明时不指定数值的长度。用T[]的格式表明，其中T是元素的类型（bytes比较特殊，是数组，但是不加[]），eg：\r\n\r\n    // 可变长度 Array\r\n    uint[] array4;\r\n    bytes1[] array5;\r\n    address[] array6;\r\n    bytes array7;\r\n创建数组的规则\r\n\r\n对于memory修饰的动态数组，可以用new操作符来创建，但是必须声明长度，并且声明后长度不能改变，eg：\r\n\r\n    // memory动态数组\r\n    uint[] memory array8 = new uint[](5);\r\n    bytes memory array9 = new bytes(9);\r\n\r\n数组字面常数（Array\r\nLiterals）是写作表达形式的数组，用方括号包着来初始化array的一种方式，并且里面每一个元素的type是以第一个元素为准的，例如[1,2,3]里面所有的元素都是uint8类型，因为在solidity中如果一个值没有指定type的话，默认就是最小单位的该type，这里int的默认最小单位类型就是uint8。而[uint(1),2,3]里面的元素都是uint类型，因为第一个元素指定了是uint类型了，我们都以第一个元素为准。下面的合约中，对于f函数里面的调用，如果我们没有显式对第一个元素进行uint强转的话，是会报错的，因为如上所述我们其实是传入了uint8类型的array，可是g函数需要的却是uint类型的array，就会报错了。\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\npragma solidity &gt;=0.4.16 &lt;0.9.0;\r\ncontract C {\r\n    function f() public pure {\r\n        g([uint(1), 2, 3]);  //uint(1)强转了。如果是g([1,2,3]),就是uint8类型\r\n    }\r\n    function g(uint[3] memory) public pure {    //g()这边传入的是uint类型\r\n        // ...\r\n    }\r\n}\r\n\r\n如果创建的是动态数组，你需要一个一个元素的赋值。\r\n\r\n    uint[] memory x = new uint[](3);\r\n    x[0] = 1;\r\n    x[1] = 3;\r\n    x[2] = 4;\r\n数组成员\r\n\r\n结构体\r\n创建结构体\r\n    // 结构体\r\n    struct Student{\r\n        uint256 id;\r\n        uint256 score; \r\n    }\r\n    Student student; // 初始一个student结构体\r\n给结构体赋值的两种方法\r\n    //  给结构体赋值\r\n    // 方法1:在函数中创建一个storage的struct引用\r\n    function initStudent1() external{\r\n        Student storage _student = student; // assign a copy of student\r\n        _student.id = 11;\r\n        _student.score = 100;\r\n    }\r\n     // 方法2:直接引用状态变量的struct\r\n    function initStudent2() external{\r\n        student.id = 1;\r\n        student.score = 80;\r\n    }\r\n7.映射类型\r\nmapping\r\n在映射中，人们可以通过键（Key）来查询对应的值（Value），比如：通过一个人的id来查询他的钱包地址。\r\nmapping(_KeyType =&gt; _ValueType)eg:\r\n    mapping(uint =&gt; address) public idToAddress; // id映射到地址\r\n    mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址\r\n映射的规则\r\n\r\n规则1：映射的_KeyType只能选择solidity默认的类型，比如uint，address等，不能用自定义的结构体。而_ValueType可以使用自定义的类型。\r\n规则2：映射的存储位置必须是storage，因此可以用于合约的状态变量，函数中的storage变量。不能用于public函数的参数或返回结果中，因为mapping记录的是一种关系\r\n(key - value pair)。\r\n规则3：如果映射声明为public，那么solidity会自动给你创建一个getter函数，可以通过Key来查询对应的Value。\r\n规则4：给映射新增的键值对的语法为_Var[_Key] = _Value，其中_Var是映射变量名，_Key和_Value对应新增的键值对。eg：\r\n\r\n    function writeMap (uint _Key, address _Value) public{\r\n        idToAddress[_Key] = _Value;\r\n    }\r\n映射的原理\r\n\r\n原理1：映射不储存任何键（Key）的资讯，也没有length的资讯。\r\n原理2：映射使用keccak256(key)当成offset存取value。\r\n原理3：因为Ethereum会定义所有未使用的空间为0，所以未赋值（Value）的键（Key）初始值都是0。\r\n\r\n8.变量初始值\r\n声明但没赋值的变量都是有初始值\r\n值类型初始值\r\n\r\nboolean:false\r\nstring:\"\"\r\nint:0\r\nuint:o\r\nenum:枚举的第一个元素\r\naddress:0x0000000000000000000000000000000000000000(或address(0))\r\nfunction\r\n\r\ninternal:空白方程\r\nexternal:空白方程\r\n\r\n\r\n可以用public变量的getter函数验证初始值：\r\n    bool public _bool;\r\n    ......\r\n引用类型初始值\r\n\r\n映射mapping：所有元素都为其默认值的mapping\r\n结构体struct：所有成员都设为其默认值的结构题\r\n数组array：\r\n\r\n动态数组：[]\r\n静态数组：所有成员设为其默认值的静态数组\r\n\r\n\r\n验证方式一样，eg：\r\n    mapping(uint =&gt; address) public _mapping; // 所有元素都为其默认值的mapping\r\n    \r\n        // 所有成员设为其默认值的结构体 0, 0\r\n    struct Student{\r\n        uint256 id;\r\n        uint256 score; \r\n    }\r\n    Student public student;\r\ndelete操作符\r\ndelete a会让变量a的值变为初始值\r\n9.常数\r\nconstant（常量）和immutable（不变量）。状态变量声明这个两个关键字之后，不能在合约后更改数值；并且还可以节省gas。\r\n另外，只有数值变量可以声明constant和immutable；string和bytes可以声明为constant，但不能为immutable。\r\nconstant\r\nconstant变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过。\r\n    // constant变量必须在声明的时候初始化，之后不能改变\r\n    uint256 constant CONSTANT_NUM = 10;\r\n    string constant CONSTANT_STRING = \"0xAA\";\r\n    bytes constant CONSTANT_BYTES = \"WTF\";\r\n    address constant CONSTANT_ADDRESS = 0x0000000000000000000000000000000000000000;\r\nimmutable\r\nimmutable变量可以在声明时或构造函数中初始化，因此更加灵活。\r\n    // immutable变量可以在constructor里初始化，之后不能改变\r\n    uint256 public immutable IMMUTABLE_NUM = 9999999999;\r\n    address public immutable IMMUTABLE_ADDRESS;\r\n    uint256 public immutable IMMUTABLE_BLOCK;\r\n    uint256 public immutable IMMUTABLE_TEST;\r\n可以使用全局变量例如address(this)，block.number\r\n，或者自定义的函数给immutable变量初始化。在下面这个例子，我们利用了test()函数给IMMUTABLE_TEST初始化为9：\r\n    // 利用constructor初始化immutable变量，因此可以利用\r\n    constructor(){\r\n        IMMUTABLE_ADDRESS = address(this);\r\n        IMMUTABLE_BLOCK = block.number;\r\n        IMMUTABLE_TEST = test();\r\n    }\r\n\r\n    function test() public pure returns(uint256){\r\n        uint256 what = 9;\r\n        return(what);\r\n    }\r\n10.控制流\r\n\r\nif-else\r\nfor循环\r\nwhie循环\r\ndo-while循环\r\n三元运算符：三元运算符是solidity中唯一一个接受三个操作数的运算符，规则条件? 条件为真的表达式:条件为假的表达式。\r\n此运算符经常用作 if 语句的快捷方式。\r\n\r\n// 三元运算符 ternary/conditional operator\r\nfunction ternaryTest(uint256 x, uint256 y) public pure returns(uint256){\r\n    // return the max of x and y\r\n    return x &gt;= y ? x: y; \r\n}\r\n用solidity实现插入排序\r\n插入排序\r\n排序算法解决的问题是将无序的一组数字，例如[2, 5, 3, 1]，从小到大依次排列好。（思路：从前往后，依次将每一个数和排在他前面的数字比大小，如果比前面的数字小，就互换位置。）\r\n贴个python代码\r\n# Python program for implementation of Insertion Sort\r\ndef insertionSort(arr):\r\n    for i in range(1, len(arr)):\r\n        key = arr[i]\r\n        j = i-1\r\n        while j &gt;=0 and key &lt; arr[j] :\r\n                arr[j+1] = arr[j]\r\n                j -= 1\r\n        arr[j+1] = key\r\n改写成solidity后有BUG！\r\n    // 插入排序 错误版\r\n    function insertionSortWrong(uint[] memory a) public pure returns(uint[] memory) {\r\n        \r\n        for (uint i = 1;i &lt; a.length;i++){\r\n            uint temp = a[i];\r\n            uint j=i-1;\r\n            while( (j &gt;= 0) &amp;&amp; (temp &lt; a[j])){\r\n                a[j+1] = a[j];\r\n                j--;\r\n            }\r\n            a[j+1] = temp;\r\n        }\r\n        return(a);\r\n    }\r\n原因：solidity中最常用的变量类型是uint，也就是正整数，取到负值的话，会报underflow错误。而在插入算法中，变量j有可能会取到-1，引起报错。\r\n这里把j加1，让它无法取到赋值\r\n    // 插入排序 正确版\r\n    function insertionSort(uint[] memory a) public pure returns(uint[] memory) {\r\n        // note that uint can not take negative value\r\n        for (uint i = 1;i &lt; a.length;i++){\r\n            uint temp = a[i];\r\n            uint j=i;\r\n            while( (j &gt;= 1) &amp;&amp; (temp &lt; a[j-1])){\r\n                a[j] = a[j-1];\r\n                j--;\r\n            }\r\n            a[j] = temp;\r\n        }\r\n        return(a);\r\n    }\r\n11.构造函数和修饰器\r\n构造函数\r\n构造函数（constructor）是一种特殊的函数，每个合约可以定义一个，并在部署合约的时候自动运行一次。它可以用来初始化合约的一些参数，例如初始化合约的owner地址：\r\n   address owner; // 定义owner变量\r\n\r\n   // 构造函数\r\n   constructor() {\r\n      owner = msg.sender; // 在部署合约的时候，将owner设置为部署者的地址\r\n   }\r\nTip:构造函数在不同的solidity版本中的语法并不一致，在Solidity\r\n0.4.22之前，构造函数不使用 constructor\r\n而是使用与合约名同名的函数作为构造函数而使用，由于这种旧写法容易使开发者在书写时发生疏漏（例如合约名叫\r\nParents，构造函数名写成\r\nparents），使得构造函数变成普通函数，引发漏洞，所以0.4.22版本及之后，采用了全新的\r\nconstructor 写法。\r\npragma solidity =0.4.21;\r\ncontract Parents {\r\n    // 与合约名Parents同名的函数就是构造函数\r\n    function Parents () public {\r\n    }\r\n}\r\n修饰器\r\n修饰器（modifier）是solidity特有的语法，类似于面向对象编程中的decorator，声明函数拥有的特性，并减少代码冗余。\r\nmodifier的主要使用场景是运行函数前的检查，例如地址，变量，余额等。\r\n   // 定义modifier\r\n   modifier onlyOwner {\r\n      require(msg.sender == owner); // 检查调用者是否为owner地址\r\n      _; // 如果是的话，继续运行函数主体；否则报错并revert交易\r\n   }\r\n带有onlyOwner修饰符的函数只能被owner地址调用，比如下面这个例子：\r\n   function changeOwner(address _newOwner) external onlyOwner{\r\n      owner = _newOwner; // 只有owner地址运行这个函数，并改变owner\r\n   }\r\n我们定义了一个changeOwner函数，运行他可以改变合约的owner，但是由于onlyOwner修饰符的存在，只有原先的owner可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。\r\n12.事件\r\nSolidity中的事件（event）是EVM上日志的抽象，它具有两个特点：\r\n\r\n应用程序（ether.js）可以通过RPC接口订阅和监听这些事件，并在前端做响应。\r\n事件是EVM上比较经济的存储数据的方式，每个大概消耗2,000\r\ngas；相比之下，链上存储一个新变量至少需要20,000\r\ngas。\r\n\r\n规则\r\n事件的声明由event关键字开头，然后跟事件名称，括号里面写好事件需要记录的变量类型和变量名。以ERC20代币合约的Transfer事件为例：\r\nevent Transfer(address indexed from, address indexed to, uint256 value);\r\nTransfer事件共记录了3个变量from，to和value，分别对应代币的转账地址，接收地址和转账数量。\r\n同时from和to前面带着indexed关键字，每个indexed标记的变量可以理解为检索事件的索引“键”，在以太坊上单独作为一个topic进行存储和索引，程序可以轻松的筛选出特定转账地址和接收地址的转账事件。每个事件最多有3个带indexed的变量。每个\r\nindexed\r\n变量的大小为固定的256比特。事件的哈希以及这三个带indexed的变量在EVM日志中通常被存储为topic。其中topic[0]是此事件的keccak256哈希，topic[1]到topic[3]存储了带indexed变量的keccak256哈希。\r\n\r\nvalue 不带 indexed 关键字，会存储在事件的\r\ndata 部分中，可以理解为事件的“值”。data\r\n部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般\r\ndata\r\n部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的\r\ntopic 部分中，也是以哈希的方式存储。另外，data\r\n部分的变量在存储上消耗的gas相比于 topic 更少。\r\n可以在函数里释放事件：\r\n    // 定义_transfer函数，执行转账逻辑\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external {\r\n\r\n        _balances[from] = 10000000; // 给转账地址一些初始代币\r\n\r\n        _balances[from] -=  amount; // from地址减去转账数量\r\n        _balances[to] += amount; // to地址加上转账数量\r\n\r\n        // 释放事件\r\n        emit Transfer(from, to, amount);\r\n    }\r\n13.继承\r\n规则\r\n\r\nvirtual:\r\n父合约中的函数，如果希望子合约重写，需要加上virtual关键字。\r\noverride：子合约重写了父合约中的函数，需要加上override关键字。\r\n\r\n简单继承\r\n（确实比较简单，直接贴例子）\r\n先写一个简单的爷爷合约Yeye，里面包含1个Log事件和3个function:\r\nhip(), pop(),\r\nyeye()，输出都是”Yeye”。\r\ncontract Yeye {\r\n    event Log(string msg);\r\n\r\n    // 定义3个function: hip(), pop(), man()，Log值为Yeye。\r\n    function hip() public virtual{\r\n        emit Log(\"Yeye\");\r\n    }\r\n\r\n    function pop() public virtual{\r\n        emit Log(\"Yeye\");\r\n    }\r\n\r\n    function yeye() public virtual {\r\n        emit Log(\"Yeye\");\r\n    }\r\n}\r\n再定义一个爸爸合约Baba，让他继承Yeye合约，语法就是contract Baba is Yeye，非常直观。在Baba合约里，我们重写一下hip()和pop()这两个函数，加上override关键字，并将他们的输出改为”Baba”；并且加一个新的函数baba，输出也是”Baba”。\r\ncontract Baba is Yeye{\r\n    // 继承两个function: hip()和pop()，输出改为Baba。\r\n    function hip() public virtual override{\r\n        emit Log(\"Baba\");\r\n    }\r\n\r\n    function pop() public virtual override{\r\n        emit Log(\"Baba\");\r\n    }\r\n\r\n    function baba() public virtual{\r\n        emit Log(\"Baba\");\r\n    }\r\n}\r\n部署合约，可以看到Baba合约里有4个函数，其中hip()和pop()的输出被成功改写成”Baba”，而继承来的yeye()的输出仍然是”Yeye”。\r\n多重继承\r\nsolidity合约可以继承多个合约\r\n继承时要按辈分最高到最低的顺序排。比如我们写一个Erzi合约，继承Yeye合约和Baba合约，那么就要写成contract Erzi is Yeye, Baba，而不能写成contract Erzi is Baba, Yeye，不然就会报错。\r\n如果某一个函数在多个继承的合约里都存在，比如例子中的hip()和pop()，在子合约里必须重写，不然会报错。\r\n重写在多个父合约中都重名的函数时，override关键字后面要加上所有父合约名字，例如override(Yeye, Baba)。\r\n例子：\r\ncontract Erzi is Yeye, Baba{\r\n    // 继承两个function: hip()和pop()，输出值为Erzi。\r\n    function hip() public virtual override(Yeye, Baba){\r\n        emit Log(\"Erzi\");\r\n    }\r\n\r\n    function pop() public virtual override(Yeye, Baba) {\r\n        emit Log(\"Erzi\");\r\n    }\r\n修饰器的继承\r\nSolidity中的修饰器（Modifier）同样可以继承，用法与函数继承类似，在相应的地方加virtual和override关键字即可。\r\ncontract Base1 {\r\n    modifier exactDividedBy2And3(uint _a) virtual {\r\n        require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Identifier is Base1 {\r\n\r\n    //计算一个数分别被2除和被3除的值，但是传入的参数必须是2和3的倍数\r\n    function getExactDividedBy2And3(uint _dividend) public exactDividedBy2And3(_dividend) pure returns(uint, uint) {\r\n        return getExactDividedBy2And3WithoutModifier(_dividend);\r\n    }\r\n\r\n    //计算一个数分别被2除和被3除的值\r\n    function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returns(uint, uint){\r\n        uint div2 = _dividend / 2;\r\n        uint div3 = _dividend / 3;\r\n        return (div2, div3);\r\n    }\r\n}\r\nIdentifier合约可以直接在代码中使用父合约中的exactDividedBy2And3修饰器，也可以利用override关键字重写修饰器：\r\n    modifier exactDividedBy2And3(uint _a) override {\r\n        _;\r\n        require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);\r\n    }\r\n构造函数的继承\r\n子合约有两种方法继承父合约的构造函数。举个简单的例子，父合约A里面有一个状态变量a，并由构造函数的参数来确定：\r\n// 构造函数的继承\r\nabstract contract A {\r\n    uint public a;\r\n\r\n    constructor(uint _a) {\r\n        a = _a;\r\n    }\r\n}\r\n1.在继承时声明父构造函数的参数，例如：contract B is A(1)\r\n2.在子合约的构造函数中声明构造函数的参数，例如：\r\ncontract C is A {\r\n    constructor(uint _c) A(_c * _c) {}\r\n}\r\n调用父合约的函数\r\n子合约有两种调用父合约的函数\r\n\r\n直接调用：子合约可以直接用父合约名.函数名()的方式来调用父合约函数，例如Yeye.pop()。\r\n\r\n    function callParent() public{\r\n        Yeye.pop();\r\n    }\r\n\r\nsuper关键字：子合约可以利用super.函数名()来调用最近的父合约函数。solidity继承关系按声明时从右到左的顺序是：contract Erzi is Yeye, Baba，那么Baba是最近的父合约，super.pop()将调用Baba.pop()而不是Yeye.pop()：\r\n\r\n    function callParentSuper() public{\r\n        // 将调用最近的父合约函数，Baba.pop()\r\n        super.pop();\r\n    }\r\n14.抽象合约和接口\r\n抽象合约\r\n如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体{}中的内容，则必须将该合约标为abstract，不然编译会报错；另外，未实现的函数需要加virtual，以便子合约重写。拿我们之前的插入排序合约为例，如果我们还没想好具体怎么实现插入排序函数，那么可以把合约标为abstract，之后让别人补写上。\r\nabstract contract InsertionSort{\r\n    function insertionSort(uint[] memory a) public pure virtual returns(uint[] memory);\r\n}\r\n接口\r\n接口类似于抽象合约，但不实现任何功能。\r\n规则：\r\n\r\n不能包含状态变量\r\n不能包含构造函数\r\n不能继承除接口外的其他合约\r\n所有函数都必须是external且不能有函数体\r\n继承接口的合约必须实现接口定义的所有功能\r\n\r\n虽然接口不实现任何功能，但它非常重要。接口是智能合约的骨架，定义了合约的功能以及如何触发它们：如果智能合约实现了某种接口（比如ERC20或ERC721），其他Dapps和智能合约就知道如何与它交互。因为接口提供了两个重要的信息：\r\n1.合约里每个函数的bytes4选择器，以及基于它们的函数签名函数名(每个参数类型）。\r\n2.接口id（更多信息见EIP165）\r\n另外，接口与合约ABI（Application Binary\r\nInterface）等价，可以相互转换：编译接口可以得到合约的ABI，利用abi-to-sol工具也可以将ABI json文件转换为接口sol文件。\r\n我们以ERC721接口合约IERC721为例，它定义了3个event和9个function，所有ERC721标准的NFT都实现了这些函数。我们可以看到，接口和常规合约的区别在于每个函数都以;代替函数体{ }结尾。\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    \r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\nIERC721事件\r\nIERC721包含3个事件，其中Transfer和Approval事件在ERC20中也有。\r\n\r\nTransfer事件：在转账时被释放，记录代币的发出地址from，接收地址to和tokenid。\r\nApproval事件：在授权时释放，记录授权地址owner，被授权地址approved和tokenid。\r\nApprovalForAll事件：在批量授权时释放，记录批量授权的发出地址owner，被授权地址operator和授权与否的approved。\r\n\r\nIERC721函数\r\n\r\nbalanceOf：返回某地址的NFT持有量balance。\r\nownerOf：返回某tokenId的主人owner。\r\ntransferFrom：普通转账，参数为转出地址from，接收地址to和tokenId。\r\nsafeTransferFrom：安全转账（如果接收方是合约地址，会要求实现ERC721Receiver接口）。参数为转出地址from，接收地址to和tokenId。\r\napprove：授权另一个地址使用你的NFT。参数为被授权地址approve和tokenId。\r\ngetApproved：查询tokenId被批准给了哪个地址。\r\nsetApprovalForAll：将自己持有的该系列NFT批量授权给某个地址operator。\r\nisApprovedForAll：查询某地址的NFT是否批量授权给了另一个operator地址。\r\nsafeTransferFrom：安全转账的重载函数，参数里面包含了data。\r\n\r\n什么时候使用接口\r\n如果我们知道一个合约实现了IERC721接口，我们不需要知道它具体代码实现，就可以与它交互。\r\n无聊猿BAYC属于ERC721代币，实现了IERC721接口的功能。我们不需要知道它的源代码，只需知道它的合约地址，用IERC721接口就可以与它交互，比如用balanceOf()来查询某个地址的BAYC余额，用safeTransferFrom()来转账BAYC。\r\ncontract interactBAYC {\r\n    // 利用BAYC地址创建接口合约变量（ETH主网）\r\n    IERC721 BAYC = IERC721(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D);\r\n\r\n    // 通过接口调用BAYC的balanceOf()查询持仓量\r\n    function balanceOfBAYC(address owner) external view returns (uint256 balance){\r\n        return BAYC.balanceOf(owner);\r\n    }\r\n\r\n    // 通过接口调用BAYC的safeTransferFrom()安全转账\r\n    function safeTransferFromBAYC(address from, address to, uint256 tokenId) external{\r\n        BAYC.safeTransferFrom(from, to, tokenId);\r\n    }\r\n}\r\n15.异常\r\n写智能合约经常会出bug，solidity中的异常命令帮助我们debug。\r\nError\r\nerror是solidity 0.8版本新加的内容，方便且高效（省gas）地向用户解释操作失败的原因。人们可以在contract之外定义异常。下面，我们定义一个TransferNotOwner异常，当用户不是代币owner的时候尝试转账，会抛出错误：\r\nerror TransferNotOwner(); // 自定义error\r\n在执行当中，error必须搭配revert（回退）命令使用。\r\n    function transferOwner1(uint256 tokenId, address newOwner) public {\r\n        if(_owners[tokenId] != msg.sender){\r\n            revert TransferNotOwner();\r\n        }\r\n        _owners[tokenId] = newOwner;\r\n    }\r\n我们定义了一个transferOwner1()函数，它会检查代币的owner是不是发起人，如果不是，就会抛出TransferNotOwner异常；如果是的话，就会转账。\r\nRequire\r\nrequire命令是solidity 0.8版本之前抛出异常的常用方法，目前很多主流合约仍然还在使用它。它很好用，唯一的缺点就是gas随着描述异常的字符串长度增加，比error命令要高。使用方法：require(检查条件，\"异常的描述\")，当检查条件不成立的时候，就会抛出异常。\r\n我们用require命令重写一下上面的transferOwner函数：\r\n    function transferOwner2(uint256 tokenId, address newOwner) public {\r\n        require(_owners[tokenId] == msg.sender, \"Transfer Not Owner\");\r\n        _owners[tokenId] = newOwner;\r\n    }\r\n贴个在remix上验证的例子吧\r\n1.输入任意uint256数字和非0地址，调用transferOwner1，也就是error方法，控制台抛出了异常并显示我们自定义的TransferNotOwner。\r\n\r\n2.输入任意uint256数字和非0地址，调用transferOwner2，也就是require方法，控制台抛出了异常并打印出require中的字符串。\r\n\r\n3.输入任意uint256数字和非0地址，调用transferOwner3，也就是assert方法，控制台只抛出了异常。\r\n\r\nAssert\r\nassert命令一般用于程序员写程序debug，因为它不能解释抛出异常的原因（比require少个字符串）。它的用法很简单，assert(检查条件），当检查条件不成立的时候，就会抛出异常。\r\n我们用assert命令重写一下上面的transferOwner函数：\r\n    function transferOwner3(uint256 tokenId, address newOwner) public {\r\n        assert(_owners[tokenId] == msg.sender);\r\n        _owners[tokenId] = newOwner;\r\n    }\r\n三种方法的gas比较\r\n我们比较一下三种抛出异常的gas消耗，通过remix控制台的Debug按钮，能查到每次函数调用的gas消耗分别如下：\r\n\r\nerror方法gas消耗：24445\r\nrequire方法gas消耗：24743\r\nassert方法gas消耗：24446\r\n\r\n我们可以看到，error方法gas最少，其次是assert，require方法消耗gas最多！因此，error既可以告知用户抛出异常的原因，又能省gas，大家要多用！（注意，由于部署测试时间的不同，每个函数的gas消耗会有所不同，但是比较结果会是一致的。）\r\n","slug":"solidity入门","date":"2022-11-26T16:55:02.000Z","categories_index":"","tags_index":"solidity","author_index":"cocoZ"},{"id":"4a8c6c67f0d77f1d7a087ca184ac4b68","title":"hexo+github搭建个人博客","content":"搭建个人博客（hexo+github）\r\n准备工作\r\n安装git、安装node.js、还有npm啥的（在看到任务前就装好了的）\r\n## 在github上创建仓库\r\n仓库名字要和用户名一样！！！\r\n（github pages等一会儿就出来了）\r\n\r\n安装hexo\r\n桌面创建一个文件夹，在文件夹目录下打开git bash here\r\n\r\n安装hexo\r\nnpm install -g hexo-cli\r\n查看版本\r\nhexo -v\r\n初始化hexo、\r\nhexo init\r\n生成本地的hexo页面\r\nhexo s\r\n输入hexo g生成静态网站\r\n输入hexo s，然后浏览器打开localhost:4000，就可以本地访问了（Ctrl+c退出）\r\n连接GitHub与本地\r\n绑定个密钥：\r\n生成SSH Keys\r\nssh-keygen -t rsa -C \"你的邮箱地址\"\r\n在C/用户/16017/.ssh目录下打开这个，复制\r\n\r\n打开github的总setting，添加SSH Keys\r\n\r\n在目录下打开git bash here，输入以下命令\r\ngit config --global user.name cocoGenZ\r\ngit config --global user.email 160760796@qq.com\r\n打开博客根目录下的_config.yml文件，修改最后一行的配置\r\n  type: git\r\n  repository: https://github.com/cocoGenZ/cocoGenZ.github.io.git\r\n  branch: main\r\nTip:上面的repository在GitHub里面复制HTTPS那个\r\n\r\n安装一键部署插件\r\ncnpm install hexo-deployer-git --save(不知道为什么有这个save的我安装不了，就另外装了个cnpm来安装)（更新完就ok了`npm\r\n-g install npm@latest）\r\n分别输入一下三条命令\r\nhexo clean   #清除缓存文件 db.json 和已生成的静态文件 public\r\nhexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)\r\nhexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)\r\n最后访问博客的地址就可以啦https://cocogenz.github.io/\r\n\r\n改个主题吧\r\n安装一个yarn（命令行就能装，用npm来装）\r\nyarn add hexo-theme-aurora\r\n\r\n改改参数\r\n\r\n关于上传图片显示的问题\r\n将图片上传到网上，再用markdown引用\r\nhttps://sm.ms/\r\n这个网址很方便\r\n","slug":"hexo-github搭建个人博客","date":"2022-11-21T14:10:57.000Z","categories_index":"","tags_index":"博客","author_index":"cocoZ"},{"id":"7b9812fe6cbf2aba598dcdf2de807daf","title":"Test","content":"第一次搭博客，浅浅做个测试\r\n","slug":"Test","date":"2022-11-15T03:55:53.000Z","categories_index":"","tags_index":"","author_index":"cocoZ"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very\r\nfirst post. Check documentation for\r\nmore info. If you get any problems when using Hexo, you can find the\r\nanswer in troubleshooting or\r\nyou can ask me on GitHub.\r\nQuick Start\r\nCreate a new post\r\n$ hexo new \"My New Post\"\r\nMore info: Writing\r\nRun server\r\n$ hexo server\r\nMore info: Server\r\nGenerate static files\r\n$ hexo generate\r\nMore info: Generating\r\nDeploy to remote sites\r\n$ hexo deploy\r\nMore info: Deployment\r\n","slug":"hello-world","date":"2022-11-15T02:54:10.513Z","categories_index":"","tags_index":"","author_index":"cocoZ"}]