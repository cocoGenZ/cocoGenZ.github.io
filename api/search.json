[{"id":"3b889475d55359c53070293a35d903d7","title":"solidity入门","content":"solidity\r\n1.入门\r\n// SPDX-License-Identifier: MIT             //这个代码所用的软件许可，如果不写许可，编译时会警告\r\npragma solidity ^0.8.4;             //声明源文件所用的solidity版本\r\ncontract HelloWeb3{             //创建合约（contract），并声明合约名字为Helloweb3\r\n    string public _string = \"Hello Web3!\";      //合约的内容，声明了一个string（字符串）变量_string，并赋值\r\n}\r\n2.数值类型\r\n数值类型\r\n1.布尔型：二值变量，取值为** true或false**\r\nbool public  _bool = true;\r\n布尔值的运算符：！（逻辑非）、&amp;&amp;（逻辑与）、||（逻辑或）、==（等于）、！=（不等于）\r\n2.整型：\r\nint public _int = -1;           //整数，包括负数\r\nuint public _uint = 1;          //正整数\r\nuint256 public _number = 20220330;       //256位正整数\r\nuint public _coco1 =2**4;       //求指数2^4=16\r\nbool public _numberbool = _Uint &gt; _int;     //比大小\r\n3.地址类型：\r\n存储一个20字节的值（以太坊地址的大小）。\r\n地址类型也由成员变量，并作为所有合约的基础。\r\n地址类型分为普通的地址和可以转账ETH的地址（payable）\r\npayable的地址拥有balance和transfer（）两个成员，方便查询ETH余额以及转账。\r\naddress public _address =0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;\r\naddress payable public _address1 = payable(_address);       //payable address可以转账、查余额\r\nuint256 public balance = _address1.balance;  //address1的余额\r\n4.定长字节数组：\r\n字节数组bytes分为定长（byte,bytes8，bytes32）和不定长。（定长的属于数值类型，不定长的属于引用类型）\r\n定长byte可以存一些数据，消耗gas比较少\r\nbytes32 public _byte32 = \"Minisolidity\";        //Minisolidity变量以字节的方式存储进变量_byte32，转换成16进制为：0x4d696e69536f6c69646974790000000000000000000000000000000000000000\r\nbytes1 public _byte = _byte32[0];       //_byte变量存储_byte32的第一个字节，为0x4d\r\nTip：byte是bytes1的别名\r\n\r\n（Q:为啥每个元素会浪费31字节？)\r\n5.枚举enum\r\n枚举是solidity中用户定义的数据类型，主要为uint分配名称，使程序易于阅读和维护（参考c语言）\r\nenum ActionSet{Buy,hold,Sell}       //用enum将unit 0， 1， 2表示为Buy, Hold, Sell\r\nActionSet action = ActionSet.Buy;   //创建enum变量action\r\n\r\n（Q:这段话有点看不懂，啥叫显式的和uint相互转换？然后检查是怎么检查的？)\r\n\r\nemmmmm，懂了，我觉得就是数组名称和数组索引的转换，检查是自动会检查的，如果不在长度内会报错\r\n3.函数类型\r\n函数\r\n    function &lt;function name&gt;(&lt;parameter types&gt;) {internal|external|public|private} [pure|view|payable] [returns (&lt;return types&gt;)]\r\n    function 函数名(输入到函数的变量类型和名字) 函数可见性说明符 决定函数权限/功能的关键字 returns(函数返回的变量类型和名称)\r\n1.function：声明函数的关键字\r\n2.&lt;function name&gt;：函数名\r\n3.(&lt;parameter types&gt;)：函数的参数，变量类型+变量名\r\n4.{internal|external|public|private}：函数可见性说明符，一共4种（没标明函数类型的，默认internal）\r\n\r\npublic：内部外部都可见（也可以用于修饰状态变量，public变量会自动生成getter函数，用于查询数据）\r\nprivate：只能从合约内部访问，继承的合约也不能用（也可用于修饰状态变量）\r\nexternal：只能从合约外部访问（但是可以用this.f()来调用，f是函数名）\r\ninternal：只能从合约内部访问，继承的合约可以用（也可以用于修饰状态变量）\r\n5.[pure|view|payable]：决定函数权限/功能的关键字。（payable运行时可以给合约转入ETH）\r\n6.[returns()]：函数返回的变量类型和名称\r\n\r\n\r\neg: function getData() external view returns(uint256) {\r\n         return data;\r\n     } \r\n关于pure和view\r\n在合约里面定义一个状态变量number=5\r\n// SPDX-License-Indentifier:MIT\r\npragma solidity ^0.8.4;\r\ncontract FunctionTypes{\r\nuint256 public number=5;\r\n定义一个add()函数，每次调用，每次给number+1\r\n//默认\r\nfunction add() external{\r\nnumber=number+1;\r\n}\r\n如果add()包含了pure关键字，例如function add() pure external，就会报错。pure没有权限读取合约的相关变量，更没有权限改写。\r\npure函数能干啥捏？(pure：纯纯牛马emmmmm)\r\neg：可以给函数传递一个参数_number，然后让他返回_number+1\r\nfunction addPure(uint256 _number) external pure returns(uint256 new_number){\r\nnew_number=_number+1;\r\n}\r\n\r\n如图，在_number位置传入一个参数7，就会执行函数，得到输出结果为8\r\n如果add()包含view，比如function add() view external也会报错。因为view能读取，但是不能够改写状态变量。可以稍微改一下，让其不改写number，而是返回一个新的变量。(view：看客)\r\nuint public number=1;\r\nfunction addView() external view returns(uint256 new_number){\r\nnew_number=number+1;\r\n}\r\n\r\n点击addView这个函数就会直接读取number=5，直接输出number3=6\r\n（Q:遇到一个问题，就是这样子写报错了，addView函数里面写uint256\r\nnumber=5也会报错，我觉得是因为view只有读取的权限没有写入的权限，是嘛是嘛？？？）\r\n\r\n\r\n为什么引入pure和view关键字\r\nsolidity引入pure和view关键字主要是为了节省gas和控制函数权限：如果用户直接调用pure/view方程是不消耗gas的（合约中非pure/gas函数调用它们则会改写链上状态，需要付gas）\r\n关于internal和external\r\n（Q：我自己问出了一个很蠢的问题：怎么区分合约内部和外部）\r\n我思考了一下，还是要回到1入门那边，最开始学习到的创建一个合约\r\n\r\n所以我知道怎么区分了（所以我是pure，纯纯牛马一个\r\n//internal:内部\r\nfunction minus() internal{\r\nnumber=number-1;\r\n}\r\n//合约内的函数可以调用内部函数\r\nfunction minusCall() external(){\r\nminus();\r\n}\r\n定义一个internal的minus()函数，每次调用使number-1。由于是internal，只能从合约内部调用，不能从外部。因此，还要再定义一个external的minusCall()函数，来直接调用内部的minus()\r\n\r\n图片里面只能看到minus222（）看不到minus（）这样子\r\n（Tip：我的理解是internal有像把函数写进合约内部，然后external是写在外部，直接调用即可。)（这样子理解有问题否？？？？？\r\npayable\r\n//payable：递钱，能给合约支付ETH的函数\r\nfunction minusPayable() external payable returns(uint256 balance){\r\nminus();\r\nbalance=address(this).balance;\r\n}\r\n定义一个external payable的minusPayable()函数，间接的调用minus()，并且返回合约里的ETH余额（this关键字可以让我们引用合约地址）\r\n我们可以再调用minusPayable()时，往合约里转入1个ETH\r\n\r\n是这样的，可以在左下角看到余额balance：1ETH\r\n\r\n4.函数输出return\r\n返回值return和returns\r\nreturn和returns这两个关键字与函数输出相关。区别在于：\r\n\r\nreturns加在函数名后面，用于声明返回的变量类型及变量名；\r\nreturns用于函数主体中，返回指定的变量。\r\n\r\n//返回多个变量\r\nfunction returnMultiple() public pure returns(uint256,bool,uint256[3] memory){\r\nreturn(1,true,[uint256(1),2,5]);\r\n}\r\n声明了returnMultiple()函数将有多个输出：returns(uint256,bool,uint256[3] memory)，接着在函数的主体中用return(1,true,[uint256(1),2,5])确定了返回值\r\n命名式返回\r\n我们可以在returns中\r\n标明返回变量的名称，这样solidity会自动给这些变量初始化，并且自动返回这些函数的值，不需要加return\r\n    // 返回多个变量\r\n    function returnMultiple() public pure returns(uint256, bool, uint256[3] memory){\r\n            return(1, true, [uint256(1),2,5]);\r\n        }\r\n改为\r\n    // 命名式返回\r\n    function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){\r\n        _number = 2;\r\n        _bool = false; \r\n        _array = [uint256(3),2,1];\r\n    }\r\nTip:也可以在命名式返回中用return来返回变量，跟第一种一样\r\n解构式赋值\r\n\r\n读取所有返回值：声明变量，并且将要赋值的变量用,隔开，按顺序排列。\r\n\r\n        uint256 _number;\r\n        bool _bool;\r\n        uint256[3] memory _array;\r\n        (_number, _bool, _array) = returnNamed();\r\n\r\n读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。下面这段代码中，我们只读取_bool，而不读取返回的_number和_array：\r\n\r\n        (, _bool2, ) = returnNamed();\r\n5.变量数据存储和作用域\r\n引用类型(Reference Type)\r\n数组(array)、结构体(struct)和映射(mapping)，这类变量占空间大，赋值时候直接传递地址（类似指针）。由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明数据存储的位置。\r\n数据位置\r\nstorage、memory和calldata。\r\n不同存储位置的gas成本不同：\r\nstorage类型的数据存在链上，类似计算机的硬盘，消耗gas多；\r\nmemory和calldata类型的临时存在内存里，消耗gas少。\r\n\r\nstorage：合约里的状态变量默认都是storage，存储在链上。\r\nmemory：函数里的参数和临时变量一般用memory，存储在内存中，不上链。\r\ncalldata：和memory类似，存储在内存中，不上链。与memory的不同点在于calldata变量不能修改（immutable），一般用于函数的参数。eg：\r\n\r\n    function fCalldata(uint[] calldata _x) public pure returns(uint[] calldata){\r\n        //参数为calldata数组，不能被修改\r\n        // _x[0] = 0 //这样修改会报错\r\n        return(_x);\r\n    }\r\n赋值规则\r\n在不同存储类型相互赋值时候，有时会产生独立的副本（修改新变量不会影响原变量），有时会产生引用（修改新变量会影响原变量）。规则如下：\r\n\r\nstorage（合约的状态变量）赋值给本地storage（函数里的）时候，会创建引用，改变新变量会影响原变量。eg：\r\n\r\n    uint[] x = [1,2,3]; // 状态变量：数组 x\r\n\r\n    function fStorage() public{\r\n        //声明一个storage的变量 xStorage，指向x。修改xStorage也会影响x\r\n        uint[] storage xStorage = x;\r\n        xStorage[0] = 100;\r\n    }\r\n\r\nstorage赋值给memory，会创建独立的复本，修改其中一个不会影响另一个；反之亦然。\r\n\r\n    uint[] x = [1,2,3]; // 状态变量：数组 x\r\n    \r\n    function fMemory() public view{\r\n        //声明一个Memory的变量xMemory，复制x。修改xMemory不会影响x\r\n        uint[] memory xMemory = x;\r\n        xMemory[0] = 100;\r\n        xMemory[1] = 200;\r\n        uint[] memory xMemory2 = x;\r\n        xMemory2[0] = 300;\r\n    }\r\ndebug康康\r\n\r\n\r\n\r\nmemory赋值给memory，会创建引用，改变新变量会影响原变量\r\n其他情况，变量赋值给storage，会创建独立的复本，修改其中一个不会影响另一个\r\n\r\n作用域\r\n\r\n状态变量\r\n数据存储在链上的变量，所有的合约内的函数都可以访问，gas消耗高。状态变量在合约内、函数外声明（可以在函数里更改状态变量的值）\r\n局部变量\r\n局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，gas低。局部变量在函数内声明\r\n\r\n    function bar() external pure returns(uint){\r\n        uint xx = 1;\r\n        uint yy = 3;\r\n        uint zz = xx + yy;\r\n        return(zz);\r\n    }\r\n\r\n全局变量\r\n全局变量是全局范围工作的变量，都是solidity预留关键字（可以在函数内不声明直接使用）\r\n\r\n    function global() external view returns(address, uint, bytes memory){\r\n        address sender = msg.sender;\r\n        uint blockNum = block.number;\r\n        bytes memory data = msg.data;\r\n        return(sender, blockNum, data);\r\n    }\r\n\r\n6.引用类型\r\n数组array\r\n数组（Array）是solidity常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）\r\n\r\n固定长度数组：在声明时指定数组的长度。用T[k]的格式表明，其中T是元素的类型，k是长度，eg:\r\n\r\n    // 固定长度 Array\r\n    uint[8] array1;\r\n    bytes1[5] array2;\r\n    address[100] array3;\r\n\r\n可变长度数组（动态数组）：在声明时不指定数值的长度。用T[]的格式表明，其中T是元素的类型（bytes比较特殊，是数组，但是不加[]），eg：\r\n\r\n    // 可变长度 Array\r\n    uint[] array4;\r\n    bytes1[] array5;\r\n    address[] array6;\r\n    bytes array7;\r\n创建数组的规则\r\n\r\n对于memory修饰的动态数组，可以用new操作符来创建，但是必须声明长度，并且声明后长度不能改变，eg：\r\n\r\n    // memory动态数组\r\n    uint[] memory array8 = new uint[](5);\r\n    bytes memory array9 = new bytes(9);\r\n\r\n数组字面常数（Array\r\nLiterals）是写作表达形式的数组，用方括号包着来初始化array的一种方式，并且里面每一个元素的type是以第一个元素为准的，例如[1,2,3]里面所有的元素都是uint8类型，因为在solidity中如果一个值没有指定type的话，默认就是最小单位的该type，这里int的默认最小单位类型就是uint8。而[uint(1),2,3]里面的元素都是uint类型，因为第一个元素指定了是uint类型了，我们都以第一个元素为准。下面的合约中，对于f函数里面的调用，如果我们没有显式对第一个元素进行uint强转的话，是会报错的，因为如上所述我们其实是传入了uint8类型的array，可是g函数需要的却是uint类型的array，就会报错了。\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\npragma solidity &gt;=0.4.16 &lt;0.9.0;\r\ncontract C {\r\n    function f() public pure {\r\n        g([uint(1), 2, 3]);  //uint(1)强转了。如果是g([1,2,3]),就是uint8类型\r\n    }\r\n    function g(uint[3] memory) public pure {    //g()这边传入的是uint类型\r\n        // ...\r\n    }\r\n}\r\n\r\n如果创建的是动态数组，你需要一个一个元素的赋值。\r\n\r\n    uint[] memory x = new uint[](3);\r\n    x[0] = 1;\r\n    x[1] = 3;\r\n    x[2] = 4;\r\n数组成员\r\n\r\n结构体\r\n创建结构体\r\n    // 结构体\r\n    struct Student{\r\n        uint256 id;\r\n        uint256 score; \r\n    }\r\n    Student student; // 初始一个student结构体\r\n给结构体赋值的两种方法\r\n    //  给结构体赋值\r\n    // 方法1:在函数中创建一个storage的struct引用\r\n    function initStudent1() external{\r\n        Student storage _student = student; // assign a copy of student\r\n        _student.id = 11;\r\n        _student.score = 100;\r\n    }\r\n     // 方法2:直接引用状态变量的struct\r\n    function initStudent2() external{\r\n        student.id = 1;\r\n        student.score = 80;\r\n    }\r\n7.映射类型\r\nmapping\r\n在映射中，人们可以通过键（Key）来查询对应的值（Value），比如：通过一个人的id来查询他的钱包地址。\r\nmapping(_KeyType =&gt; _ValueType)eg:\r\n    mapping(uint =&gt; address) public idToAddress; // id映射到地址\r\n    mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址\r\n映射的规则\r\n\r\n规则1：映射的_KeyType只能选择solidity默认的类型，比如uint，address等，不能用自定义的结构体。而_ValueType可以使用自定义的类型。\r\n规则2：映射的存储位置必须是storage，因此可以用于合约的状态变量，函数中的storage变量。不能用于public函数的参数或返回结果中，因为mapping记录的是一种关系\r\n(key - value pair)。\r\n规则3：如果映射声明为public，那么solidity会自动给你创建一个getter函数，可以通过Key来查询对应的Value。\r\n规则4：给映射新增的键值对的语法为_Var[_Key] = _Value，其中_Var是映射变量名，_Key和_Value对应新增的键值对。eg：\r\n\r\n    function writeMap (uint _Key, address _Value) public{\r\n        idToAddress[_Key] = _Value;\r\n    }\r\n映射的原理\r\n\r\n原理1：映射不储存任何键（Key）的资讯，也没有length的资讯。\r\n原理2：映射使用keccak256(key)当成offset存取value。\r\n原理3：因为Ethereum会定义所有未使用的空间为0，所以未赋值（Value）的键（Key）初始值都是0。\r\n\r\n8.变量初始值\r\n声明但没赋值的变量都是有初始值\r\n值类型初始值\r\n\r\nboolean:false\r\nstring:\"\"\r\nint:0\r\nuint:o\r\nenum:枚举的第一个元素\r\naddress:0x0000000000000000000000000000000000000000(或address(0))\r\nfunction\r\n\r\ninternal:空白方程\r\nexternal:空白方程\r\n\r\n\r\n可以用public变量的getter函数验证初始值：\r\n    bool public _bool;\r\n    ......\r\n引用类型初始值\r\n\r\n映射mapping：所有元素都为其默认值的mapping\r\n结构体struct：所有成员都设为其默认值的结构题\r\n数组array：\r\n\r\n动态数组：[]\r\n静态数组：所有成员设为其默认值的静态数组\r\n\r\n\r\n验证方式一样，eg：\r\n    mapping(uint =&gt; address) public _mapping; // 所有元素都为其默认值的mapping\r\n    \r\n        // 所有成员设为其默认值的结构体 0, 0\r\n    struct Student{\r\n        uint256 id;\r\n        uint256 score; \r\n    }\r\n    Student public student;\r\ndelete操作符\r\ndelete a会让变量a的值变为初始值\r\n9.常数\r\nconstant（常量）和immutable（不变量）。状态变量声明这个两个关键字之后，不能在合约后更改数值；并且还可以节省gas。\r\n另外，只有数值变量可以声明constant和immutable；string和bytes可以声明为constant，但不能为immutable。\r\nconstant\r\nconstant变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过。\r\n    // constant变量必须在声明的时候初始化，之后不能改变\r\n    uint256 constant CONSTANT_NUM = 10;\r\n    string constant CONSTANT_STRING = \"0xAA\";\r\n    bytes constant CONSTANT_BYTES = \"WTF\";\r\n    address constant CONSTANT_ADDRESS = 0x0000000000000000000000000000000000000000;\r\nimmutable\r\nimmutable变量可以在声明时或构造函数中初始化，因此更加灵活。\r\n    // immutable变量可以在constructor里初始化，之后不能改变\r\n    uint256 public immutable IMMUTABLE_NUM = 9999999999;\r\n    address public immutable IMMUTABLE_ADDRESS;\r\n    uint256 public immutable IMMUTABLE_BLOCK;\r\n    uint256 public immutable IMMUTABLE_TEST;\r\n可以使用全局变量例如address(this)，block.number\r\n，或者自定义的函数给immutable变量初始化。在下面这个例子，我们利用了test()函数给IMMUTABLE_TEST初始化为9：\r\n    // 利用constructor初始化immutable变量，因此可以利用\r\n    constructor(){\r\n        IMMUTABLE_ADDRESS = address(this);\r\n        IMMUTABLE_BLOCK = block.number;\r\n        IMMUTABLE_TEST = test();\r\n    }\r\n\r\n    function test() public pure returns(uint256){\r\n        uint256 what = 9;\r\n        return(what);\r\n    }\r\n10.控制流\r\n\r\nif-else\r\nfor循环\r\nwhie循环\r\ndo-while循环\r\n三元运算符：三元运算符是solidity中唯一一个接受三个操作数的运算符，规则条件? 条件为真的表达式:条件为假的表达式。\r\n此运算符经常用作 if 语句的快捷方式。\r\n\r\n// 三元运算符 ternary/conditional operator\r\nfunction ternaryTest(uint256 x, uint256 y) public pure returns(uint256){\r\n    // return the max of x and y\r\n    return x &gt;= y ? x: y; \r\n}\r\n用solidity实现插入排序\r\n插入排序\r\n排序算法解决的问题是将无序的一组数字，例如[2, 5, 3, 1]，从小到大依次排列好。（思路：从前往后，依次将每一个数和排在他前面的数字比大小，如果比前面的数字小，就互换位置。）\r\n贴个python代码\r\n# Python program for implementation of Insertion Sort\r\ndef insertionSort(arr):\r\n    for i in range(1, len(arr)):\r\n        key = arr[i]\r\n        j = i-1\r\n        while j &gt;=0 and key &lt; arr[j] :\r\n                arr[j+1] = arr[j]\r\n                j -= 1\r\n        arr[j+1] = key\r\n改写成solidity后有BUG！\r\n    // 插入排序 错误版\r\n    function insertionSortWrong(uint[] memory a) public pure returns(uint[] memory) {\r\n        \r\n        for (uint i = 1;i &lt; a.length;i++){\r\n            uint temp = a[i];\r\n            uint j=i-1;\r\n            while( (j &gt;= 0) &amp;&amp; (temp &lt; a[j])){\r\n                a[j+1] = a[j];\r\n                j--;\r\n            }\r\n            a[j+1] = temp;\r\n        }\r\n        return(a);\r\n    }\r\n原因：solidity中最常用的变量类型是uint，也就是正整数，取到负值的话，会报underflow错误。而在插入算法中，变量j有可能会取到-1，引起报错。\r\n这里把j加1，让它无法取到赋值\r\n    // 插入排序 正确版\r\n    function insertionSort(uint[] memory a) public pure returns(uint[] memory) {\r\n        // note that uint can not take negative value\r\n        for (uint i = 1;i &lt; a.length;i++){\r\n            uint temp = a[i];\r\n            uint j=i;\r\n            while( (j &gt;= 1) &amp;&amp; (temp &lt; a[j-1])){\r\n                a[j] = a[j-1];\r\n                j--;\r\n            }\r\n            a[j] = temp;\r\n        }\r\n        return(a);\r\n    }\r\n11.构造函数和修饰器\r\n构造函数\r\n构造函数（constructor）是一种特殊的函数，每个合约可以定义一个，并在部署合约的时候自动运行一次。它可以用来初始化合约的一些参数，例如初始化合约的owner地址：\r\n   address owner; // 定义owner变量\r\n\r\n   // 构造函数\r\n   constructor() {\r\n      owner = msg.sender; // 在部署合约的时候，将owner设置为部署者的地址\r\n   }\r\nTip:构造函数在不同的solidity版本中的语法并不一致，在Solidity\r\n0.4.22之前，构造函数不使用 constructor\r\n而是使用与合约名同名的函数作为构造函数而使用，由于这种旧写法容易使开发者在书写时发生疏漏（例如合约名叫\r\nParents，构造函数名写成\r\nparents），使得构造函数变成普通函数，引发漏洞，所以0.4.22版本及之后，采用了全新的\r\nconstructor 写法。\r\npragma solidity =0.4.21;\r\ncontract Parents {\r\n    // 与合约名Parents同名的函数就是构造函数\r\n    function Parents () public {\r\n    }\r\n}\r\n修饰器\r\n修饰器（modifier）是solidity特有的语法，类似于面向对象编程中的decorator，声明函数拥有的特性，并减少代码冗余。\r\nmodifier的主要使用场景是运行函数前的检查，例如地址，变量，余额等。\r\n   // 定义modifier\r\n   modifier onlyOwner {\r\n      require(msg.sender == owner); // 检查调用者是否为owner地址\r\n      _; // 如果是的话，继续运行函数主体；否则报错并revert交易\r\n   }\r\n带有onlyOwner修饰符的函数只能被owner地址调用，比如下面这个例子：\r\n   function changeOwner(address _newOwner) external onlyOwner{\r\n      owner = _newOwner; // 只有owner地址运行这个函数，并改变owner\r\n   }\r\n我们定义了一个changeOwner函数，运行他可以改变合约的owner，但是由于onlyOwner修饰符的存在，只有原先的owner可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。\r\n12.事件\r\nSolidity中的事件（event）是EVM上日志的抽象，它具有两个特点：\r\n\r\n应用程序（ether.js）可以通过RPC接口订阅和监听这些事件，并在前端做响应。\r\n事件是EVM上比较经济的存储数据的方式，每个大概消耗2,000\r\ngas；相比之下，链上存储一个新变量至少需要20,000\r\ngas。\r\n\r\n规则\r\n事件的声明由event关键字开头，然后跟事件名称，括号里面写好事件需要记录的变量类型和变量名。以ERC20代币合约的Transfer事件为例：\r\nevent Transfer(address indexed from, address indexed to, uint256 value);\r\nTransfer事件共记录了3个变量from，to和value，分别对应代币的转账地址，接收地址和转账数量。\r\n同时from和to前面带着indexed关键字，每个indexed标记的变量可以理解为检索事件的索引“键”，在以太坊上单独作为一个topic进行存储和索引，程序可以轻松的筛选出特定转账地址和接收地址的转账事件。每个事件最多有3个带indexed的变量。每个\r\nindexed\r\n变量的大小为固定的256比特。事件的哈希以及这三个带indexed的变量在EVM日志中通常被存储为topic。其中topic[0]是此事件的keccak256哈希，topic[1]到topic[3]存储了带indexed变量的keccak256哈希。\r\n\r\nvalue 不带 indexed 关键字，会存储在事件的\r\ndata 部分中，可以理解为事件的“值”。data\r\n部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般\r\ndata\r\n部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的\r\ntopic 部分中，也是以哈希的方式存储。另外，data\r\n部分的变量在存储上消耗的gas相比于 topic 更少。\r\n可以在函数里释放事件：\r\n    // 定义_transfer函数，执行转账逻辑\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external {\r\n\r\n        _balances[from] = 10000000; // 给转账地址一些初始代币\r\n\r\n        _balances[from] -=  amount; // from地址减去转账数量\r\n        _balances[to] += amount; // to地址加上转账数量\r\n\r\n        // 释放事件\r\n        emit Transfer(from, to, amount);\r\n    }\r\n13.继承\r\n规则\r\n\r\nvirtual:\r\n父合约中的函数，如果希望子合约重写，需要加上virtual关键字。\r\noverride：子合约重写了父合约中的函数，需要加上override关键字。\r\n\r\n简单继承\r\n（确实比较简单，直接贴例子）\r\n先写一个简单的爷爷合约Yeye，里面包含1个Log事件和3个function:\r\nhip(), pop(),\r\nyeye()，输出都是”Yeye”。\r\ncontract Yeye {\r\n    event Log(string msg);\r\n\r\n    // 定义3个function: hip(), pop(), man()，Log值为Yeye。\r\n    function hip() public virtual{\r\n        emit Log(\"Yeye\");\r\n    }\r\n\r\n    function pop() public virtual{\r\n        emit Log(\"Yeye\");\r\n    }\r\n\r\n    function yeye() public virtual {\r\n        emit Log(\"Yeye\");\r\n    }\r\n}\r\n再定义一个爸爸合约Baba，让他继承Yeye合约，语法就是contract Baba is Yeye，非常直观。在Baba合约里，我们重写一下hip()和pop()这两个函数，加上override关键字，并将他们的输出改为”Baba”；并且加一个新的函数baba，输出也是”Baba”。\r\ncontract Baba is Yeye{\r\n    // 继承两个function: hip()和pop()，输出改为Baba。\r\n    function hip() public virtual override{\r\n        emit Log(\"Baba\");\r\n    }\r\n\r\n    function pop() public virtual override{\r\n        emit Log(\"Baba\");\r\n    }\r\n\r\n    function baba() public virtual{\r\n        emit Log(\"Baba\");\r\n    }\r\n}\r\n部署合约，可以看到Baba合约里有4个函数，其中hip()和pop()的输出被成功改写成”Baba”，而继承来的yeye()的输出仍然是”Yeye”。\r\n多重继承\r\nsolidity合约可以继承多个合约\r\n继承时要按辈分最高到最低的顺序排。比如我们写一个Erzi合约，继承Yeye合约和Baba合约，那么就要写成contract Erzi is Yeye, Baba，而不能写成contract Erzi is Baba, Yeye，不然就会报错。\r\n如果某一个函数在多个继承的合约里都存在，比如例子中的hip()和pop()，在子合约里必须重写，不然会报错。\r\n重写在多个父合约中都重名的函数时，override关键字后面要加上所有父合约名字，例如override(Yeye, Baba)。\r\n例子：\r\ncontract Erzi is Yeye, Baba{\r\n    // 继承两个function: hip()和pop()，输出值为Erzi。\r\n    function hip() public virtual override(Yeye, Baba){\r\n        emit Log(\"Erzi\");\r\n    }\r\n\r\n    function pop() public virtual override(Yeye, Baba) {\r\n        emit Log(\"Erzi\");\r\n    }\r\n修饰器的继承\r\nSolidity中的修饰器（Modifier）同样可以继承，用法与函数继承类似，在相应的地方加virtual和override关键字即可。\r\ncontract Base1 {\r\n    modifier exactDividedBy2And3(uint _a) virtual {\r\n        require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Identifier is Base1 {\r\n\r\n    //计算一个数分别被2除和被3除的值，但是传入的参数必须是2和3的倍数\r\n    function getExactDividedBy2And3(uint _dividend) public exactDividedBy2And3(_dividend) pure returns(uint, uint) {\r\n        return getExactDividedBy2And3WithoutModifier(_dividend);\r\n    }\r\n\r\n    //计算一个数分别被2除和被3除的值\r\n    function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returns(uint, uint){\r\n        uint div2 = _dividend / 2;\r\n        uint div3 = _dividend / 3;\r\n        return (div2, div3);\r\n    }\r\n}\r\nIdentifier合约可以直接在代码中使用父合约中的exactDividedBy2And3修饰器，也可以利用override关键字重写修饰器：\r\n    modifier exactDividedBy2And3(uint _a) override {\r\n        _;\r\n        require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);\r\n    }\r\n构造函数的继承\r\n子合约有两种方法继承父合约的构造函数。举个简单的例子，父合约A里面有一个状态变量a，并由构造函数的参数来确定：\r\n// 构造函数的继承\r\nabstract contract A {\r\n    uint public a;\r\n\r\n    constructor(uint _a) {\r\n        a = _a;\r\n    }\r\n}\r\n1.在继承时声明父构造函数的参数，例如：contract B is A(1)\r\n2.在子合约的构造函数中声明构造函数的参数，例如：\r\ncontract C is A {\r\n    constructor(uint _c) A(_c * _c) {}\r\n}\r\n调用父合约的函数\r\n子合约有两种调用父合约的函数\r\n\r\n直接调用：子合约可以直接用父合约名.函数名()的方式来调用父合约函数，例如Yeye.pop()。\r\n\r\n    function callParent() public{\r\n        Yeye.pop();\r\n    }\r\n\r\nsuper关键字：子合约可以利用super.函数名()来调用最近的父合约函数。solidity继承关系按声明时从右到左的顺序是：contract Erzi is Yeye, Baba，那么Baba是最近的父合约，super.pop()将调用Baba.pop()而不是Yeye.pop()：\r\n\r\n    function callParentSuper() public{\r\n        // 将调用最近的父合约函数，Baba.pop()\r\n        super.pop();\r\n    }\r\n14.抽象合约和接口\r\n抽象合约\r\n如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体{}中的内容，则必须将该合约标为abstract，不然编译会报错；另外，未实现的函数需要加virtual，以便子合约重写。拿我们之前的插入排序合约为例，如果我们还没想好具体怎么实现插入排序函数，那么可以把合约标为abstract，之后让别人补写上。\r\nabstract contract InsertionSort{\r\n    function insertionSort(uint[] memory a) public pure virtual returns(uint[] memory);\r\n}\r\n接口\r\n接口类似于抽象合约，但不实现任何功能。\r\n规则：\r\n\r\n不能包含状态变量\r\n不能包含构造函数\r\n不能继承除接口外的其他合约\r\n所有函数都必须是external且不能有函数体\r\n继承接口的合约必须实现接口定义的所有功能\r\n\r\n虽然接口不实现任何功能，但它非常重要。接口是智能合约的骨架，定义了合约的功能以及如何触发它们：如果智能合约实现了某种接口（比如ERC20或ERC721），其他Dapps和智能合约就知道如何与它交互。因为接口提供了两个重要的信息：\r\n1.合约里每个函数的bytes4选择器，以及基于它们的函数签名函数名(每个参数类型）。\r\n2.接口id（更多信息见EIP165）\r\n另外，接口与合约ABI（Application Binary\r\nInterface）等价，可以相互转换：编译接口可以得到合约的ABI，利用abi-to-sol工具也可以将ABI json文件转换为接口sol文件。\r\n我们以ERC721接口合约IERC721为例，它定义了3个event和9个function，所有ERC721标准的NFT都实现了这些函数。我们可以看到，接口和常规合约的区别在于每个函数都以;代替函数体{ }结尾。\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    \r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\nIERC721事件\r\nIERC721包含3个事件，其中Transfer和Approval事件在ERC20中也有。\r\n\r\nTransfer事件：在转账时被释放，记录代币的发出地址from，接收地址to和tokenid。\r\nApproval事件：在授权时释放，记录授权地址owner，被授权地址approved和tokenid。\r\nApprovalForAll事件：在批量授权时释放，记录批量授权的发出地址owner，被授权地址operator和授权与否的approved。\r\n\r\nIERC721函数\r\n\r\nbalanceOf：返回某地址的NFT持有量balance。\r\nownerOf：返回某tokenId的主人owner。\r\ntransferFrom：普通转账，参数为转出地址from，接收地址to和tokenId。\r\nsafeTransferFrom：安全转账（如果接收方是合约地址，会要求实现ERC721Receiver接口）。参数为转出地址from，接收地址to和tokenId。\r\napprove：授权另一个地址使用你的NFT。参数为被授权地址approve和tokenId。\r\ngetApproved：查询tokenId被批准给了哪个地址。\r\nsetApprovalForAll：将自己持有的该系列NFT批量授权给某个地址operator。\r\nisApprovedForAll：查询某地址的NFT是否批量授权给了另一个operator地址。\r\nsafeTransferFrom：安全转账的重载函数，参数里面包含了data。\r\n\r\n什么时候使用接口\r\n如果我们知道一个合约实现了IERC721接口，我们不需要知道它具体代码实现，就可以与它交互。\r\n无聊猿BAYC属于ERC721代币，实现了IERC721接口的功能。我们不需要知道它的源代码，只需知道它的合约地址，用IERC721接口就可以与它交互，比如用balanceOf()来查询某个地址的BAYC余额，用safeTransferFrom()来转账BAYC。\r\ncontract interactBAYC {\r\n    // 利用BAYC地址创建接口合约变量（ETH主网）\r\n    IERC721 BAYC = IERC721(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D);\r\n\r\n    // 通过接口调用BAYC的balanceOf()查询持仓量\r\n    function balanceOfBAYC(address owner) external view returns (uint256 balance){\r\n        return BAYC.balanceOf(owner);\r\n    }\r\n\r\n    // 通过接口调用BAYC的safeTransferFrom()安全转账\r\n    function safeTransferFromBAYC(address from, address to, uint256 tokenId) external{\r\n        BAYC.safeTransferFrom(from, to, tokenId);\r\n    }\r\n}\r\n15.异常\r\n写智能合约经常会出bug，solidity中的异常命令帮助我们debug。\r\nError\r\nerror是solidity 0.8版本新加的内容，方便且高效（省gas）地向用户解释操作失败的原因。人们可以在contract之外定义异常。下面，我们定义一个TransferNotOwner异常，当用户不是代币owner的时候尝试转账，会抛出错误：\r\nerror TransferNotOwner(); // 自定义error\r\n在执行当中，error必须搭配revert（回退）命令使用。\r\n    function transferOwner1(uint256 tokenId, address newOwner) public {\r\n        if(_owners[tokenId] != msg.sender){\r\n            revert TransferNotOwner();\r\n        }\r\n        _owners[tokenId] = newOwner;\r\n    }\r\n我们定义了一个transferOwner1()函数，它会检查代币的owner是不是发起人，如果不是，就会抛出TransferNotOwner异常；如果是的话，就会转账。\r\nRequire\r\nrequire命令是solidity 0.8版本之前抛出异常的常用方法，目前很多主流合约仍然还在使用它。它很好用，唯一的缺点就是gas随着描述异常的字符串长度增加，比error命令要高。使用方法：require(检查条件，\"异常的描述\")，当检查条件不成立的时候，就会抛出异常。\r\n我们用require命令重写一下上面的transferOwner函数：\r\n    function transferOwner2(uint256 tokenId, address newOwner) public {\r\n        require(_owners[tokenId] == msg.sender, \"Transfer Not Owner\");\r\n        _owners[tokenId] = newOwner;\r\n    }\r\n贴个在remix上验证的例子吧\r\n1.输入任意uint256数字和非0地址，调用transferOwner1，也就是error方法，控制台抛出了异常并显示我们自定义的TransferNotOwner。\r\n\r\n2.输入任意uint256数字和非0地址，调用transferOwner2，也就是require方法，控制台抛出了异常并打印出require中的字符串。\r\n\r\n3.输入任意uint256数字和非0地址，调用transferOwner3，也就是assert方法，控制台只抛出了异常。\r\n\r\nAssert\r\nassert命令一般用于程序员写程序debug，因为它不能解释抛出异常的原因（比require少个字符串）。它的用法很简单，assert(检查条件），当检查条件不成立的时候，就会抛出异常。\r\n我们用assert命令重写一下上面的transferOwner函数：\r\n    function transferOwner3(uint256 tokenId, address newOwner) public {\r\n        assert(_owners[tokenId] == msg.sender);\r\n        _owners[tokenId] = newOwner;\r\n    }\r\n三种方法的gas比较\r\n我们比较一下三种抛出异常的gas消耗，通过remix控制台的Debug按钮，能查到每次函数调用的gas消耗分别如下：\r\n\r\nerror方法gas消耗：24445\r\nrequire方法gas消耗：24743\r\nassert方法gas消耗：24446\r\n\r\n我们可以看到，error方法gas最少，其次是assert，require方法消耗gas最多！因此，error既可以告知用户抛出异常的原因，又能省gas，大家要多用！（注意，由于部署测试时间的不同，每个函数的gas消耗会有所不同，但是比较结果会是一致的。）\r\n","slug":"solidity入门","date":"2022-11-26T16:55:02.000Z","categories_index":"","tags_index":"solidity","author_index":"cocoZ"},{"id":"4a8c6c67f0d77f1d7a087ca184ac4b68","title":"hexo+github搭建个人博客","content":"搭建个人博客（hexo+github）\r\n准备工作\r\n安装git、安装node.js、还有npm啥的（在看到任务前就装好了的）\r\n## 在github上创建仓库\r\n仓库名字要和用户名一样！！！\r\n（github pages等一会儿就出来了）\r\n\r\n安装hexo\r\n桌面创建一个文件夹，在文件夹目录下打开git bash here\r\n\r\n安装hexo\r\nnpm install -g hexo-cli\r\n查看版本\r\nhexo -v\r\n初始化hexo、\r\nhexo init\r\n生成本地的hexo页面\r\nhexo s\r\n输入hexo g生成静态网站\r\n输入hexo s，然后浏览器打开localhost:4000，就可以本地访问了（Ctrl+c退出）\r\n连接GitHub与本地\r\n绑定个密钥：\r\n生成SSH Keys\r\nssh-keygen -t rsa -C \"你的邮箱地址\"\r\n在C/用户/16017/.ssh目录下打开这个，复制\r\n\r\n打开github的总setting，添加SSH Keys\r\n\r\n在目录下打开git bash here，输入以下命令\r\ngit config --global user.name cocoGenZ\r\ngit config --global user.email 160760796@qq.com\r\n打开博客根目录下的_config.yml文件，修改最后一行的配置\r\n  type: git\r\n  repository: https://github.com/cocoGenZ/cocoGenZ.github.io.git\r\n  branch: main\r\nTip:上面的repository在GitHub里面复制HTTPS那个\r\n\r\n安装一键部署插件\r\ncnpm install hexo-deployer-git --save(不知道为什么有这个save的我安装不了，就另外装了个cnpm来安装)（更新完就ok了`npm\r\n-g install npm@latest）\r\n分别输入一下三条命令\r\nhexo clean   #清除缓存文件 db.json 和已生成的静态文件 public\r\nhexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)\r\nhexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)\r\n最后访问博客的地址就可以啦https://cocogenz.github.io/\r\n\r\n改个主题吧\r\n安装一个yarn（命令行就能装，用npm来装）\r\nyarn add hexo-theme-aurora\r\n\r\n改改参数\r\n\r\n关于上传图片显示的问题\r\n将图片上传到网上，再用markdown引用\r\nhttps://sm.ms/\r\n这个网址很方便\r\n","slug":"hexo-github搭建个人博客","date":"2022-11-21T14:10:57.000Z","categories_index":"","tags_index":"博客","author_index":"cocoZ"},{"id":"7b9812fe6cbf2aba598dcdf2de807daf","title":"Test","content":"第一次搭博客，浅浅做个测试\r\n","slug":"Test","date":"2022-11-15T03:55:53.000Z","categories_index":"","tags_index":"","author_index":"cocoZ"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very\r\nfirst post. Check documentation for\r\nmore info. If you get any problems when using Hexo, you can find the\r\nanswer in troubleshooting or\r\nyou can ask me on GitHub.\r\nQuick Start\r\nCreate a new post\r\n$ hexo new \"My New Post\"\r\nMore info: Writing\r\nRun server\r\n$ hexo server\r\nMore info: Server\r\nGenerate static files\r\n$ hexo generate\r\nMore info: Generating\r\nDeploy to remote sites\r\n$ hexo deploy\r\nMore info: Deployment\r\n","slug":"hello-world","date":"2022-11-15T02:54:10.513Z","categories_index":"","tags_index":"","author_index":"cocoZ"}]